/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["/js/vendor"],{

/***/ "./node_modules/uikit/dist/js/components/notification.js":
/*!***************************************************************!*\
  !*** ./node_modules/uikit/dist/js/components/notification.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*! UIkit 3.14.1 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */\n\n(function (global, factory) {\n     true ? module.exports = factory(__webpack_require__(/*! uikit-util */ \"./node_modules/uikit/src/js/util/index.js\")) :\n    0;\n})(this, (function (uikitUtil) { 'use strict';\n\n    var Container = {\n      props: {\n        container: Boolean },\n\n\n      data: {\n        container: true },\n\n\n      computed: {\n        container(_ref) {let { container } = _ref;\n          return container === true && this.$container || container && uikitUtil.$(container);\n        } } };\n\n    var Component = {\n      mixins: [Container],\n\n      functional: true,\n\n      args: ['message', 'status'],\n\n      data: {\n        message: '',\n        status: '',\n        timeout: 5000,\n        group: null,\n        pos: 'top-center',\n        clsContainer: 'uk-notification',\n        clsClose: 'uk-notification-close',\n        clsMsg: 'uk-notification-message' },\n\n\n      install,\n\n      computed: {\n        marginProp(_ref) {let { pos } = _ref;\n          return \"margin\" + (uikitUtil.startsWith(pos, 'top') ? 'Top' : 'Bottom');\n        },\n\n        startProps() {\n          return { opacity: 0, [this.marginProp]: -this.$el.offsetHeight };\n        } },\n\n\n      created() {\n        const container =\n        uikitUtil.$(\".\" + this.clsContainer + \"-\" + this.pos, this.container) ||\n        uikitUtil.append(\n        this.container, \"<div class=\\\"\" +\n        this.clsContainer + \" \" + this.clsContainer + \"-\" + this.pos + \"\\\" style=\\\"display: block\\\"></div>\");\n\n\n        this.$mount(\n        uikitUtil.append(\n        container, \"<div class=\\\"\" +\n        this.clsMsg + (this.status ? \" \" + this.clsMsg + \"-\" + this.status : '') + \"\\\"> <a href class=\\\"\" +\n        this.clsClose + \"\\\" data-uk-close></a> <div>\" +\n        this.message + \"</div> </div>\"));\n\n\n\n      },\n\n      async connected() {\n        const margin = uikitUtil.toFloat(uikitUtil.css(this.$el, this.marginProp));\n        await uikitUtil.Transition.start(uikitUtil.css(this.$el, this.startProps), {\n          opacity: 1,\n          [this.marginProp]: margin });\n\n\n        if (this.timeout) {\n          this.timer = setTimeout(this.close, this.timeout);\n        }\n      },\n\n      events: {\n        click(e) {\n          if (uikitUtil.closest(e.target, 'a[href=\"#\"],a[href=\"\"]')) {\n            e.preventDefault();\n          }\n          this.close();\n        },\n\n        [uikitUtil.pointerEnter]() {\n          if (this.timer) {\n            clearTimeout(this.timer);\n          }\n        },\n\n        [uikitUtil.pointerLeave]() {\n          if (this.timeout) {\n            this.timer = setTimeout(this.close, this.timeout);\n          }\n        } },\n\n\n      methods: {\n        async close(immediate) {\n          const removeFn = (el) => {\n            const container = uikitUtil.parent(el);\n\n            uikitUtil.trigger(el, 'close', [this]);\n            uikitUtil.remove(el);\n\n            if (!(container != null && container.hasChildNodes())) {\n              uikitUtil.remove(container);\n            }\n          };\n\n          if (this.timer) {\n            clearTimeout(this.timer);\n          }\n\n          if (!immediate) {\n            await uikitUtil.Transition.start(this.$el, this.startProps);\n          }\n\n          removeFn(this.$el);\n        } } };\n\n\n\n    function install(UIkit) {\n      UIkit.notification.closeAll = function (group, immediate) {\n        uikitUtil.apply(document.body, (el) => {\n          const notification = UIkit.getComponent(el, 'notification');\n          if (notification && (!group || group === notification.group)) {\n            notification.close(immediate);\n          }\n        });\n      };\n    }\n\n    if (typeof window !== 'undefined' && window.UIkit) {\n      window.UIkit.component('notification', Component);\n    }\n\n    return Component;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvZGlzdC9qcy9jb21wb25lbnRzL25vdGlmaWNhdGlvbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLElBQUksS0FBNEQsNEJBQTRCLG1CQUFPLENBQUMsNkRBQVk7QUFDaEgsSUFBSSxDQUNpSTtBQUNySSxDQUFDLGdDQUFnQzs7QUFFakM7QUFDQTtBQUNBLDRCQUE0Qjs7O0FBRzVCO0FBQ0EseUJBQXlCOzs7QUFHekI7QUFDQSx5QkFBeUIsTUFBTSxZQUFZO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOzs7QUFHM0M7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTSxNQUFNO0FBQ3RDO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG1CQUFtQjtBQUNuQixXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7OztBQUdyQztBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Vpa2l0L2Rpc3QvanMvY29tcG9uZW50cy9ub3RpZmljYXRpb24uanM/ODBjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgVUlraXQgMy4xNC4xIHwgaHR0cHM6Ly93d3cuZ2V0dWlraXQuY29tIHwgKGMpIDIwMTQgLSAyMDIyIFlPT3RoZW1lIHwgTUlUIExpY2Vuc2UgKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgndWlraXQtdXRpbCcpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCd1aWtpdG5vdGlmaWNhdGlvbicsIFsndWlraXQtdXRpbCddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLlVJa2l0Tm90aWZpY2F0aW9uID0gZmFjdG9yeShnbG9iYWwuVUlraXQudXRpbCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICh1aWtpdFV0aWwpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIENvbnRhaW5lciA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNvbnRhaW5lcjogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29udGFpbmVyOiB0cnVlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29udGFpbmVyKF9yZWYpIHtsZXQgeyBjb250YWluZXIgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lciA9PT0gdHJ1ZSAmJiB0aGlzLiRjb250YWluZXIgfHwgY29udGFpbmVyICYmIHVpa2l0VXRpbC4kKGNvbnRhaW5lcik7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIENvbXBvbmVudCA9IHtcbiAgICAgIG1peGluczogW0NvbnRhaW5lcl0sXG5cbiAgICAgIGZ1bmN0aW9uYWw6IHRydWUsXG5cbiAgICAgIGFyZ3M6IFsnbWVzc2FnZScsICdzdGF0dXMnXSxcblxuICAgICAgZGF0YToge1xuICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICAgICAgc3RhdHVzOiAnJyxcbiAgICAgICAgdGltZW91dDogNTAwMCxcbiAgICAgICAgZ3JvdXA6IG51bGwsXG4gICAgICAgIHBvczogJ3RvcC1jZW50ZXInLFxuICAgICAgICBjbHNDb250YWluZXI6ICd1ay1ub3RpZmljYXRpb24nLFxuICAgICAgICBjbHNDbG9zZTogJ3VrLW5vdGlmaWNhdGlvbi1jbG9zZScsXG4gICAgICAgIGNsc01zZzogJ3VrLW5vdGlmaWNhdGlvbi1tZXNzYWdlJyB9LFxuXG5cbiAgICAgIGluc3RhbGwsXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIG1hcmdpblByb3AoX3JlZikge2xldCB7IHBvcyB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gXCJtYXJnaW5cIiArICh1aWtpdFV0aWwuc3RhcnRzV2l0aChwb3MsICd0b3AnKSA/ICdUb3AnIDogJ0JvdHRvbScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0UHJvcHMoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgb3BhY2l0eTogMCwgW3RoaXMubWFyZ2luUHJvcF06IC10aGlzLiRlbC5vZmZzZXRIZWlnaHQgfTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9XG4gICAgICAgIHVpa2l0VXRpbC4kKFwiLlwiICsgdGhpcy5jbHNDb250YWluZXIgKyBcIi1cIiArIHRoaXMucG9zLCB0aGlzLmNvbnRhaW5lcikgfHxcbiAgICAgICAgdWlraXRVdGlsLmFwcGVuZChcbiAgICAgICAgdGhpcy5jb250YWluZXIsIFwiPGRpdiBjbGFzcz1cXFwiXCIgK1xuICAgICAgICB0aGlzLmNsc0NvbnRhaW5lciArIFwiIFwiICsgdGhpcy5jbHNDb250YWluZXIgKyBcIi1cIiArIHRoaXMucG9zICsgXCJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBibG9ja1xcXCI+PC9kaXY+XCIpO1xuXG5cbiAgICAgICAgdGhpcy4kbW91bnQoXG4gICAgICAgIHVpa2l0VXRpbC5hcHBlbmQoXG4gICAgICAgIGNvbnRhaW5lciwgXCI8ZGl2IGNsYXNzPVxcXCJcIiArXG4gICAgICAgIHRoaXMuY2xzTXNnICsgKHRoaXMuc3RhdHVzID8gXCIgXCIgKyB0aGlzLmNsc01zZyArIFwiLVwiICsgdGhpcy5zdGF0dXMgOiAnJykgKyBcIlxcXCI+IDxhIGhyZWYgY2xhc3M9XFxcIlwiICtcbiAgICAgICAgdGhpcy5jbHNDbG9zZSArIFwiXFxcIiBkYXRhLXVrLWNsb3NlPjwvYT4gPGRpdj5cIiArXG4gICAgICAgIHRoaXMubWVzc2FnZSArIFwiPC9kaXY+IDwvZGl2PlwiKSk7XG5cblxuXG4gICAgICB9LFxuXG4gICAgICBhc3luYyBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHVpa2l0VXRpbC50b0Zsb2F0KHVpa2l0VXRpbC5jc3ModGhpcy4kZWwsIHRoaXMubWFyZ2luUHJvcCkpO1xuICAgICAgICBhd2FpdCB1aWtpdFV0aWwuVHJhbnNpdGlvbi5zdGFydCh1aWtpdFV0aWwuY3NzKHRoaXMuJGVsLCB0aGlzLnN0YXJ0UHJvcHMpLCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBbdGhpcy5tYXJnaW5Qcm9wXTogbWFyZ2luIH0pO1xuXG5cbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuY2xvc2UsIHRoaXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBjbGljayhlKSB7XG4gICAgICAgICAgaWYgKHVpa2l0VXRpbC5jbG9zZXN0KGUudGFyZ2V0LCAnYVtocmVmPVwiI1wiXSxhW2hyZWY9XCJcIl0nKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgW3Vpa2l0VXRpbC5wb2ludGVyRW50ZXJdKCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFt1aWtpdFV0aWwucG9pbnRlckxlYXZlXSgpIHtcbiAgICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCh0aGlzLmNsb3NlLCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgY2xvc2UoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgY29uc3QgcmVtb3ZlRm4gPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHVpa2l0VXRpbC5wYXJlbnQoZWwpO1xuXG4gICAgICAgICAgICB1aWtpdFV0aWwudHJpZ2dlcihlbCwgJ2Nsb3NlJywgW3RoaXNdKTtcbiAgICAgICAgICAgIHVpa2l0VXRpbC5yZW1vdmUoZWwpO1xuXG4gICAgICAgICAgICBpZiAoIShjb250YWluZXIgIT0gbnVsbCAmJiBjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSkge1xuICAgICAgICAgICAgICB1aWtpdFV0aWwucmVtb3ZlKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHVpa2l0VXRpbC5UcmFuc2l0aW9uLnN0YXJ0KHRoaXMuJGVsLCB0aGlzLnN0YXJ0UHJvcHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbW92ZUZuKHRoaXMuJGVsKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbChVSWtpdCkge1xuICAgICAgVUlraXQubm90aWZpY2F0aW9uLmNsb3NlQWxsID0gZnVuY3Rpb24gKGdyb3VwLCBpbW1lZGlhdGUpIHtcbiAgICAgICAgdWlraXRVdGlsLmFwcGx5KGRvY3VtZW50LmJvZHksIChlbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IFVJa2l0LmdldENvbXBvbmVudChlbCwgJ25vdGlmaWNhdGlvbicpO1xuICAgICAgICAgIGlmIChub3RpZmljYXRpb24gJiYgKCFncm91cCB8fCBncm91cCA9PT0gbm90aWZpY2F0aW9uLmdyb3VwKSkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uLmNsb3NlKGltbWVkaWF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5VSWtpdCkge1xuICAgICAgd2luZG93LlVJa2l0LmNvbXBvbmVudCgnbm90aWZpY2F0aW9uJywgQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ29tcG9uZW50O1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uikit/dist/js/components/notification.js\n");

/***/ }),

/***/ "./node_modules/uikit/dist/js/uikit-icons.js":
/*!***************************************************!*\
  !*** ./node_modules/uikit/dist/js/uikit-icons.js ***!
  \***************************************************/
/***/ (function(module) {

eval("/*! UIkit 3.14.1 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    function plugin(UIkit) {\n      if (plugin.installed) {\n        return;\n      }\n\n      UIkit.icon.add({\n        \"500px\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M9.624,11.866c-0.141,0.132,0.479,0.658,0.662,0.418c0.051-0.046,0.607-0.61,0.662-0.664c0,0,0.738,0.719,0.814,0.719 c0.1,0,0.207-0.055,0.322-0.17c0.27-0.269,0.135-0.416,0.066-0.495l-0.631-0.616l0.658-0.668c0.146-0.156,0.021-0.314-0.1-0.449 c-0.182-0.18-0.359-0.226-0.471-0.125l-0.656,0.654l-0.654-0.654c-0.033-0.034-0.08-0.045-0.124-0.045 c-0.079,0-0.191,0.068-0.307,0.181c-0.202,0.202-0.247,0.351-0.133,0.462l0.665,0.665L9.624,11.866z\\\"/><path d=\\\"M11.066,2.884c-1.061,0-2.185,0.248-3.011,0.604c-0.087,0.034-0.141,0.106-0.15,0.205C7.893,3.784,7.919,3.909,7.982,4.066 c0.05,0.136,0.187,0.474,0.452,0.372c0.844-0.326,1.779-0.507,2.633-0.507c0.963,0,1.9,0.191,2.781,0.564 c0.695,0.292,1.357,0.719,2.078,1.34c0.051,0.044,0.105,0.068,0.164,0.068c0.143,0,0.273-0.137,0.389-0.271 c0.191-0.214,0.324-0.395,0.135-0.575c-0.686-0.654-1.436-1.138-2.363-1.533C13.24,3.097,12.168,2.884,11.066,2.884z\\\"/><path d=\\\"M16.43,15.747c-0.092-0.028-0.242,0.05-0.309,0.119l0,0c-0.652,0.652-1.42,1.169-2.268,1.521 c-0.877,0.371-1.814,0.551-2.779,0.551c-0.961,0-1.896-0.189-2.775-0.564c-0.848-0.36-1.612-0.879-2.268-1.53 c-0.682-0.688-1.196-1.455-1.529-2.268c-0.325-0.799-0.471-1.643-0.471-1.643c-0.045-0.24-0.258-0.249-0.567-0.203 c-0.128,0.021-0.519,0.079-0.483,0.36v0.01c0.105,0.644,0.289,1.284,0.545,1.895c0.417,0.969,1.002,1.849,1.756,2.604 c0.757,0.754,1.636,1.34,2.604,1.757C8.901,18.785,9.97,19,11.088,19c1.104,0,2.186-0.215,3.188-0.645 c1.838-0.896,2.604-1.757,2.604-1.757c0.182-0.204,0.227-0.317-0.1-0.643C16.779,15.956,16.525,15.774,16.43,15.747z\\\"/><path d=\\\"M5.633,13.287c0.293,0.71,0.723,1.341,1.262,1.882c0.54,0.54,1.172,0.971,1.882,1.264c0.731,0.303,1.509,0.461,2.298,0.461 c0.801,0,1.578-0.158,2.297-0.461c0.711-0.293,1.344-0.724,1.883-1.264c0.543-0.541,0.971-1.172,1.264-1.882 c0.314-0.721,0.463-1.5,0.463-2.298c0-0.79-0.148-1.569-0.463-2.289c-0.293-0.699-0.721-1.329-1.264-1.881 c-0.539-0.541-1.172-0.959-1.867-1.263c-0.721-0.303-1.5-0.461-2.299-0.461c-0.802,0-1.613,0.159-2.322,0.461 c-0.577,0.25-1.544,0.867-2.119,1.454v0.012V2.108h8.16C15.1,2.104,15.1,1.69,15.1,1.552C15.1,1.417,15.1,1,14.809,1H5.915 C5.676,1,5.527,1.192,5.527,1.384v6.84c0,0.214,0.273,0.372,0.529,0.428c0.5,0.105,0.614-0.056,0.737-0.224l0,0 c0.18-0.273,0.776-0.884,0.787-0.894c0.901-0.905,2.117-1.408,3.416-1.408c1.285,0,2.5,0.501,3.412,1.408 c0.914,0.914,1.408,2.122,1.408,3.405c0,1.288-0.508,2.496-1.408,3.405c-0.9,0.896-2.152,1.406-3.438,1.406 c-0.877,0-1.711-0.229-2.433-0.671v-4.158c0-0.553,0.237-1.151,0.643-1.614c0.462-0.519,1.094-0.799,1.782-0.799 c0.664,0,1.293,0.253,1.758,0.715c0.459,0.459,0.709,1.071,0.709,1.723c0,1.385-1.094,2.468-2.488,2.468 c-0.273,0-0.769-0.121-0.781-0.125c-0.281-0.087-0.405,0.306-0.438,0.436c-0.159,0.496,0.079,0.585,0.123,0.607 c0.452,0.137,0.743,0.157,1.129,0.157c1.973,0,3.572-1.6,3.572-3.57c0-1.964-1.6-3.552-3.572-3.552c-0.97,0-1.872,0.36-2.546,1.038 c-0.656,0.631-1.027,1.487-1.027,2.322v3.438v-0.011c-0.372-0.42-0.732-1.041-0.981-1.682c-0.102-0.248-0.315-0.202-0.607-0.113 c-0.135,0.035-0.519,0.157-0.44,0.439C5.372,12.799,5.577,13.164,5.633,13.287z\\\"/></svg>\",\n        \"album\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"5\\\" y=\\\"2\\\" width=\\\"10\\\" height=\\\"1\\\"/><rect x=\\\"3\\\" y=\\\"4\\\" width=\\\"14\\\" height=\\\"1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"1.5\\\" y=\\\"6.5\\\" width=\\\"17\\\" height=\\\"11\\\"/></svg>\",\n        \"arrow-down\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"10.5,16.08 5.63,10.66 6.37,10 10.5,14.58 14.63,10 15.37,10.66\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"10.5\\\" y1=\\\"4\\\" x2=\\\"10.5\\\" y2=\\\"15\\\"/></svg>\",\n        \"arrow-left\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"10 14 5 9.5 10 5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"16\\\" y1=\\\"9.5\\\" x2=\\\"5\\\" y2=\\\"9.52\\\"/></svg>\",\n        \"arrow-right\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"10 5 15 9.5 10 14\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"4\\\" y1=\\\"9.5\\\" x2=\\\"15\\\" y2=\\\"9.5\\\"/></svg>\",\n        \"arrow-up\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"10.5,4 15.37,9.4 14.63,10.08 10.5,5.49 6.37,10.08 5.63,9.4\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"10.5\\\" y1=\\\"16\\\" x2=\\\"10.5\\\" y2=\\\"5\\\"/></svg>\",\n        \"bag\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M7.5,7.5V4A2.48,2.48,0,0,1,10,1.5,2.54,2.54,0,0,1,12.5,4V7.5\\\"/><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"16.5 7.5 3.5 7.5 2.5 18.5 17.5 18.5 16.5 7.5\\\"/></svg>\",\n        \"ban\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"4\\\" y1=\\\"3.5\\\" x2=\\\"16\\\" y2=\\\"16.5\\\"/></svg>\",\n        \"behance\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M9.5,10.6c-0.4-0.5-0.9-0.9-1.6-1.1c1.7-1,2.2-3.2,0.7-4.7C7.8,4,6.3,4,5.2,4C3.5,4,1.7,4,0,4v12c1.7,0,3.4,0,5.2,0 c1,0,2.1,0,3.1-0.5C10.2,14.6,10.5,12.3,9.5,10.6L9.5,10.6z M5.6,6.1c1.8,0,1.8,2.7-0.1,2.7c-1,0-2,0-2.9,0V6.1H5.6z M2.6,13.8v-3.1 c1.1,0,2.1,0,3.2,0c2.1,0,2.1,3.2,0.1,3.2L2.6,13.8z\\\"/><path d=\\\"M19.9,10.9C19.7,9.2,18.7,7.6,17,7c-4.2-1.3-7.3,3.4-5.3,7.1c0.9,1.7,2.8,2.3,4.7,2.1c1.7-0.2,2.9-1.3,3.4-2.9h-2.2 c-0.4,1.3-2.4,1.5-3.5,0.6c-0.4-0.4-0.6-1.1-0.6-1.7H20C20,11.7,19.9,10.9,19.9,10.9z M13.5,10.6c0-1.6,2.3-2.7,3.5-1.4 c0.4,0.4,0.5,0.9,0.6,1.4H13.5L13.5,10.6z\\\"/><rect x=\\\"13\\\" y=\\\"4\\\" width=\\\"5\\\" height=\\\"1.4\\\"/></svg>\",\n        \"bell\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M17,15.5 L3,15.5 C2.99,14.61 3.79,13.34 4.1,12.51 C4.58,11.3 4.72,10.35 5.19,7.01 C5.54,4.53 5.89,3.2 7.28,2.16 C8.13,1.56 9.37,1.5 9.81,1.5 L9.96,1.5 C9.96,1.5 11.62,1.41 12.67,2.17 C14.08,3.2 14.42,4.54 14.77,7.02 C15.26,10.35 15.4,11.31 15.87,12.52 C16.2,13.34 17.01,14.61 17,15.5 L17,15.5 Z\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M12.39,16 C12.39,17.37 11.35,18.43 9.91,18.43 C8.48,18.43 7.42,17.37 7.42,16\\\"/></svg>\",\n        \"bold\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M5,15.3 C5.66,15.3 5.9,15 5.9,14.53 L5.9,5.5 C5.9,4.92 5.56,4.7 5,4.7 L5,4 L8.95,4 C12.6,4 13.7,5.37 13.7,6.9 C13.7,7.87 13.14,9.17 10.86,9.59 L10.86,9.7 C13.25,9.86 14.29,11.28 14.3,12.54 C14.3,14.47 12.94,16 9,16 L5,16 L5,15.3 Z M9,9.3 C11.19,9.3 11.8,8.5 11.85,7 C11.85,5.65 11.3,4.8 9,4.8 L7.67,4.8 L7.67,9.3 L9,9.3 Z M9.185,15.22 C11.97,15 12.39,14 12.4,12.58 C12.4,11.15 11.39,10 9,10 L7.67,10 L7.67,15 L9.18,15 Z\\\"/></svg>\",\n        \"bolt\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M4.74,20 L7.73,12 L3,12 L15.43,1 L12.32,9 L17.02,9 L4.74,20 L4.74,20 L4.74,20 Z M9.18,11 L7.1,16.39 L14.47,10 L10.86,10 L12.99,4.67 L5.61,11 L9.18,11 L9.18,11 L9.18,11 Z\\\"/></svg>\",\n        \"bookmark\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"5.5 1.5 15.5 1.5 15.5 17.5 10.5 12.5 5.5 17.5\\\"/></svg>\",\n        \"calendar\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M 2,3 2,17 18,17 18,3 2,3 Z M 17,16 3,16 3,8 17,8 17,16 Z M 17,7 3,7 3,4 17,4 17,7 Z\\\"/><rect width=\\\"1\\\" height=\\\"3\\\" x=\\\"6\\\" y=\\\"2\\\"/><rect width=\\\"1\\\" height=\\\"3\\\" x=\\\"13\\\" y=\\\"2\\\"/></svg>\",\n        \"camera\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10.8\\\" r=\\\"3.8\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M1,4.5 C0.7,4.5 0.5,4.7 0.5,5 L0.5,17 C0.5,17.3 0.7,17.5 1,17.5 L19,17.5 C19.3,17.5 19.5,17.3 19.5,17 L19.5,5 C19.5,4.7 19.3,4.5 19,4.5 L13.5,4.5 L13.5,2.9 C13.5,2.6 13.3,2.5 13,2.5 L7,2.5 C6.7,2.5 6.5,2.6 6.5,2.9 L6.5,4.5 L1,4.5 L1,4.5 Z\\\"/></svg>\",\n        \"cart\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"7.3\\\" cy=\\\"17.3\\\" r=\\\"1.4\\\"/><circle cx=\\\"13.3\\\" cy=\\\"17.3\\\" r=\\\"1.4\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"0 2 3.2 4 5.3 12.5 16 12.5 18 6.5 8 6.5\\\"/></svg>\",\n        \"check\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" points=\\\"4,10 8,15 17,4\\\"/></svg>\",\n        \"chevron-double-left\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"10 14 6 10 10 6\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"14 14 10 10 14 6\\\"/></svg>\",\n        \"chevron-double-right\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"10 6 14 10 10 14\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"6 6 10 10 6 14\\\"/></svg>\",\n        \"chevron-down\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"16 7 10 13 4 7\\\"/></svg>\",\n        \"chevron-left\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"13 16 7 10 13 4\\\"/></svg>\",\n        \"chevron-right\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"7 4 13 10 7 16\\\"/></svg>\",\n        \"chevron-up\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" points=\\\"4 13 10 7 16 13\\\"/></svg>\",\n        \"clock\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/><rect x=\\\"9\\\" y=\\\"4\\\" width=\\\"1\\\" height=\\\"7\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M13.018,14.197 L9.445,10.625\\\"/></svg>\",\n        \"close\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.06\\\" d=\\\"M16,16 L4,4\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.06\\\" d=\\\"M16,4 L4,16\\\"/></svg>\",\n        \"cloud-download\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.3,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"11.75 16 9.5 18.25 7.25 16\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M9.5,18 L9.5,9.5\\\"/></svg>\",\n        \"cloud-upload\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.31,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"7.25 11.75 9.5 9.5 11.75 11.75\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M9.5,18 L9.5,9.5\\\"/></svg>\",\n        \"code\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" points=\\\"13,4 19,10 13,16\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" points=\\\"7,4 1,10 7,16\\\"/></svg>\",\n        \"cog\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"9.997\\\" cy=\\\"10\\\" r=\\\"3.31\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M18.488,12.285 L16.205,16.237 C15.322,15.496 14.185,15.281 13.303,15.791 C12.428,16.289 12.047,17.373 12.246,18.5 L7.735,18.5 C7.938,17.374 7.553,16.299 6.684,15.791 C5.801,15.27 4.655,15.492 3.773,16.237 L1.5,12.285 C2.573,11.871 3.317,10.999 3.317,9.991 C3.305,8.98 2.573,8.121 1.5,7.716 L3.765,3.784 C4.645,4.516 5.794,4.738 6.687,4.232 C7.555,3.722 7.939,2.637 7.735,1.5 L12.263,1.5 C12.072,2.637 12.441,3.71 13.314,4.22 C14.206,4.73 15.343,4.516 16.225,3.794 L18.487,7.714 C17.404,8.117 16.661,8.988 16.67,10.009 C16.672,11.018 17.415,11.88 18.488,12.285 L18.488,12.285 Z\\\"/></svg>\",\n        \"comment\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M6,18.71 L6,14 L1,14 L1,1 L19,1 L19,14 L10.71,14 L6,18.71 L6,18.71 Z M2,13 L7,13 L7,16.29 L10.29,13 L18,13 L18,2 L2,2 L2,13 L2,13 Z\\\"/></svg>\",\n        \"commenting\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"1.5,1.5 18.5,1.5 18.5,13.5 10.5,13.5 6.5,17.5 6.5,13.5 1.5,13.5\\\"/><circle cx=\\\"10\\\" cy=\\\"8\\\" r=\\\"1\\\"/><circle cx=\\\"6\\\" cy=\\\"8\\\" r=\\\"1\\\"/><circle cx=\\\"14\\\" cy=\\\"8\\\" r=\\\"1\\\"/></svg>\",\n        \"comments\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"2 0.5 19.5 0.5 19.5 13\\\"/><path d=\\\"M5,19.71 L5,15 L0,15 L0,2 L18,2 L18,15 L9.71,15 L5,19.71 L5,19.71 L5,19.71 Z M1,14 L6,14 L6,17.29 L9.29,14 L17,14 L17,3 L1,3 L1,14 L1,14 L1,14 Z\\\"/></svg>\",\n        \"copy\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"3.5\\\" y=\\\"2.5\\\" width=\\\"12\\\" height=\\\"16\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"5 0.5 17.5 0.5 17.5 17\\\"/></svg>\",\n        \"credit-card\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"1.5\\\" y=\\\"4.5\\\" width=\\\"17\\\" height=\\\"12\\\"/><rect x=\\\"1\\\" y=\\\"7\\\" width=\\\"18\\\" height=\\\"3\\\"/></svg>\",\n        \"database\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><ellipse fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"4.64\\\" rx=\\\"7.5\\\" ry=\\\"3.14\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M17.5,8.11 C17.5,9.85 14.14,11.25 10,11.25 C5.86,11.25 2.5,9.84 2.5,8.11\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M17.5,11.25 C17.5,12.99 14.14,14.39 10,14.39 C5.86,14.39 2.5,12.98 2.5,11.25\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M17.49,4.64 L17.5,14.36 C17.5,16.1 14.14,17.5 10,17.5 C5.86,17.5 2.5,16.09 2.5,14.36 L2.5,4.64\\\"/></svg>\",\n        \"desktop\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"8\\\" y=\\\"15\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"11\\\" y=\\\"15\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"5\\\" y=\\\"16\\\" width=\\\"10\\\" height=\\\"1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"1.5\\\" y=\\\"3.5\\\" width=\\\"17\\\" height=\\\"11\\\"/></svg>\",\n        \"discord\": \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\"><path d=\\\"M16.074,4.361a14.243,14.243,0,0,0-3.61-1.134,10.61,10.61,0,0,0-.463.96,13.219,13.219,0,0,0-4,0,10.138,10.138,0,0,0-.468-.96A14.206,14.206,0,0,0,3.919,4.364,15.146,15.146,0,0,0,1.324,14.5a14.435,14.435,0,0,0,4.428,2.269A10.982,10.982,0,0,0,6.7,15.21a9.294,9.294,0,0,1-1.494-.727c.125-.093.248-.19.366-.289a10.212,10.212,0,0,0,8.854,0c.119.1.242.2.366.289a9.274,9.274,0,0,1-1.5.728,10.8,10.8,0,0,0,.948,1.562,14.419,14.419,0,0,0,4.431-2.27A15.128,15.128,0,0,0,16.074,4.361Zm-8.981,8.1a1.7,1.7,0,0,1-1.573-1.79A1.689,1.689,0,0,1,7.093,8.881a1.679,1.679,0,0,1,1.573,1.791A1.687,1.687,0,0,1,7.093,12.462Zm5.814,0a1.7,1.7,0,0,1-1.573-1.79,1.689,1.689,0,0,1,1.573-1.791,1.679,1.679,0,0,1,1.573,1.791A1.688,1.688,0,0,1,12.907,12.462Z\\\"/></svg>\",\n        \"download\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"14,10 9.5,14.5 5,10\\\"/><rect x=\\\"3\\\" y=\\\"17\\\" width=\\\"13\\\" height=\\\"1\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"9.5\\\" y1=\\\"13.91\\\" x2=\\\"9.5\\\" y2=\\\"3\\\"/></svg>\",\n        \"dribbble\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" d=\\\"M1.3,8.9c0,0,5,0.1,8.6-1c1.4-0.4,2.6-0.9,4-1.9 c1.4-1.1,2.5-2.5,2.5-2.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" d=\\\"M3.9,16.6c0,0,1.7-2.8,3.5-4.2 c1.8-1.3,4-2,5.7-2.2C16,10,19,10.6,19,10.6\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" d=\\\"M6.9,1.6c0,0,3.3,4.6,4.2,6.8 c0.4,0.9,1.3,3.1,1.9,5.2c0.6,2,0.9,4.4,0.9,4.4\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/></svg>\",\n        \"etsy\": \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\"><path d=\\\"M8,4.26C8,4.07,8,4,8.31,4h4.46c.79,0,1.22.67,1.53,1.91l.25,1h.76c.14-2.82.26-4,.26-4S13.65,3,12.52,3H6.81L3.75,2.92v.84l1,.2c.73.11.9.27,1,1,0,0,.06,2,.06,5.17s-.06,5.14-.06,5.14c0,.59-.23.81-1,.94l-1,.2v.84l3.06-.1h5.11c1.15,0,3.82.1,3.82.1,0-.7.45-3.88.51-4.22h-.73l-.76,1.69a2.25,2.25,0,0,1-2.45,1.47H9.4c-1,0-1.44-.4-1.44-1.24V10.44s2.16,0,2.86.06c.55,0,.85.19,1.06,1l.23,1H13L12.9,9.94,13,7.41h-.85l-.28,1.13c-.16.74-.28.84-1,1-1,.1-2.89.09-2.89.09Z\\\"/></svg>\",\n        \"expand\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"13 2 18 2 18 7 17 7 17 3 13 3\\\"/><polygon points=\\\"2 13 3 13 3 17 7 17 7 18 2 18\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M11,9 L17,3\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M3,17 L9,11\\\"/></svg>\",\n        \"facebook\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M11,10h2.6l0.4-3H11V5.3c0-0.9,0.2-1.5,1.5-1.5H14V1.1c-0.3,0-1-0.1-2.1-0.1C9.6,1,8,2.4,8,5v2H5.5v3H8v8h3V10z\\\"/></svg>\",\n        \"file-edit\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M18.65,1.68 C18.41,1.45 18.109,1.33 17.81,1.33 C17.499,1.33 17.209,1.45 16.98,1.68 L8.92,9.76 L8,12.33 L10.55,11.41 L18.651,3.34 C19.12,2.87 19.12,2.15 18.65,1.68 L18.65,1.68 L18.65,1.68 Z\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"16.5 8.482 16.5 18.5 3.5 18.5 3.5 1.5 14.211 1.5\\\"/></svg>\",\n        \"file-pdf\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" width=\\\"13\\\" height=\\\"17\\\" x=\\\"3.5\\\" y=\\\"1.5\\\"/><path d=\\\"M14.65 11.67c-.48.3-1.37-.19-1.79-.37a4.65 4.65 0 0 1 1.49.06c.35.1.36.28.3.31zm-6.3.06l.43-.79a14.7 14.7 0 0 0 .75-1.64 5.48 5.48 0 0 0 1.25 1.55l.2.15a16.36 16.36 0 0 0-2.63.73zM9.5 5.32c.2 0 .32.5.32.97a1.99 1.99 0 0 1-.23 1.04 5.05 5.05 0 0 1-.17-1.3s0-.71.08-.71zm-3.9 9a4.35 4.35 0 0 1 1.21-1.46l.24-.22a4.35 4.35 0 0 1-1.46 1.68zm9.23-3.3a2.05 2.05 0 0 0-1.32-.3 11.07 11.07 0 0 0-1.58.11 4.09 4.09 0 0 1-.74-.5 5.39 5.39 0 0 1-1.32-2.06 10.37 10.37 0 0 0 .28-2.62 1.83 1.83 0 0 0-.07-.25.57.57 0 0 0-.52-.4H9.4a.59.59 0 0 0-.6.38 6.95 6.95 0 0 0 .37 3.14c-.26.63-1 2.12-1 2.12-.3.58-.57 1.08-.82 1.5l-.8.44A3.11 3.11 0 0 0 5 14.16a.39.39 0 0 0 .15.42l.24.13c1.15.56 2.28-1.74 2.66-2.42a23.1 23.1 0 0 1 3.59-.85 4.56 4.56 0 0 0 2.91.8.5.5 0 0 0 .3-.21 1.1 1.1 0 0 0 .12-.75.84.84 0 0 0-.14-.25z\\\"/></svg>\",\n        \"file-text\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" width=\\\"13\\\" height=\\\"17\\\" x=\\\"3.5\\\" y=\\\"1.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"6\\\" x2=\\\"12\\\" y1=\\\"12.5\\\" y2=\\\"12.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"6\\\" x2=\\\"14\\\" y1=\\\"8.5\\\" y2=\\\"8.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"6\\\" x2=\\\"14\\\" y1=\\\"6.5\\\" y2=\\\"6.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"6\\\" x2=\\\"14\\\" y1=\\\"10.5\\\" y2=\\\"10.5\\\"/></svg>\",\n        \"file\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"3.5\\\" y=\\\"1.5\\\" width=\\\"13\\\" height=\\\"17\\\"/></svg>\",\n        \"flickr\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"5.5\\\" cy=\\\"9.5\\\" r=\\\"3.5\\\"/><circle cx=\\\"14.5\\\" cy=\\\"9.5\\\" r=\\\"3.5\\\"/></svg>\",\n        \"folder\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"9.5 5.5 8.5 3.5 1.5 3.5 1.5 16.5 18.5 16.5 18.5 5.5\\\"/></svg>\",\n        \"forward\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M2.47,13.11 C4.02,10.02 6.27,7.85 9.04,6.61 C9.48,6.41 10.27,6.13 11,5.91 L11,2 L18.89,9 L11,16 L11,12.13 C9.25,12.47 7.58,13.19 6.02,14.25 C3.03,16.28 1.63,18.54 1.63,18.54 C1.63,18.54 1.38,15.28 2.47,13.11 L2.47,13.11 Z M5.3,13.53 C6.92,12.4 9.04,11.4 12,10.92 L12,13.63 L17.36,9 L12,4.25 L12,6.8 C11.71,6.86 10.86,7.02 9.67,7.49 C6.79,8.65 4.58,10.96 3.49,13.08 C3.18,13.7 2.68,14.87 2.49,16 C3.28,15.05 4.4,14.15 5.3,13.53 L5.3,13.53 Z\\\"/></svg>\",\n        \"foursquare\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M15.23,2 C15.96,2 16.4,2.41 16.5,2.86 C16.57,3.15 16.56,3.44 16.51,3.73 C16.46,4.04 14.86,11.72 14.75,12.03 C14.56,12.56 14.16,12.82 13.61,12.83 C13.03,12.84 11.09,12.51 10.69,13 C10.38,13.38 7.79,16.39 6.81,17.53 C6.61,17.76 6.4,17.96 6.08,17.99 C5.68,18.04 5.29,17.87 5.17,17.45 C5.12,17.28 5.1,17.09 5.1,16.91 C5.1,12.4 4.86,7.81 5.11,3.31 C5.17,2.5 5.81,2.12 6.53,2 L15.23,2 L15.23,2 Z M9.76,11.42 C9.94,11.19 10.17,11.1 10.45,11.1 L12.86,11.1 C13.12,11.1 13.31,10.94 13.36,10.69 C13.37,10.64 13.62,9.41 13.74,8.83 C13.81,8.52 13.53,8.28 13.27,8.28 C12.35,8.29 11.42,8.28 10.5,8.28 C9.84,8.28 9.83,7.69 9.82,7.21 C9.8,6.85 10.13,6.55 10.5,6.55 C11.59,6.56 12.67,6.55 13.76,6.55 C14.03,6.55 14.23,6.4 14.28,6.14 C14.34,5.87 14.67,4.29 14.67,4.29 C14.67,4.29 14.82,3.74 14.19,3.74 L7.34,3.74 C7,3.75 6.84,4.02 6.84,4.33 C6.84,7.58 6.85,14.95 6.85,14.99 C6.87,15 8.89,12.51 9.76,11.42 L9.76,11.42 Z\\\"/></svg>\",\n        \"future\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline points=\\\"19 2 18 2 18 6 14 6 14 7 19 7 19 2\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M18,6.548 C16.709,3.29 13.354,1 9.6,1 C4.6,1 0.6,5 0.6,10 C0.6,15 4.6,19 9.6,19 C14.6,19 18.6,15 18.6,10\\\"/><rect x=\\\"9\\\" y=\\\"4\\\" width=\\\"1\\\" height=\\\"7\\\"/><path d=\\\"M13.018,14.197 L9.445,10.625\\\" fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\"/></svg>\",\n        \"git-branch\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"7\\\" cy=\\\"3\\\" r=\\\"2\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"14\\\" cy=\\\"6\\\" r=\\\"2\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"7\\\" cy=\\\"17\\\" r=\\\"2\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" d=\\\"M14,8 C14,10.41 12.43,10.87 10.56,11.25 C9.09,11.54 7,12.06 7,15 L7,5\\\"/></svg>\",\n        \"git-fork\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"5.79\\\" cy=\\\"2.79\\\" r=\\\"1.79\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"14.19\\\" cy=\\\"2.79\\\" r=\\\"1.79\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" cx=\\\"10.03\\\" cy=\\\"16.79\\\" r=\\\"1.79\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" d=\\\"M5.79,4.57 L5.79,6.56 C5.79,9.19 10.03,10.22 10.03,13.31 C10.03,14.86 10.04,14.55 10.04,14.55 C10.04,14.37 10.04,14.86 10.04,13.31 C10.04,10.22 14.2,9.19 14.2,6.56 L14.2,4.57\\\"/></svg>\",\n        \"github-alt\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10,0.5 C4.75,0.5 0.5,4.76 0.5,10.01 C0.5,15.26 4.75,19.51 10,19.51 C15.24,19.51 19.5,15.26 19.5,10.01 C19.5,4.76 15.25,0.5 10,0.5 L10,0.5 Z M12.81,17.69 C12.81,17.69 12.81,17.7 12.79,17.69 C12.47,17.75 12.35,17.59 12.35,17.36 L12.35,16.17 C12.35,15.45 12.09,14.92 11.58,14.56 C12.2,14.51 12.77,14.39 13.26,14.21 C13.87,13.98 14.36,13.69 14.74,13.29 C15.42,12.59 15.76,11.55 15.76,10.17 C15.76,9.25 15.45,8.46 14.83,7.8 C15.1,7.08 15.07,6.29 14.75,5.44 L14.51,5.42 C14.34,5.4 14.06,5.46 13.67,5.61 C13.25,5.78 12.79,6.03 12.31,6.35 C11.55,6.16 10.81,6.05 10.09,6.05 C9.36,6.05 8.61,6.15 7.88,6.35 C7.28,5.96 6.75,5.68 6.26,5.54 C6.07,5.47 5.9,5.44 5.78,5.44 L5.42,5.44 C5.06,6.29 5.04,7.08 5.32,7.8 C4.7,8.46 4.4,9.25 4.4,10.17 C4.4,11.94 4.96,13.16 6.08,13.84 C6.53,14.13 7.05,14.32 7.69,14.43 C8.03,14.5 8.32,14.54 8.55,14.55 C8.07,14.89 7.82,15.42 7.82,16.16 L7.82,17.51 C7.8,17.69 7.7,17.8 7.51,17.8 C4.21,16.74 1.82,13.65 1.82,10.01 C1.82,5.5 5.49,1.83 10,1.83 C14.5,1.83 18.17,5.5 18.17,10.01 C18.18,13.53 15.94,16.54 12.81,17.69 L12.81,17.69 Z\\\"/></svg>\",\n        \"github\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10,1 C5.03,1 1,5.03 1,10 C1,13.98 3.58,17.35 7.16,18.54 C7.61,18.62 7.77,18.34 7.77,18.11 C7.77,17.9 7.76,17.33 7.76,16.58 C5.26,17.12 4.73,15.37 4.73,15.37 C4.32,14.33 3.73,14.05 3.73,14.05 C2.91,13.5 3.79,13.5 3.79,13.5 C4.69,13.56 5.17,14.43 5.17,14.43 C5.97,15.8 7.28,15.41 7.79,15.18 C7.87,14.6 8.1,14.2 8.36,13.98 C6.36,13.75 4.26,12.98 4.26,9.53 C4.26,8.55 4.61,7.74 5.19,7.11 C5.1,6.88 4.79,5.97 5.28,4.73 C5.28,4.73 6.04,4.49 7.75,5.65 C8.47,5.45 9.24,5.35 10,5.35 C10.76,5.35 11.53,5.45 12.25,5.65 C13.97,4.48 14.72,4.73 14.72,4.73 C15.21,5.97 14.9,6.88 14.81,7.11 C15.39,7.74 15.73,8.54 15.73,9.53 C15.73,12.99 13.63,13.75 11.62,13.97 C11.94,14.25 12.23,14.8 12.23,15.64 C12.23,16.84 12.22,17.81 12.22,18.11 C12.22,18.35 12.38,18.63 12.84,18.54 C16.42,17.35 19,13.98 19,10 C19,5.03 14.97,1 10,1 L10,1 Z\\\"/></svg>\",\n        \"gitter\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"3.5\\\" y=\\\"1\\\" width=\\\"1.531\\\" height=\\\"11.471\\\"/><rect x=\\\"7.324\\\" y=\\\"4.059\\\" width=\\\"1.529\\\" height=\\\"15.294\\\"/><rect x=\\\"11.148\\\" y=\\\"4.059\\\" width=\\\"1.527\\\" height=\\\"15.294\\\"/><rect x=\\\"14.971\\\" y=\\\"4.059\\\" width=\\\"1.529\\\" height=\\\"8.412\\\"/></svg>\",\n        \"google\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.86,9.09 C18.46,12.12 17.14,16.05 13.81,17.56 C9.45,19.53 4.13,17.68 2.47,12.87 C0.68,7.68 4.22,2.42 9.5,2.03 C11.57,1.88 13.42,2.37 15.05,3.65 C15.22,3.78 15.37,3.93 15.61,4.14 C14.9,4.81 14.23,5.45 13.5,6.14 C12.27,5.08 10.84,4.72 9.28,4.98 C8.12,5.17 7.16,5.76 6.37,6.63 C4.88,8.27 4.62,10.86 5.76,12.82 C6.95,14.87 9.17,15.8 11.57,15.25 C13.27,14.87 14.76,13.33 14.89,11.75 L10.51,11.75 L10.51,9.09 L17.86,9.09 L17.86,9.09 Z\\\"/></svg>\",\n        \"grid\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"2\\\" y=\\\"2\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"8\\\" y=\\\"2\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"14\\\" y=\\\"2\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"2\\\" y=\\\"8\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"8\\\" y=\\\"8\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"14\\\" y=\\\"8\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"2\\\" y=\\\"14\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"8\\\" y=\\\"14\\\" width=\\\"3\\\" height=\\\"3\\\"/><rect x=\\\"14\\\" y=\\\"14\\\" width=\\\"3\\\" height=\\\"3\\\"/></svg>\",\n        \"happy\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"13\\\" cy=\\\"7\\\" r=\\\"1\\\"/><circle cx=\\\"7\\\" cy=\\\"7\\\" r=\\\"1\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"8.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M14.6,11.4 C13.9,13.3 12.1,14.5 10,14.5 C7.9,14.5 6.1,13.3 5.4,11.4\\\"/></svg>\",\n        \"hashtag\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M15.431,8 L15.661,7 L12.911,7 L13.831,3 L12.901,3 L11.98,7 L9.29,7 L10.21,3 L9.281,3 L8.361,7 L5.23,7 L5,8 L8.13,8 L7.21,12 L4.23,12 L4,13 L6.98,13 L6.061,17 L6.991,17 L7.911,13 L10.601,13 L9.681,17 L10.611,17 L11.531,13 L14.431,13 L14.661,12 L11.76,12 L12.681,8 L15.431,8 Z M10.831,12 L8.141,12 L9.061,8 L11.75,8 L10.831,12 Z\\\"/></svg>\",\n        \"heart\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.03\\\" d=\\\"M10,4 C10,4 8.1,2 5.74,2 C3.38,2 1,3.55 1,6.73 C1,8.84 2.67,10.44 2.67,10.44 L10,18 L17.33,10.44 C17.33,10.44 19,8.84 19,6.73 C19,3.55 16.62,2 14.26,2 C11.9,2 10,4 10,4 L10,4 Z\\\"/></svg>\",\n        \"history\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"#000\\\" points=\\\"1 2 2 2 2 6 6 6 6 7 1 7 1 2\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M2.1,6.548 C3.391,3.29 6.746,1 10.5,1 C15.5,1 19.5,5 19.5,10 C19.5,15 15.5,19 10.5,19 C5.5,19 1.5,15 1.5,10\\\"/><rect x=\\\"9\\\" y=\\\"4\\\" width=\\\"1\\\" height=\\\"7\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M13.018,14.197 L9.445,10.625\\\"/></svg>\",\n        \"home\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"18.65 11.35 10 2.71 1.35 11.35 0.65 10.65 10 1.29 19.35 10.65\\\"/><polygon points=\\\"15 4 18 4 18 7 17 7 17 5 15 5\\\"/><polygon points=\\\"3 11 4 11 4 18 7 18 7 12 12 12 12 18 16 18 16 11 17 11 17 19 11 19 11 13 8 13 8 19 3 19\\\"/></svg>\",\n        \"image\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"16.1\\\" cy=\\\"6.1\\\" r=\\\"1.1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\".5\\\" y=\\\"2.5\\\" width=\\\"19\\\" height=\\\"15\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" points=\\\"4,13 8,9 13,14\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" points=\\\"11,12 12.5,10.5 16,14\\\"/></svg>\",\n        \"info\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M12.13,11.59 C11.97,12.84 10.35,14.12 9.1,14.16 C6.17,14.2 9.89,9.46 8.74,8.37 C9.3,8.16 10.62,7.83 10.62,8.81 C10.62,9.63 10.12,10.55 9.88,11.32 C8.66,15.16 12.13,11.15 12.14,11.18 C12.16,11.21 12.16,11.35 12.13,11.59 C12.08,11.95 12.16,11.35 12.13,11.59 L12.13,11.59 Z M11.56,5.67 C11.56,6.67 9.36,7.15 9.36,6.03 C9.36,5 11.56,4.54 11.56,5.67 L11.56,5.67 Z\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/></svg>\",\n        \"instagram\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M13.55,1H6.46C3.45,1,1,3.44,1,6.44v7.12c0,3,2.45,5.44,5.46,5.44h7.08c3.02,0,5.46-2.44,5.46-5.44V6.44 C19.01,3.44,16.56,1,13.55,1z M17.5,14c0,1.93-1.57,3.5-3.5,3.5H6c-1.93,0-3.5-1.57-3.5-3.5V6c0-1.93,1.57-3.5,3.5-3.5h8 c1.93,0,3.5,1.57,3.5,3.5V14z\\\"/><circle cx=\\\"14.87\\\" cy=\\\"5.26\\\" r=\\\"1.09\\\"/><path d=\\\"M10.03,5.45c-2.55,0-4.63,2.06-4.63,4.6c0,2.55,2.07,4.61,4.63,4.61c2.56,0,4.63-2.061,4.63-4.61 C14.65,7.51,12.58,5.45,10.03,5.45L10.03,5.45L10.03,5.45z M10.08,13c-1.66,0-3-1.34-3-2.99c0-1.65,1.34-2.99,3-2.99s3,1.34,3,2.99 C13.08,11.66,11.74,13,10.08,13L10.08,13L10.08,13z\\\"/></svg>\",\n        \"italic\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M12.63,5.48 L10.15,14.52 C10,15.08 10.37,15.25 11.92,15.3 L11.72,16 L6,16 L6.2,15.31 C7.78,15.26 8.19,15.09 8.34,14.53 L10.82,5.49 C10.97,4.92 10.63,4.76 9.09,4.71 L9.28,4 L15,4 L14.81,4.69 C13.23,4.75 12.78,4.91 12.63,5.48 L12.63,5.48 Z\\\"/></svg>\",\n        \"joomla\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M7.8,13.4l1.7-1.7L5.9,8c-0.6-0.5-0.6-1.5,0-2c0.6-0.6,1.4-0.6,2,0l1.7-1.7c-1-1-2.3-1.3-3.6-1C5.8,2.2,4.8,1.4,3.7,1.4 c-1.3,0-2.3,1-2.3,2.3c0,1.1,0.8,2,1.8,2.3c-0.4,1.3-0.1,2.8,1,3.8L7.8,13.4L7.8,13.4z\\\"/><path d=\\\"M10.2,4.3c1-1,2.5-1.4,3.8-1c0.2-1.1,1.1-2,2.3-2c1.3,0,2.3,1,2.3,2.3c0,1.2-0.9,2.2-2,2.3c0.4,1.3,0,2.8-1,3.8L13.9,8 c0.6-0.5,0.6-1.5,0-2c-0.5-0.6-1.5-0.6-2,0L8.2,9.7L6.5,8\\\"/><path d=\\\"M14.1,16.8c-1.3,0.4-2.8,0.1-3.8-1l1.7-1.7c0.6,0.6,1.5,0.6,2,0c0.5-0.6,0.6-1.5,0-2l-3.7-3.7L12,6.7l3.7,3.7 c1,1,1.3,2.4,1,3.6c1.1,0.2,2,1.1,2,2.3c0,1.3-1,2.3-2.3,2.3C15.2,18.6,14.3,17.8,14.1,16.8\\\"/><path d=\\\"M13.2,12.2l-3.7,3.7c-1,1-2.4,1.3-3.6,1c-0.2,1-1.2,1.8-2.2,1.8c-1.3,0-2.3-1-2.3-2.3c0-1.1,0.8-2,1.8-2.3 c-0.3-1.3,0-2.7,1-3.7l1.7,1.7c-0.6,0.6-0.6,1.5,0,2c0.6,0.6,1.4,0.6,2,0l3.7-3.7\\\"/></svg>\",\n        \"laptop\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect y=\\\"16\\\" width=\\\"20\\\" height=\\\"1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"2.5\\\" y=\\\"4.5\\\" width=\\\"15\\\" height=\\\"10\\\"/></svg>\",\n        \"lifesaver\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10,0.5 C4.76,0.5 0.5,4.76 0.5,10 C0.5,15.24 4.76,19.5 10,19.5 C15.24,19.5 19.5,15.24 19.5,10 C19.5,4.76 15.24,0.5 10,0.5 L10,0.5 Z M10,1.5 C11.49,1.5 12.89,1.88 14.11,2.56 L11.85,4.82 C11.27,4.61 10.65,4.5 10,4.5 C9.21,4.5 8.47,4.67 7.79,4.96 L5.58,2.75 C6.87,1.95 8.38,1.5 10,1.5 L10,1.5 Z M4.96,7.8 C4.67,8.48 4.5,9.21 4.5,10 C4.5,10.65 4.61,11.27 4.83,11.85 L2.56,14.11 C1.88,12.89 1.5,11.49 1.5,10 C1.5,8.38 1.95,6.87 2.75,5.58 L4.96,7.79 L4.96,7.8 L4.96,7.8 Z M10,18.5 C8.25,18.5 6.62,17.97 5.27,17.06 L7.46,14.87 C8.22,15.27 9.08,15.5 10,15.5 C10.79,15.5 11.53,15.33 12.21,15.04 L14.42,17.25 C13.13,18.05 11.62,18.5 10,18.5 L10,18.5 Z M10,14.5 C7.52,14.5 5.5,12.48 5.5,10 C5.5,7.52 7.52,5.5 10,5.5 C12.48,5.5 14.5,7.52 14.5,10 C14.5,12.48 12.48,14.5 10,14.5 L10,14.5 Z M15.04,12.21 C15.33,11.53 15.5,10.79 15.5,10 C15.5,9.08 15.27,8.22 14.87,7.46 L17.06,5.27 C17.97,6.62 18.5,8.25 18.5,10 C18.5,11.62 18.05,13.13 17.25,14.42 L15.04,12.21 L15.04,12.21 Z\\\"/></svg>\",\n        \"link\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M10.625,12.375 L7.525,15.475 C6.825,16.175 5.925,16.175 5.225,15.475 L4.525,14.775 C3.825,14.074 3.825,13.175 4.525,12.475 L7.625,9.375\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M9.325,7.375 L12.425,4.275 C13.125,3.575 14.025,3.575 14.724,4.275 L15.425,4.975 C16.125,5.675 16.125,6.575 15.425,7.275 L12.325,10.375\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M7.925,11.875 L11.925,7.975\\\"/></svg>\",\n        \"linkedin\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M5.77,17.89 L5.77,7.17 L2.21,7.17 L2.21,17.89 L5.77,17.89 L5.77,17.89 Z M3.99,5.71 C5.23,5.71 6.01,4.89 6.01,3.86 C5.99,2.8 5.24,2 4.02,2 C2.8,2 2,2.8 2,3.85 C2,4.88 2.77,5.7 3.97,5.7 L3.99,5.7 L3.99,5.71 L3.99,5.71 Z\\\"/><path d=\\\"M7.75,17.89 L11.31,17.89 L11.31,11.9 C11.31,11.58 11.33,11.26 11.43,11.03 C11.69,10.39 12.27,9.73 13.26,9.73 C14.55,9.73 15.06,10.71 15.06,12.15 L15.06,17.89 L18.62,17.89 L18.62,11.74 C18.62,8.45 16.86,6.92 14.52,6.92 C12.6,6.92 11.75,7.99 11.28,8.73 L11.3,8.73 L11.3,7.17 L7.75,7.17 C7.79,8.17 7.75,17.89 7.75,17.89 L7.75,17.89 L7.75,17.89 Z\\\"/></svg>\",\n        \"list\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"6\\\" y=\\\"4\\\" width=\\\"12\\\" height=\\\"1\\\"/><rect x=\\\"6\\\" y=\\\"9\\\" width=\\\"12\\\" height=\\\"1\\\"/><rect x=\\\"6\\\" y=\\\"14\\\" width=\\\"12\\\" height=\\\"1\\\"/><rect x=\\\"2\\\" y=\\\"4\\\" width=\\\"2\\\" height=\\\"1\\\"/><rect x=\\\"2\\\" y=\\\"9\\\" width=\\\"2\\\" height=\\\"1\\\"/><rect x=\\\"2\\\" y=\\\"14\\\" width=\\\"2\\\" height=\\\"1\\\"/></svg>\",\n        \"location\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" d=\\\"M10,0.5 C6.41,0.5 3.5,3.39 3.5,6.98 C3.5,11.83 10,19 10,19 C10,19 16.5,11.83 16.5,6.98 C16.5,3.39 13.59,0.5 10,0.5 L10,0.5 Z\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"6.8\\\" r=\\\"2.3\\\"/></svg>\",\n        \"lock\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" height=\\\"10\\\" width=\\\"13\\\" y=\\\"8.5\\\" x=\\\"3.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M6.5,8 L6.5,4.88 C6.5,3.01 8.07,1.5 10,1.5 C11.93,1.5 13.5,3.01 13.5,4.88 L13.5,8\\\"/></svg>\",\n        \"mail\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"1.4,6.5 10,11 18.6,6.5\\\"/><path d=\\\"M 1,4 1,16 19,16 19,4 1,4 Z M 18,15 2,15 2,5 18,5 18,15 Z\\\"/></svg>\",\n        \"menu\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"2\\\" y=\\\"4\\\" width=\\\"16\\\" height=\\\"1\\\"/><rect x=\\\"2\\\" y=\\\"9\\\" width=\\\"16\\\" height=\\\"1\\\"/><rect x=\\\"2\\\" y=\\\"14\\\" width=\\\"16\\\" height=\\\"1\\\"/></svg>\",\n        \"microphone\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"10\\\" x2=\\\"10\\\" y1=\\\"16.44\\\" y2=\\\"18.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"7\\\" x2=\\\"13\\\" y1=\\\"18.5\\\" y2=\\\"18.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M13.5 4.89v5.87a3.5 3.5 0 0 1-7 0V4.89a3.5 3.5 0 0 1 7 0z\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M15.5 10.36V11a5.5 5.5 0 0 1-11 0v-.6\\\"/></svg>\",\n        \"minus-circle\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9.5\\\" cy=\\\"9.5\\\" r=\\\"9\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"5\\\" y1=\\\"9.5\\\" x2=\\\"14\\\" y2=\\\"9.5\\\"/></svg>\",\n        \"minus\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect height=\\\"1\\\" width=\\\"18\\\" y=\\\"9\\\" x=\\\"1\\\"/></svg>\",\n        \"more-vertical\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"10\\\" cy=\\\"3\\\" r=\\\"2\\\"/><circle cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"2\\\"/><circle cx=\\\"10\\\" cy=\\\"17\\\" r=\\\"2\\\"/></svg>\",\n        \"more\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"3\\\" cy=\\\"10\\\" r=\\\"2\\\"/><circle cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"2\\\"/><circle cx=\\\"17\\\" cy=\\\"10\\\" r=\\\"2\\\"/></svg>\",\n        \"move\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"4,5 1,5 1,9 2,9 2,6 4,6\\\"/><polygon points=\\\"1,16 2,16 2,18 4,18 4,19 1,19\\\"/><polygon points=\\\"14,16 14,19 11,19 11,18 13,18 13,16\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"5.5\\\" y=\\\"1.5\\\" width=\\\"13\\\" height=\\\"13\\\"/><rect x=\\\"1\\\" y=\\\"11\\\" width=\\\"1\\\" height=\\\"3\\\"/><rect x=\\\"6\\\" y=\\\"18\\\" width=\\\"3\\\" height=\\\"1\\\"/></svg>\",\n        \"nut\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"2.5,5.7 10,1.3 17.5,5.7 17.5,14.3 10,18.7 2.5,14.3\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"3.5\\\"/></svg>\",\n        \"pagekit\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"3,1 17,1 17,16 10,16 10,13 14,13 14,4 6,4 6,16 10,16 10,19 3,19\\\"/></svg>\",\n        \"paint-bucket\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10.21,1 L0,11.21 L8.1,19.31 L18.31,9.1 L10.21,1 L10.21,1 Z M16.89,9.1 L15,11 L1.7,11 L10.21,2.42 L16.89,9.1 Z\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M6.42,2.33 L11.7,7.61\\\"/><path d=\\\"M18.49,12 C18.49,12 20,14.06 20,15.36 C20,16.28 19.24,17 18.49,17 L18.49,17 C17.74,17 17,16.28 17,15.36 C17,14.06 18.49,12 18.49,12 L18.49,12 Z\\\"/></svg>\",\n        \"pencil\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M17.25,6.01 L7.12,16.1 L3.82,17.2 L5.02,13.9 L15.12,3.88 C15.71,3.29 16.66,3.29 17.25,3.88 C17.83,4.47 17.83,5.42 17.25,6.01 L17.25,6.01 Z\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M15.98,7.268 L13.851,5.148\\\"/></svg>\",\n        \"phone-landscape\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M17,5.5 C17.8,5.5 18.5,6.2 18.5,7 L18.5,14 C18.5,14.8 17.8,15.5 17,15.5 L3,15.5 C2.2,15.5 1.5,14.8 1.5,14 L1.5,7 C1.5,6.2 2.2,5.5 3,5.5 L17,5.5 L17,5.5 L17,5.5 Z\\\"/><circle cx=\\\"3.8\\\" cy=\\\"10.5\\\" r=\\\".8\\\"/></svg>\",\n        \"phone\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M15.5,17 C15.5,17.8 14.8,18.5 14,18.5 L7,18.5 C6.2,18.5 5.5,17.8 5.5,17 L5.5,3 C5.5,2.2 6.2,1.5 7,1.5 L14,1.5 C14.8,1.5 15.5,2.2 15.5,3 L15.5,17 L15.5,17 L15.5,17 Z\\\"/><circle cx=\\\"10.5\\\" cy=\\\"16.5\\\" r=\\\".8\\\"/></svg>\",\n        \"pinterest\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10.21,1 C5.5,1 3,4.16 3,7.61 C3,9.21 3.85,11.2 5.22,11.84 C5.43,11.94 5.54,11.89 5.58,11.69 C5.62,11.54 5.8,10.8 5.88,10.45 C5.91,10.34 5.89,10.24 5.8,10.14 C5.36,9.59 5,8.58 5,7.65 C5,5.24 6.82,2.91 9.93,2.91 C12.61,2.91 14.49,4.74 14.49,7.35 C14.49,10.3 13,12.35 11.06,12.35 C9.99,12.35 9.19,11.47 9.44,10.38 C9.75,9.08 10.35,7.68 10.35,6.75 C10.35,5.91 9.9,5.21 8.97,5.21 C7.87,5.21 6.99,6.34 6.99,7.86 C6.99,8.83 7.32,9.48 7.32,9.48 C7.32,9.48 6.24,14.06 6.04,14.91 C5.7,16.35 6.08,18.7 6.12,18.9 C6.14,19.01 6.26,19.05 6.33,18.95 C6.44,18.81 7.74,16.85 8.11,15.44 C8.24,14.93 8.79,12.84 8.79,12.84 C9.15,13.52 10.19,14.09 11.29,14.09 C14.58,14.09 16.96,11.06 16.96,7.3 C16.94,3.7 14,1 10.21,1\\\"/></svg>\",\n        \"play-circle\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" points=\\\"8.5 7 13.5 10 8.5 13\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/></svg>\",\n        \"play\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"6.5,5 14.5,10 6.5,15\\\"/></svg>\",\n        \"plus-circle\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9.5\\\" cy=\\\"9.5\\\" r=\\\"9\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"9.5\\\" y1=\\\"5\\\" x2=\\\"9.5\\\" y2=\\\"14\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"5\\\" y1=\\\"9.5\\\" x2=\\\"14\\\" y2=\\\"9.5\\\"/></svg>\",\n        \"plus\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"9\\\" y=\\\"1\\\" width=\\\"1\\\" height=\\\"17\\\"/><rect x=\\\"1\\\" y=\\\"9\\\" width=\\\"17\\\" height=\\\"1\\\"/></svg>\",\n        \"print\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"4.5 13.5 1.5 13.5 1.5 6.5 18.5 6.5 18.5 13.5 15.5 13.5\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"15.5 6.5 15.5 2.5 4.5 2.5 4.5 6.5\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" width=\\\"11\\\" height=\\\"6\\\" x=\\\"4.5\\\" y=\\\"11.5\\\"/><rect width=\\\"8\\\" height=\\\"1\\\" x=\\\"6\\\" y=\\\"13\\\"/><rect width=\\\"8\\\" height=\\\"1\\\" x=\\\"6\\\" y=\\\"15\\\"/></svg>\",\n        \"pull\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"6.85,8 9.5,10.6 12.15,8 12.85,8.7 9.5,12 6.15,8.7\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"9.5\\\" y1=\\\"11\\\" x2=\\\"9.5\\\" y2=\\\"2\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"6,5.5 3.5,5.5 3.5,18.5 15.5,18.5 15.5,5.5 13,5.5\\\"/></svg>\",\n        \"push\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"12.15,4 9.5,1.4 6.85,4 6.15,3.3 9.5,0 12.85,3.3\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"9.5\\\" y1=\\\"10\\\" x2=\\\"9.5\\\" y2=\\\"1\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"6 5.5 3.5 5.5 3.5 18.5 15.5 18.5 15.5 5.5 13 5.5\\\"/></svg>\",\n        \"question\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/><circle cx=\\\"10.44\\\" cy=\\\"14.42\\\" r=\\\"1.05\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" d=\\\"M8.17,7.79 C8.17,4.75 12.72,4.73 12.72,7.72 C12.72,8.67 11.81,9.15 11.23,9.75 C10.75,10.24 10.51,10.73 10.45,11.4 C10.44,11.53 10.43,11.64 10.43,11.75\\\"/></svg>\",\n        \"quote-right\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.27,7.79 C17.27,9.45 16.97,10.43 15.99,12.02 C14.98,13.64 13,15.23 11.56,15.97 L11.1,15.08 C12.34,14.2 13.14,13.51 14.02,11.82 C14.27,11.34 14.41,10.92 14.49,10.54 C14.3,10.58 14.09,10.6 13.88,10.6 C12.06,10.6 10.59,9.12 10.59,7.3 C10.59,5.48 12.06,4 13.88,4 C15.39,4 16.67,5.02 17.05,6.42 C17.19,6.82 17.27,7.27 17.27,7.79 L17.27,7.79 Z\\\"/><path d=\\\"M8.68,7.79 C8.68,9.45 8.38,10.43 7.4,12.02 C6.39,13.64 4.41,15.23 2.97,15.97 L2.51,15.08 C3.75,14.2 4.55,13.51 5.43,11.82 C5.68,11.34 5.82,10.92 5.9,10.54 C5.71,10.58 5.5,10.6 5.29,10.6 C3.47,10.6 2,9.12 2,7.3 C2,5.48 3.47,4 5.29,4 C6.8,4 8.08,5.02 8.46,6.42 C8.6,6.82 8.68,7.27 8.68,7.79 L8.68,7.79 Z\\\"/></svg>\",\n        \"receiver\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" d=\\\"M6.189,13.611C8.134,15.525 11.097,18.239 13.867,18.257C16.47,18.275 18.2,16.241 18.2,16.241L14.509,12.551L11.539,13.639L6.189,8.29L7.313,5.355L3.76,1.8C3.76,1.8 1.732,3.537 1.7,6.092C1.667,8.809 4.347,11.738 6.189,13.611\\\"/></svg>\",\n        \"reddit\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M19 9.05a2.56 2.56 0 0 0-2.56-2.56 2.59 2.59 0 0 0-1.88.82 10.63 10.63 0 0 0-4.14-1v-.08c.58-1.62 1.58-3.89 2.7-4.1.38-.08.77.12 1.19.57a1.15 1.15 0 0 0-.06.37 1.48 1.48 0 1 0 1.51-1.45 1.43 1.43 0 0 0-.76.19A2.29 2.29 0 0 0 12.91 1c-2.11.43-3.39 4.38-3.63 5.19 0 0 0 .11-.06.11a10.65 10.65 0 0 0-3.75 1A2.56 2.56 0 0 0 1 9.05a2.42 2.42 0 0 0 .72 1.76A5.18 5.18 0 0 0 1.24 13c0 3.66 3.92 6.64 8.73 6.64s8.74-3 8.74-6.64a5.23 5.23 0 0 0-.46-2.13A2.58 2.58 0 0 0 19 9.05zm-16.88 0a1.44 1.44 0 0 1 2.27-1.19 7.68 7.68 0 0 0-2.07 1.91 1.33 1.33 0 0 1-.2-.72zM10 18.4c-4.17 0-7.55-2.4-7.55-5.4S5.83 7.53 10 7.53 17.5 10 17.5 13s-3.38 5.4-7.5 5.4zm7.69-8.61a7.62 7.62 0 0 0-2.09-1.91 1.41 1.41 0 0 1 .84-.28 1.47 1.47 0 0 1 1.44 1.45 1.34 1.34 0 0 1-.21.72z\\\"/><path d=\\\"M6.69 12.58a1.39 1.39 0 1 1 1.39-1.39 1.38 1.38 0 0 1-1.38 1.39z\\\"/><path d=\\\"M14.26 11.2a1.39 1.39 0 1 1-1.39-1.39 1.39 1.39 0 0 1 1.39 1.39z\\\"/><path d=\\\"M13.09 14.88a.54.54 0 0 1-.09.77 5.3 5.3 0 0 1-3.26 1.19 5.61 5.61 0 0 1-3.4-1.22.55.55 0 1 1 .73-.83 4.09 4.09 0 0 0 5.25 0 .56.56 0 0 1 .77.09z\\\"/></svg>\",\n        \"refresh\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M17.08,11.15 C17.09,11.31 17.1,11.47 17.1,11.64 C17.1,15.53 13.94,18.69 10.05,18.69 C6.16,18.68 3,15.53 3,11.63 C3,7.74 6.16,4.58 10.05,4.58 C10.9,4.58 11.71,4.73 12.46,5\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"9.9 2 12.79 4.89 9.79 7.9\\\"/></svg>\",\n        \"reply\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.7,13.11 C16.12,10.02 13.84,7.85 11.02,6.61 C10.57,6.41 9.75,6.13 9,5.91 L9,2 L1,9 L9,16 L9,12.13 C10.78,12.47 12.5,13.19 14.09,14.25 C17.13,16.28 18.56,18.54 18.56,18.54 C18.56,18.54 18.81,15.28 17.7,13.11 L17.7,13.11 Z M14.82,13.53 C13.17,12.4 11.01,11.4 8,10.92 L8,13.63 L2.55,9 L8,4.25 L8,6.8 C8.3,6.86 9.16,7.02 10.37,7.49 C13.3,8.65 15.54,10.96 16.65,13.08 C16.97,13.7 17.48,14.86 17.68,16 C16.87,15.05 15.73,14.15 14.82,13.53 L14.82,13.53 Z\\\"/></svg>\",\n        \"rss\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"3.12\\\" cy=\\\"16.8\\\" r=\\\"1.85\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M1.5,8.2 C1.78,8.18 2.06,8.16 2.35,8.16 C7.57,8.16 11.81,12.37 11.81,17.57 C11.81,17.89 11.79,18.19 11.76,18.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M1.5,2.52 C1.78,2.51 2.06,2.5 2.35,2.5 C10.72,2.5 17.5,9.24 17.5,17.57 C17.5,17.89 17.49,18.19 17.47,18.5\\\"/></svg>\",\n        \"search\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9\\\" cy=\\\"9\\\" r=\\\"7\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M14,14 L18,18 L14,14 Z\\\"/></svg>\",\n        \"server\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"3\\\" y=\\\"3\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"5\\\" y=\\\"3\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"7\\\" y=\\\"3\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"16\\\" y=\\\"3\\\" width=\\\"1\\\" height=\\\"1\\\"/><rect x=\\\"16\\\" y=\\\"10\\\" width=\\\"1\\\" height=\\\"1\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"9.9\\\" cy=\\\"17.4\\\" r=\\\"1.4\\\"/><rect x=\\\"3\\\" y=\\\"10\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"5\\\" y=\\\"10\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"9.5\\\" y=\\\"14\\\" width=\\\"1\\\" height=\\\"2\\\"/><rect x=\\\"3\\\" y=\\\"17\\\" width=\\\"6\\\" height=\\\"1\\\"/><rect x=\\\"11\\\" y=\\\"17\\\" width=\\\"6\\\" height=\\\"1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"1.5\\\" y=\\\"1.5\\\" width=\\\"17\\\" height=\\\"5\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"1.5\\\" y=\\\"8.5\\\" width=\\\"17\\\" height=\\\"5\\\"/></svg>\",\n        \"settings\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><ellipse fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"6.11\\\" cy=\\\"3.55\\\" rx=\\\"2.11\\\" ry=\\\"2.15\\\"/><ellipse fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"6.11\\\" cy=\\\"15.55\\\" rx=\\\"2.11\\\" ry=\\\"2.15\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"13.15\\\" cy=\\\"9.55\\\" r=\\\"2.15\\\"/><rect x=\\\"1\\\" y=\\\"3\\\" width=\\\"3\\\" height=\\\"1\\\"/><rect x=\\\"10\\\" y=\\\"3\\\" width=\\\"8\\\" height=\\\"1\\\"/><rect x=\\\"1\\\" y=\\\"9\\\" width=\\\"8\\\" height=\\\"1\\\"/><rect x=\\\"15\\\" y=\\\"9\\\" width=\\\"3\\\" height=\\\"1\\\"/><rect x=\\\"1\\\" y=\\\"15\\\" width=\\\"3\\\" height=\\\"1\\\"/><rect x=\\\"10\\\" y=\\\"15\\\" width=\\\"8\\\" height=\\\"1\\\"/></svg>\",\n        \"shrink\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"11 4 12 4 12 8 16 8 16 9 11 9\\\"/><polygon points=\\\"4 11 9 11 9 16 8 16 8 12 4 12\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M12,8 L18,2\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M2,18 L8,12\\\"/></svg>\",\n        \"sign-in\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"7 2 17 2 17 17 7 17 7 16 16 16 16 3 7 3\\\"/><polygon points=\\\"9.1 13.4 8.5 12.8 11.28 10 4 10 4 9 11.28 9 8.5 6.2 9.1 5.62 13 9.5\\\"/></svg>\",\n        \"sign-out\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"13.1 13.4 12.5 12.8 15.28 10 8 10 8 9 15.28 9 12.5 6.2 13.1 5.62 17 9.5\\\"/><polygon points=\\\"13 2 3 2 3 17 13 17 13 16 4 16 4 3 13 3\\\"/></svg>\",\n        \"social\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"13.4\\\" y1=\\\"14\\\" x2=\\\"6.3\\\" y2=\\\"10.7\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"13.5\\\" y1=\\\"5.5\\\" x2=\\\"6.5\\\" y2=\\\"8.8\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"15.5\\\" cy=\\\"4.6\\\" r=\\\"2.3\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"15.5\\\" cy=\\\"14.8\\\" r=\\\"2.3\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"4.5\\\" cy=\\\"9.8\\\" r=\\\"2.3\\\"/></svg>\",\n        \"soundcloud\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.2,9.4c-0.4,0-0.8,0.1-1.101,0.2c-0.199-2.5-2.399-4.5-5-4.5c-0.6,0-1.2,0.1-1.7,0.3C9.2,5.5,9.1,5.6,9.1,5.6V15h8 c1.601,0,2.801-1.2,2.801-2.8C20,10.7,18.7,9.4,17.2,9.4L17.2,9.4z\\\"/><rect x=\\\"6\\\" y=\\\"6.5\\\" width=\\\"1.5\\\" height=\\\"8.5\\\"/><rect x=\\\"3\\\" y=\\\"8\\\" width=\\\"1.5\\\" height=\\\"7\\\"/><rect y=\\\"10\\\" width=\\\"1.5\\\" height=\\\"5\\\"/></svg>\",\n        \"star\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.01\\\" points=\\\"10 2 12.63 7.27 18.5 8.12 14.25 12.22 15.25 18 10 15.27 4.75 18 5.75 12.22 1.5 8.12 7.37 7.27\\\"/></svg>\",\n        \"strikethrough\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M6,13.02 L6.65,13.02 C7.64,15.16 8.86,16.12 10.41,16.12 C12.22,16.12 12.92,14.93 12.92,13.89 C12.92,12.55 11.99,12.03 9.74,11.23 C8.05,10.64 6.23,10.11 6.23,7.83 C6.23,5.5 8.09,4.09 10.4,4.09 C11.44,4.09 12.13,4.31 12.72,4.54 L13.33,4 L13.81,4 L13.81,7.59 L13.16,7.59 C12.55,5.88 11.52,4.89 10.07,4.89 C8.84,4.89 7.89,5.69 7.89,7.03 C7.89,8.29 8.89,8.78 10.88,9.45 C12.57,10.03 14.38,10.6 14.38,12.91 C14.38,14.75 13.27,16.93 10.18,16.93 C9.18,16.93 8.17,16.69 7.46,16.39 L6.52,17 L6,17 L6,13.02 L6,13.02 Z\\\"/><rect x=\\\"3\\\" y=\\\"10\\\" width=\\\"15\\\" height=\\\"1\\\"/></svg>\",\n        \"table\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"1\\\" y=\\\"3\\\" width=\\\"18\\\" height=\\\"1\\\"/><rect x=\\\"1\\\" y=\\\"7\\\" width=\\\"18\\\" height=\\\"1\\\"/><rect x=\\\"1\\\" y=\\\"11\\\" width=\\\"18\\\" height=\\\"1\\\"/><rect x=\\\"1\\\" y=\\\"15\\\" width=\\\"18\\\" height=\\\"1\\\"/></svg>\",\n        \"tablet-landscape\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M1.5,5 C1.5,4.2 2.2,3.5 3,3.5 L17,3.5 C17.8,3.5 18.5,4.2 18.5,5 L18.5,16 C18.5,16.8 17.8,17.5 17,17.5 L3,17.5 C2.2,17.5 1.5,16.8 1.5,16 L1.5,5 L1.5,5 L1.5,5 Z\\\"/><circle cx=\\\"3.7\\\" cy=\\\"10.5\\\" r=\\\".8\\\"/></svg>\",\n        \"tablet\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M5,18.5 C4.2,18.5 3.5,17.8 3.5,17 L3.5,3 C3.5,2.2 4.2,1.5 5,1.5 L16,1.5 C16.8,1.5 17.5,2.2 17.5,3 L17.5,17 C17.5,17.8 16.8,18.5 16,18.5 L5,18.5 L5,18.5 L5,18.5 Z\\\"/><circle cx=\\\"10.5\\\" cy=\\\"16.3\\\" r=\\\".8\\\"/></svg>\",\n        \"tag\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M17.5,3.71 L17.5,7.72 C17.5,7.96 17.4,8.2 17.21,8.39 L8.39,17.2 C7.99,17.6 7.33,17.6 6.93,17.2 L2.8,13.07 C2.4,12.67 2.4,12.01 2.8,11.61 L11.61,2.8 C11.81,2.6 12.08,2.5 12.34,2.5 L16.19,2.5 C16.52,2.5 16.86,2.63 17.11,2.88 C17.35,3.11 17.48,3.4 17.5,3.71 L17.5,3.71 Z\\\"/><circle cx=\\\"14\\\" cy=\\\"6\\\" r=\\\"1\\\"/></svg>\",\n        \"thumbnails\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"3.5\\\" y=\\\"3.5\\\" width=\\\"5\\\" height=\\\"5\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"11.5\\\" y=\\\"3.5\\\" width=\\\"5\\\" height=\\\"5\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"11.5\\\" y=\\\"11.5\\\" width=\\\"5\\\" height=\\\"5\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"3.5\\\" y=\\\"11.5\\\" width=\\\"5\\\" height=\\\"5\\\"/></svg>\",\n        \"tiktok\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.24,6V8.82a6.79,6.79,0,0,1-4-1.28v5.81A5.26,5.26,0,1,1,8,8.1a4.36,4.36,0,0,1,.72.05v2.9A2.57,2.57,0,0,0,7.64,11a2.4,2.4,0,1,0,2.77,2.38V2h2.86a4,4,0,0,0,1.84,3.38A4,4,0,0,0,17.24,6Z\\\"/></svg>\",\n        \"trash\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"6.5 3 6.5 1.5 13.5 1.5 13.5 3\\\"/><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"4.5 4 4.5 18.5 15.5 18.5 15.5 4\\\"/><rect x=\\\"8\\\" y=\\\"7\\\" width=\\\"1\\\" height=\\\"9\\\"/><rect x=\\\"11\\\" y=\\\"7\\\" width=\\\"1\\\" height=\\\"9\\\"/><rect x=\\\"2\\\" y=\\\"3\\\" width=\\\"16\\\" height=\\\"1\\\"/></svg>\",\n        \"triangle-down\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"5 7 15 7 10 12\\\"/></svg>\",\n        \"triangle-left\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"12 5 7 10 12 15\\\"/></svg>\",\n        \"triangle-right\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"8 5 13 10 8 15\\\"/></svg>\",\n        \"triangle-up\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"5 13 10 8 15 13\\\"/></svg>\",\n        \"tripadvisor\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M19.021,7.866C19.256,6.862,20,5.854,20,5.854h-3.346C14.781,4.641,12.504,4,9.98,4C7.363,4,4.999,4.651,3.135,5.876H0\\tc0,0,0.738,0.987,0.976,1.988c-0.611,0.837-0.973,1.852-0.973,2.964c0,2.763,2.249,5.009,5.011,5.009\\tc1.576,0,2.976-0.737,3.901-1.879l1.063,1.599l1.075-1.615c0.475,0.611,1.1,1.111,1.838,1.451c1.213,0.547,2.574,0.612,3.825,0.15\\tc2.589-0.963,3.913-3.852,2.964-6.439c-0.175-0.463-0.4-0.876-0.675-1.238H19.021z M16.38,14.594\\tc-1.002,0.371-2.088,0.328-3.06-0.119c-0.688-0.317-1.252-0.817-1.657-1.438c-0.164-0.25-0.313-0.52-0.417-0.811\\tc-0.124-0.328-0.186-0.668-0.217-1.014c-0.063-0.689,0.037-1.396,0.339-2.043c0.448-0.971,1.251-1.71,2.25-2.079\\tc2.075-0.765,4.375,0.3,5.14,2.366c0.762,2.066-0.301,4.37-2.363,5.134L16.38,14.594L16.38,14.594z M8.322,13.066\\tc-0.72,1.059-1.935,1.76-3.309,1.76c-2.207,0-4.001-1.797-4.001-3.996c0-2.203,1.795-4.002,4.001-4.002\\tc2.204,0,3.999,1.8,3.999,4.002c0,0.137-0.024,0.261-0.04,0.396c-0.067,0.678-0.284,1.313-0.648,1.853v-0.013H8.322z M2.472,10.775\\tc0,1.367,1.112,2.479,2.476,2.479c1.363,0,2.472-1.11,2.472-2.479c0-1.359-1.11-2.468-2.472-2.468\\tC3.584,8.306,2.473,9.416,2.472,10.775L2.472,10.775z M12.514,10.775c0,1.367,1.104,2.479,2.471,2.479\\tc1.363,0,2.474-1.108,2.474-2.479c0-1.359-1.11-2.468-2.474-2.468c-1.364,0-2.477,1.109-2.477,2.468H12.514z M3.324,10.775\\tc0-0.893,0.726-1.618,1.614-1.618c0.889,0,1.625,0.727,1.625,1.618c0,0.898-0.725,1.627-1.625,1.627\\tc-0.901,0-1.625-0.729-1.625-1.627H3.324z M13.354,10.775c0-0.893,0.726-1.618,1.627-1.618c0.886,0,1.61,0.727,1.61,1.618\\tc0,0.898-0.726,1.627-1.626,1.627s-1.625-0.729-1.625-1.627H13.354z M9.977,4.875c1.798,0,3.425,0.324,4.849,0.968\\tc-0.535,0.015-1.061,0.108-1.586,0.3c-1.264,0.463-2.264,1.388-2.815,2.604c-0.262,0.551-0.398,1.133-0.448,1.72\\tC9.79,7.905,7.677,5.873,5.076,5.82C6.501,5.208,8.153,4.875,9.94,4.875H9.977z\\\"/></svg>\",\n        \"tumblr\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M6.885,8.598c0,0,0,3.393,0,4.996c0,0.282,0,0.66,0.094,0.942c0.377,1.509,1.131,2.545,2.545,3.11 c1.319,0.472,2.356,0.472,3.676,0c0.565-0.188,1.132-0.659,1.132-0.659l-0.849-2.263c0,0-1.036,0.378-1.603,0.283 c-0.565-0.094-1.226-0.66-1.226-1.508c0-1.603,0-4.902,0-4.902h2.828V5.771h-2.828V2H8.205c0,0-0.094,0.66-0.188,0.942 C7.828,3.791,7.262,4.733,6.603,5.394C5.848,6.147,5,6.43,5,6.43v2.168H6.885z\\\"/></svg>\",\n        \"tv\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"7\\\" y=\\\"16\\\" width=\\\"6\\\" height=\\\"1\\\"/><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\".5\\\" y=\\\"3.5\\\" width=\\\"19\\\" height=\\\"11\\\"/></svg>\",\n        \"twitch\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M5.23,1,2,4.23V15.85H5.88v3.23L9.1,15.85h2.59L17.5,10V1Zm11,8.4L13.62,12H11L8.78,14.24V12H5.88V2.29H16.21Z\\\"/><rect x=\\\"12.98\\\" y=\\\"4.55\\\" width=\\\"1.29\\\" height=\\\"3.88\\\"/><rect x=\\\"9.43\\\" y=\\\"4.55\\\" width=\\\"1.29\\\" height=\\\"3.88\\\"/></svg>\",\n        \"twitter\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M19,4.74 C18.339,5.029 17.626,5.229 16.881,5.32 C17.644,4.86 18.227,4.139 18.503,3.28 C17.79,3.7 17.001,4.009 16.159,4.17 C15.485,3.45 14.526,3 13.464,3 C11.423,3 9.771,4.66 9.771,6.7 C9.771,6.99 9.804,7.269 9.868,7.539 C6.795,7.38 4.076,5.919 2.254,3.679 C1.936,4.219 1.754,4.86 1.754,5.539 C1.754,6.82 2.405,7.95 3.397,8.61 C2.79,8.589 2.22,8.429 1.723,8.149 L1.723,8.189 C1.723,9.978 2.997,11.478 4.686,11.82 C4.376,11.899 4.049,11.939 3.713,11.939 C3.475,11.939 3.245,11.919 3.018,11.88 C3.49,13.349 4.852,14.419 6.469,14.449 C5.205,15.429 3.612,16.019 1.882,16.019 C1.583,16.019 1.29,16.009 1,15.969 C2.635,17.019 4.576,17.629 6.662,17.629 C13.454,17.629 17.17,12 17.17,7.129 C17.17,6.969 17.166,6.809 17.157,6.649 C17.879,6.129 18.504,5.478 19,4.74\\\"/></svg>\",\n        \"uikit\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon points=\\\"14.4,3.1 11.3,5.1 15,7.3 15,12.9 10,15.7 5,12.9 5,8.5 2,6.8 2,14.8 9.9,19.5 18,14.8 18,5.3\\\"/><polygon points=\\\"9.8,4.2 6.7,2.4 9.8,0.4 12.9,2.3\\\"/></svg>\",\n        \"unlock\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect fill=\\\"none\\\" stroke=\\\"#000\\\" x=\\\"3.5\\\" y=\\\"8.5\\\" width=\\\"13\\\" height=\\\"10\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M6.5,8.5 L6.5,4.9 C6.5,3 8.1,1.5 10,1.5 C11.9,1.5 13.5,3 13.5,4.9\\\"/></svg>\",\n        \"upload\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"5 8 9.5 3.5 14 8\\\"/><rect x=\\\"3\\\" y=\\\"17\\\" width=\\\"13\\\" height=\\\"1\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" x1=\\\"9.5\\\" y1=\\\"15\\\" x2=\\\"9.5\\\" y2=\\\"4\\\"/></svg>\",\n        \"user\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9.9\\\" cy=\\\"6.4\\\" r=\\\"4.4\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M1.5,19 C2.3,14.5 5.8,11.2 10,11.2 C14.2,11.2 17.7,14.6 18.5,19.2\\\"/></svg>\",\n        \"users\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"7.7\\\" cy=\\\"8.6\\\" r=\\\"3.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M1,18.1 C1.7,14.6 4.4,12.1 7.6,12.1 C10.9,12.1 13.7,14.8 14.3,18.3\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M11.4,4 C12.8,2.4 15.4,2.8 16.3,4.7 C17.2,6.6 15.7,8.9 13.6,8.9 C16.5,8.9 18.8,11.3 19.2,14.1\\\"/></svg>\",\n        \"video-camera\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polygon fill=\\\"none\\\" stroke=\\\"#000\\\" points=\\\"17.5 6.9 17.5 13.1 13.5 10.4 13.5 14.5 2.5 14.5 2.5 5.5 13.5 5.5 13.5 9.6 17.5 6.9\\\"/></svg>\",\n        \"vimeo\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M2.065,7.59C1.84,7.367,1.654,7.082,1.468,6.838c-0.332-0.42-0.137-0.411,0.274-0.772c1.026-0.91,2.004-1.896,3.127-2.688 c1.017-0.713,2.365-1.173,3.286-0.039c0.849,1.045,0.869,2.629,1.084,3.891c0.215,1.309,0.421,2.648,0.88,3.901 c0.127,0.352,0.37,1.018,0.81,1.074c0.567,0.078,1.145-0.917,1.408-1.289c0.684-0.987,1.611-2.317,1.494-3.587 c-0.115-1.349-1.572-1.095-2.482-0.773c0.146-1.514,1.555-3.216,2.912-3.792c1.439-0.597,3.579-0.587,4.302,1.036 c0.772,1.759,0.078,3.802-0.763,5.396c-0.918,1.731-2.1,3.333-3.363,4.829c-1.114,1.329-2.432,2.787-4.093,3.422 c-1.897,0.723-3.021-0.686-3.667-2.318c-0.705-1.777-1.056-3.771-1.565-5.621C4.898,8.726,4.644,7.836,4.136,7.191 C3.473,6.358,2.72,7.141,2.065,7.59C1.977,7.502,2.115,7.551,2.065,7.59L2.065,7.59z\\\"/></svg>\",\n        \"warning\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle cx=\\\"10\\\" cy=\\\"14\\\" r=\\\"1\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10\\\" cy=\\\"10\\\" r=\\\"9\\\"/><path d=\\\"M10.97,7.72 C10.85,9.54 10.56,11.29 10.56,11.29 C10.51,11.87 10.27,12 9.99,12 C9.69,12 9.49,11.87 9.43,11.29 C9.43,11.29 9.16,9.54 9.03,7.72 C8.96,6.54 9.03,6 9.03,6 C9.03,5.45 9.46,5.02 9.99,5 C10.53,5.01 10.97,5.44 10.97,6 C10.97,6 11.04,6.54 10.97,7.72 L10.97,7.72 Z\\\"/></svg>\",\n        \"whatsapp\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M16.7,3.3c-1.8-1.8-4.1-2.8-6.7-2.8c-5.2,0-9.4,4.2-9.4,9.4c0,1.7,0.4,3.3,1.3,4.7l-1.3,4.9l5-1.3c1.4,0.8,2.9,1.2,4.5,1.2 l0,0l0,0c5.2,0,9.4-4.2,9.4-9.4C19.5,7.4,18.5,5,16.7,3.3 M10.1,17.7L10.1,17.7c-1.4,0-2.8-0.4-4-1.1l-0.3-0.2l-3,0.8l0.8-2.9 l-0.2-0.3c-0.8-1.2-1.2-2.7-1.2-4.2c0-4.3,3.5-7.8,7.8-7.8c2.1,0,4.1,0.8,5.5,2.3c1.5,1.5,2.3,3.4,2.3,5.5 C17.9,14.2,14.4,17.7,10.1,17.7 M14.4,11.9c-0.2-0.1-1.4-0.7-1.6-0.8c-0.2-0.1-0.4-0.1-0.5,0.1c-0.2,0.2-0.6,0.8-0.8,0.9 c-0.1,0.2-0.3,0.2-0.5,0.1c-0.2-0.1-1-0.4-1.9-1.2c-0.7-0.6-1.2-1.4-1.3-1.6c-0.1-0.2,0-0.4,0.1-0.5C8,8.8,8.1,8.7,8.2,8.5 c0.1-0.1,0.2-0.2,0.2-0.4c0.1-0.2,0-0.3,0-0.4C8.4,7.6,7.9,6.5,7.7,6C7.5,5.5,7.3,5.6,7.2,5.6c-0.1,0-0.3,0-0.4,0 c-0.2,0-0.4,0.1-0.6,0.3c-0.2,0.2-0.8,0.8-0.8,2c0,1.2,0.8,2.3,1,2.4c0.1,0.2,1.7,2.5,4,3.5c0.6,0.2,1,0.4,1.3,0.5 c0.6,0.2,1.1,0.2,1.5,0.1c0.5-0.1,1.4-0.6,1.6-1.1c0.2-0.5,0.2-1,0.1-1.1C14.8,12.1,14.6,12,14.4,11.9\\\"/></svg>\",\n        \"wordpress\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M10,0.5c-5.2,0-9.5,4.3-9.5,9.5s4.3,9.5,9.5,9.5c5.2,0,9.5-4.3,9.5-9.5S15.2,0.5,10,0.5L10,0.5L10,0.5z M15.6,3.9h-0.1 c-0.8,0-1.4,0.7-1.4,1.5c0,0.7,0.4,1.3,0.8,1.9c0.3,0.6,0.7,1.3,0.7,2.3c0,0.7-0.3,1.5-0.6,2.7L14.1,15l-3-8.9 c0.5,0,0.9-0.1,0.9-0.1C12.5,6,12.5,5.3,12,5.4c0,0-1.3,0.1-2.2,0.1C9,5.5,7.7,5.4,7.7,5.4C7.2,5.3,7.2,6,7.6,6c0,0,0.4,0.1,0.9,0.1 l1.3,3.5L8,15L5,6.1C5.5,6.1,5.9,6,5.9,6C6.4,6,6.3,5.3,5.9,5.4c0,0-1.3,0.1-2.2,0.1c-0.2,0-0.3,0-0.5,0c1.5-2.2,4-3.7,6.9-3.7 C12.2,1.7,14.1,2.6,15.6,3.9L15.6,3.9L15.6,3.9z M2.5,6.6l3.9,10.8c-2.7-1.3-4.6-4.2-4.6-7.4C1.8,8.8,2,7.6,2.5,6.6L2.5,6.6L2.5,6.6 z M10.2,10.7l2.5,6.9c0,0,0,0.1,0.1,0.1C11.9,18,11,18.2,10,18.2c-0.8,0-1.6-0.1-2.3-0.3L10.2,10.7L10.2,10.7L10.2,10.7z M14.2,17.1 l2.5-7.3c0.5-1.2,0.6-2.1,0.6-2.9c0-0.3,0-0.6-0.1-0.8c0.6,1.2,1,2.5,1,4C18.3,13,16.6,15.7,14.2,17.1L14.2,17.1L14.2,17.1z\\\"/></svg>\",\n        \"world\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M1,10.5 L19,10.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M2.35,15.5 L17.65,15.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M2.35,5.5 L17.523,5.5\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" d=\\\"M10,19.46 L9.98,19.46 C7.31,17.33 5.61,14.141 5.61,10.58 C5.61,7.02 7.33,3.83 10,1.7 C10.01,1.7 9.99,1.7 10,1.7 L10,1.7 C12.67,3.83 14.4,7.02 14.4,10.58 C14.4,14.141 12.67,17.33 10,19.46 L10,19.46 L10,19.46 L10,19.46 Z\\\"/><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"10\\\" cy=\\\"10.5\\\" r=\\\"9\\\"/></svg>\",\n        \"xing\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M4.4,4.56 C4.24,4.56 4.11,4.61 4.05,4.72 C3.98,4.83 3.99,4.97 4.07,5.12 L5.82,8.16 L5.82,8.17 L3.06,13.04 C2.99,13.18 2.99,13.33 3.06,13.44 C3.12,13.55 3.24,13.62 3.4,13.62 L6,13.62 C6.39,13.62 6.57,13.36 6.71,13.12 C6.71,13.12 9.41,8.35 9.51,8.16 C9.49,8.14 7.72,5.04 7.72,5.04 C7.58,4.81 7.39,4.56 6.99,4.56 L4.4,4.56 L4.4,4.56 Z\\\"/><path d=\\\"M15.3,1 C14.91,1 14.74,1.25 14.6,1.5 C14.6,1.5 9.01,11.42 8.82,11.74 C8.83,11.76 12.51,18.51 12.51,18.51 C12.64,18.74 12.84,19 13.23,19 L15.82,19 C15.98,19 16.1,18.94 16.16,18.83 C16.23,18.72 16.23,18.57 16.16,18.43 L12.5,11.74 L12.5,11.72 L18.25,1.56 C18.32,1.42 18.32,1.27 18.25,1.16 C18.21,1.06 18.08,1 17.93,1 L15.3,1 L15.3,1 Z\\\"/></svg>\",\n        \"yelp\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M17.175,14.971c-0.112,0.77-1.686,2.767-2.406,3.054c-0.246,0.1-0.487,0.076-0.675-0.069\\tc-0.122-0.096-2.446-3.859-2.446-3.859c-0.194-0.293-0.157-0.682,0.083-0.978c0.234-0.284,0.581-0.393,0.881-0.276\\tc0.016,0.01,4.21,1.394,4.332,1.482c0.178,0.148,0.263,0.379,0.225,0.646L17.175,14.971L17.175,14.971z M11.464,10.789\\tc-0.203-0.307-0.199-0.666,0.009-0.916c0,0,2.625-3.574,2.745-3.657c0.203-0.135,0.452-0.141,0.69-0.025\\tc0.691,0.335,2.085,2.405,2.167,3.199v0.027c0.024,0.271-0.082,0.491-0.273,0.623c-0.132,0.083-4.43,1.155-4.43,1.155\\tc-0.322,0.096-0.68-0.06-0.882-0.381L11.464,10.789z M9.475,9.563C9.32,9.609,8.848,9.757,8.269,8.817c0,0-3.916-6.16-4.007-6.351\\tc-0.057-0.212,0.011-0.455,0.202-0.65C5.047,1.211,8.21,0.327,9.037,0.529c0.27,0.069,0.457,0.238,0.522,0.479\\tc0.047,0.266,0.433,5.982,0.488,7.264C10.098,9.368,9.629,9.517,9.475,9.563z M9.927,19.066c-0.083,0.225-0.273,0.373-0.54,0.421\\tc-0.762,0.13-3.15-0.751-3.647-1.342c-0.096-0.131-0.155-0.262-0.167-0.394c-0.011-0.095,0-0.189,0.036-0.272\\tc0.061-0.155,2.917-3.538,2.917-3.538c0.214-0.272,0.595-0.355,0.952-0.213c0.345,0.13,0.56,0.428,0.536,0.749\\tC10.014,14.479,9.977,18.923,9.927,19.066z M3.495,13.912c-0.235-0.009-0.444-0.148-0.568-0.382c-0.089-0.17-0.151-0.453-0.19-0.794\\tC2.63,11.701,2.761,10.144,3.07,9.648c0.145-0.226,0.357-0.345,0.592-0.336c0.154,0,4.255,1.667,4.255,1.667\\tc0.321,0.118,0.521,0.453,0.5,0.833c-0.023,0.37-0.236,0.655-0.551,0.738L3.495,13.912z\\\"/></svg>\",\n        \"youtube\": \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><path d=\\\"M15,4.1c1,0.1,2.3,0,3,0.8c0.8,0.8,0.9,2.1,0.9,3.1C19,9.2,19,10.9,19,12c-0.1,1.1,0,2.4-0.5,3.4c-0.5,1.1-1.4,1.5-2.5,1.6 c-1.2,0.1-8.6,0.1-11,0c-1.1-0.1-2.4-0.1-3.2-1c-0.7-0.8-0.7-2-0.8-3C1,11.8,1,10.1,1,8.9c0-1.1,0-2.4,0.5-3.4C2,4.5,3,4.3,4.1,4.2 C5.3,4.1,12.6,4,15,4.1z M8,7.5v6l5.5-3L8,7.5z\\\"/></svg>\" });\n\n    }\n\n    if (typeof window !== 'undefined' && window.UIkit) {\n      window.UIkit.use(plugin);\n    }\n\n    return plugin;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvZGlzdC9qcy91aWtpdC1pY29ucy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUN5RztBQUM3RyxDQUFDLHVCQUF1Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseWFBQXlhOztBQUV6YTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91aWtpdC9kaXN0L2pzL3Vpa2l0LWljb25zLmpzP2VlNTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIFVJa2l0IDMuMTQuMSB8IGh0dHBzOi8vd3d3LmdldHVpa2l0LmNvbSB8IChjKSAyMDE0IC0gMjAyMiBZT090aGVtZSB8IE1JVCBMaWNlbnNlICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgndWlraXRpY29ucycsIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVUlraXRJY29ucyA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBwbHVnaW4oVUlraXQpIHtcbiAgICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgVUlraXQuaWNvbi5hZGQoe1xuICAgICAgICBcIjUwMHB4XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNOS42MjQsMTEuODY2Yy0wLjE0MSwwLjEzMiwwLjQ3OSwwLjY1OCwwLjY2MiwwLjQxOGMwLjA1MS0wLjA0NiwwLjYwNy0wLjYxLDAuNjYyLTAuNjY0YzAsMCwwLjczOCwwLjcxOSwwLjgxNCwwLjcxOSBjMC4xLDAsMC4yMDctMC4wNTUsMC4zMjItMC4xN2MwLjI3LTAuMjY5LDAuMTM1LTAuNDE2LDAuMDY2LTAuNDk1bC0wLjYzMS0wLjYxNmwwLjY1OC0wLjY2OGMwLjE0Ni0wLjE1NiwwLjAyMS0wLjMxNC0wLjEtMC40NDkgYy0wLjE4Mi0wLjE4LTAuMzU5LTAuMjI2LTAuNDcxLTAuMTI1bC0wLjY1NiwwLjY1NGwtMC42NTQtMC42NTRjLTAuMDMzLTAuMDM0LTAuMDgtMC4wNDUtMC4xMjQtMC4wNDUgYy0wLjA3OSwwLTAuMTkxLDAuMDY4LTAuMzA3LDAuMTgxYy0wLjIwMiwwLjIwMi0wLjI0NywwLjM1MS0wLjEzMywwLjQ2MmwwLjY2NSwwLjY2NUw5LjYyNCwxMS44NjZ6XFxcIi8+PHBhdGggZD1cXFwiTTExLjA2NiwyLjg4NGMtMS4wNjEsMC0yLjE4NSwwLjI0OC0zLjAxMSwwLjYwNGMtMC4wODcsMC4wMzQtMC4xNDEsMC4xMDYtMC4xNSwwLjIwNUM3Ljg5MywzLjc4NCw3LjkxOSwzLjkwOSw3Ljk4Miw0LjA2NiBjMC4wNSwwLjEzNiwwLjE4NywwLjQ3NCwwLjQ1MiwwLjM3MmMwLjg0NC0wLjMyNiwxLjc3OS0wLjUwNywyLjYzMy0wLjUwN2MwLjk2MywwLDEuOSwwLjE5MSwyLjc4MSwwLjU2NCBjMC42OTUsMC4yOTIsMS4zNTcsMC43MTksMi4wNzgsMS4zNGMwLjA1MSwwLjA0NCwwLjEwNSwwLjA2OCwwLjE2NCwwLjA2OGMwLjE0MywwLDAuMjczLTAuMTM3LDAuMzg5LTAuMjcxIGMwLjE5MS0wLjIxNCwwLjMyNC0wLjM5NSwwLjEzNS0wLjU3NWMtMC42ODYtMC42NTQtMS40MzYtMS4xMzgtMi4zNjMtMS41MzNDMTMuMjQsMy4wOTcsMTIuMTY4LDIuODg0LDExLjA2NiwyLjg4NHpcXFwiLz48cGF0aCBkPVxcXCJNMTYuNDMsMTUuNzQ3Yy0wLjA5Mi0wLjAyOC0wLjI0MiwwLjA1LTAuMzA5LDAuMTE5bDAsMGMtMC42NTIsMC42NTItMS40MiwxLjE2OS0yLjI2OCwxLjUyMSBjLTAuODc3LDAuMzcxLTEuODE0LDAuNTUxLTIuNzc5LDAuNTUxYy0wLjk2MSwwLTEuODk2LTAuMTg5LTIuNzc1LTAuNTY0Yy0wLjg0OC0wLjM2LTEuNjEyLTAuODc5LTIuMjY4LTEuNTMgYy0wLjY4Mi0wLjY4OC0xLjE5Ni0xLjQ1NS0xLjUyOS0yLjI2OGMtMC4zMjUtMC43OTktMC40NzEtMS42NDMtMC40NzEtMS42NDNjLTAuMDQ1LTAuMjQtMC4yNTgtMC4yNDktMC41NjctMC4yMDMgYy0wLjEyOCwwLjAyMS0wLjUxOSwwLjA3OS0wLjQ4MywwLjM2djAuMDFjMC4xMDUsMC42NDQsMC4yODksMS4yODQsMC41NDUsMS44OTVjMC40MTcsMC45NjksMS4wMDIsMS44NDksMS43NTYsMi42MDQgYzAuNzU3LDAuNzU0LDEuNjM2LDEuMzQsMi42MDQsMS43NTdDOC45MDEsMTguNzg1LDkuOTcsMTksMTEuMDg4LDE5YzEuMTA0LDAsMi4xODYtMC4yMTUsMy4xODgtMC42NDUgYzEuODM4LTAuODk2LDIuNjA0LTEuNzU3LDIuNjA0LTEuNzU3YzAuMTgyLTAuMjA0LDAuMjI3LTAuMzE3LTAuMS0wLjY0M0MxNi43NzksMTUuOTU2LDE2LjUyNSwxNS43NzQsMTYuNDMsMTUuNzQ3elxcXCIvPjxwYXRoIGQ9XFxcIk01LjYzMywxMy4yODdjMC4yOTMsMC43MSwwLjcyMywxLjM0MSwxLjI2MiwxLjg4MmMwLjU0LDAuNTQsMS4xNzIsMC45NzEsMS44ODIsMS4yNjRjMC43MzEsMC4zMDMsMS41MDksMC40NjEsMi4yOTgsMC40NjEgYzAuODAxLDAsMS41NzgtMC4xNTgsMi4yOTctMC40NjFjMC43MTEtMC4yOTMsMS4zNDQtMC43MjQsMS44ODMtMS4yNjRjMC41NDMtMC41NDEsMC45NzEtMS4xNzIsMS4yNjQtMS44ODIgYzAuMzE0LTAuNzIxLDAuNDYzLTEuNSwwLjQ2My0yLjI5OGMwLTAuNzktMC4xNDgtMS41NjktMC40NjMtMi4yODljLTAuMjkzLTAuNjk5LTAuNzIxLTEuMzI5LTEuMjY0LTEuODgxIGMtMC41MzktMC41NDEtMS4xNzItMC45NTktMS44NjctMS4yNjNjLTAuNzIxLTAuMzAzLTEuNS0wLjQ2MS0yLjI5OS0wLjQ2MWMtMC44MDIsMC0xLjYxMywwLjE1OS0yLjMyMiwwLjQ2MSBjLTAuNTc3LDAuMjUtMS41NDQsMC44NjctMi4xMTksMS40NTR2MC4wMTJWMi4xMDhoOC4xNkMxNS4xLDIuMTA0LDE1LjEsMS42OSwxNS4xLDEuNTUyQzE1LjEsMS40MTcsMTUuMSwxLDE0LjgwOSwxSDUuOTE1IEM1LjY3NiwxLDUuNTI3LDEuMTkyLDUuNTI3LDEuMzg0djYuODRjMCwwLjIxNCwwLjI3MywwLjM3MiwwLjUyOSwwLjQyOGMwLjUsMC4xMDUsMC42MTQtMC4wNTYsMC43MzctMC4yMjRsMCwwIGMwLjE4LTAuMjczLDAuNzc2LTAuODg0LDAuNzg3LTAuODk0YzAuOTAxLTAuOTA1LDIuMTE3LTEuNDA4LDMuNDE2LTEuNDA4YzEuMjg1LDAsMi41LDAuNTAxLDMuNDEyLDEuNDA4IGMwLjkxNCwwLjkxNCwxLjQwOCwyLjEyMiwxLjQwOCwzLjQwNWMwLDEuMjg4LTAuNTA4LDIuNDk2LTEuNDA4LDMuNDA1Yy0wLjksMC44OTYtMi4xNTIsMS40MDYtMy40MzgsMS40MDYgYy0wLjg3NywwLTEuNzExLTAuMjI5LTIuNDMzLTAuNjcxdi00LjE1OGMwLTAuNTUzLDAuMjM3LTEuMTUxLDAuNjQzLTEuNjE0YzAuNDYyLTAuNTE5LDEuMDk0LTAuNzk5LDEuNzgyLTAuNzk5IGMwLjY2NCwwLDEuMjkzLDAuMjUzLDEuNzU4LDAuNzE1YzAuNDU5LDAuNDU5LDAuNzA5LDEuMDcxLDAuNzA5LDEuNzIzYzAsMS4zODUtMS4wOTQsMi40NjgtMi40ODgsMi40NjggYy0wLjI3MywwLTAuNzY5LTAuMTIxLTAuNzgxLTAuMTI1Yy0wLjI4MS0wLjA4Ny0wLjQwNSwwLjMwNi0wLjQzOCwwLjQzNmMtMC4xNTksMC40OTYsMC4wNzksMC41ODUsMC4xMjMsMC42MDcgYzAuNDUyLDAuMTM3LDAuNzQzLDAuMTU3LDEuMTI5LDAuMTU3YzEuOTczLDAsMy41NzItMS42LDMuNTcyLTMuNTdjMC0xLjk2NC0xLjYtMy41NTItMy41NzItMy41NTJjLTAuOTcsMC0xLjg3MiwwLjM2LTIuNTQ2LDEuMDM4IGMtMC42NTYsMC42MzEtMS4wMjcsMS40ODctMS4wMjcsMi4zMjJ2My40Mzh2LTAuMDExYy0wLjM3Mi0wLjQyLTAuNzMyLTEuMDQxLTAuOTgxLTEuNjgyYy0wLjEwMi0wLjI0OC0wLjMxNS0wLjIwMi0wLjYwNy0wLjExMyBjLTAuMTM1LDAuMDM1LTAuNTE5LDAuMTU3LTAuNDQsMC40MzlDNS4zNzIsMTIuNzk5LDUuNTc3LDEzLjE2NCw1LjYzMywxMy4yODd6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiYWxidW1cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjVcXFwiIHk9XFxcIjJcXFwiIHdpZHRoPVxcXCIxMFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiM1xcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjE0XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjEuNVxcXCIgeT1cXFwiNi41XFxcIiB3aWR0aD1cXFwiMTdcXFwiIGhlaWdodD1cXFwiMTFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJhcnJvdy1kb3duXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjEwLjUsMTYuMDggNS42MywxMC42NiA2LjM3LDEwIDEwLjUsMTQuNTggMTQuNjMsMTAgMTUuMzcsMTAuNjZcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCIxMC41XFxcIiB5MT1cXFwiNFxcXCIgeDI9XFxcIjEwLjVcXFwiIHkyPVxcXCIxNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImFycm93LWxlZnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTAgMTQgNSA5LjUgMTAgNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjE2XFxcIiB5MT1cXFwiOS41XFxcIiB4Mj1cXFwiNVxcXCIgeTI9XFxcIjkuNTJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJhcnJvdy1yaWdodFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCIxMCA1IDE1IDkuNSAxMCAxNFxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjRcXFwiIHkxPVxcXCI5LjVcXFwiIHgyPVxcXCIxNVxcXCIgeTI9XFxcIjkuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImFycm93LXVwXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjEwLjUsNCAxNS4zNyw5LjQgMTQuNjMsMTAuMDggMTAuNSw1LjQ5IDYuMzcsMTAuMDggNS42Myw5LjRcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCIxMC41XFxcIiB5MT1cXFwiMTZcXFwiIHgyPVxcXCIxMC41XFxcIiB5Mj1cXFwiNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImJhZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNNy41LDcuNVY0QTIuNDgsMi40OCwwLDAsMSwxMCwxLjUsMi41NCwyLjU0LDAsMCwxLDEyLjUsNFY3LjVcXFwiLz48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTYuNSA3LjUgMy41IDcuNSAyLjUgMTguNSAxNy41IDE4LjUgMTYuNSA3LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJiYW5cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiNFxcXCIgeTE9XFxcIjMuNVxcXCIgeDI9XFxcIjE2XFxcIiB5Mj1cXFwiMTYuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImJlaGFuY2VcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk05LjUsMTAuNmMtMC40LTAuNS0wLjktMC45LTEuNi0xLjFjMS43LTEsMi4yLTMuMiwwLjctNC43QzcuOCw0LDYuMyw0LDUuMiw0QzMuNSw0LDEuNyw0LDAsNHYxMmMxLjcsMCwzLjQsMCw1LjIsMCBjMSwwLDIuMSwwLDMuMS0wLjVDMTAuMiwxNC42LDEwLjUsMTIuMyw5LjUsMTAuNkw5LjUsMTAuNnogTTUuNiw2LjFjMS44LDAsMS44LDIuNy0wLjEsMi43Yy0xLDAtMiwwLTIuOSwwVjYuMUg1LjZ6IE0yLjYsMTMuOHYtMy4xIGMxLjEsMCwyLjEsMCwzLjIsMGMyLjEsMCwyLjEsMy4yLDAuMSwzLjJMMi42LDEzLjh6XFxcIi8+PHBhdGggZD1cXFwiTTE5LjksMTAuOUMxOS43LDkuMiwxOC43LDcuNiwxNyw3Yy00LjItMS4zLTcuMywzLjQtNS4zLDcuMWMwLjksMS43LDIuOCwyLjMsNC43LDIuMWMxLjctMC4yLDIuOS0xLjMsMy40LTIuOWgtMi4yIGMtMC40LDEuMy0yLjQsMS41LTMuNSwwLjZjLTAuNC0wLjQtMC42LTEuMS0wLjYtMS43SDIwQzIwLDExLjcsMTkuOSwxMC45LDE5LjksMTAuOXogTTEzLjUsMTAuNmMwLTEuNiwyLjMtMi43LDMuNS0xLjQgYzAuNCwwLjQsMC41LDAuOSwwLjYsMS40SDEzLjVMMTMuNSwxMC42elxcXCIvPjxyZWN0IHg9XFxcIjEzXFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiNVxcXCIgaGVpZ2h0PVxcXCIxLjRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJiZWxsXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTcsMTUuNSBMMywxNS41IEMyLjk5LDE0LjYxIDMuNzksMTMuMzQgNC4xLDEyLjUxIEM0LjU4LDExLjMgNC43MiwxMC4zNSA1LjE5LDcuMDEgQzUuNTQsNC41MyA1Ljg5LDMuMiA3LjI4LDIuMTYgQzguMTMsMS41NiA5LjM3LDEuNSA5LjgxLDEuNSBMOS45NiwxLjUgQzkuOTYsMS41IDExLjYyLDEuNDEgMTIuNjcsMi4xNyBDMTQuMDgsMy4yIDE0LjQyLDQuNTQgMTQuNzcsNy4wMiBDMTUuMjYsMTAuMzUgMTUuNCwxMS4zMSAxNS44NywxMi41MiBDMTYuMiwxMy4zNCAxNy4wMSwxNC42MSAxNywxNS41IEwxNywxNS41IFpcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xMi4zOSwxNiBDMTIuMzksMTcuMzcgMTEuMzUsMTguNDMgOS45MSwxOC40MyBDOC40OCwxOC40MyA3LjQyLDE3LjM3IDcuNDIsMTZcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJib2xkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNSwxNS4zIEM1LjY2LDE1LjMgNS45LDE1IDUuOSwxNC41MyBMNS45LDUuNSBDNS45LDQuOTIgNS41Niw0LjcgNSw0LjcgTDUsNCBMOC45NSw0IEMxMi42LDQgMTMuNyw1LjM3IDEzLjcsNi45IEMxMy43LDcuODcgMTMuMTQsOS4xNyAxMC44Niw5LjU5IEwxMC44Niw5LjcgQzEzLjI1LDkuODYgMTQuMjksMTEuMjggMTQuMywxMi41NCBDMTQuMywxNC40NyAxMi45NCwxNiA5LDE2IEw1LDE2IEw1LDE1LjMgWiBNOSw5LjMgQzExLjE5LDkuMyAxMS44LDguNSAxMS44NSw3IEMxMS44NSw1LjY1IDExLjMsNC44IDksNC44IEw3LjY3LDQuOCBMNy42Nyw5LjMgTDksOS4zIFogTTkuMTg1LDE1LjIyIEMxMS45NywxNSAxMi4zOSwxNCAxMi40LDEyLjU4IEMxMi40LDExLjE1IDExLjM5LDEwIDksMTAgTDcuNjcsMTAgTDcuNjcsMTUgTDkuMTgsMTUgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImJvbHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk00Ljc0LDIwIEw3LjczLDEyIEwzLDEyIEwxNS40MywxIEwxMi4zMiw5IEwxNy4wMiw5IEw0Ljc0LDIwIEw0Ljc0LDIwIEw0Ljc0LDIwIFogTTkuMTgsMTEgTDcuMSwxNi4zOSBMMTQuNDcsMTAgTDEwLjg2LDEwIEwxMi45OSw0LjY3IEw1LjYxLDExIEw5LjE4LDExIEw5LjE4LDExIEw5LjE4LDExIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJib29rbWFya1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjUuNSAxLjUgMTUuNSAxLjUgMTUuNSAxNy41IDEwLjUgMTIuNSA1LjUgMTcuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNhbGVuZGFyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNIDIsMyAyLDE3IDE4LDE3IDE4LDMgMiwzIFogTSAxNywxNiAzLDE2IDMsOCAxNyw4IDE3LDE2IFogTSAxNyw3IDMsNyAzLDQgMTcsNCAxNyw3IFpcXFwiLz48cmVjdCB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIzXFxcIiB4PVxcXCI2XFxcIiB5PVxcXCIyXFxcIi8+PHJlY3Qgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiM1xcXCIgeD1cXFwiMTNcXFwiIHk9XFxcIjJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjYW1lcmFcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTAuOFxcXCIgcj1cXFwiMy44XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMSw0LjUgQzAuNyw0LjUgMC41LDQuNyAwLjUsNSBMMC41LDE3IEMwLjUsMTcuMyAwLjcsMTcuNSAxLDE3LjUgTDE5LDE3LjUgQzE5LjMsMTcuNSAxOS41LDE3LjMgMTkuNSwxNyBMMTkuNSw1IEMxOS41LDQuNyAxOS4zLDQuNSAxOSw0LjUgTDEzLjUsNC41IEwxMy41LDIuOSBDMTMuNSwyLjYgMTMuMywyLjUgMTMsMi41IEw3LDIuNSBDNi43LDIuNSA2LjUsMi42IDYuNSwyLjkgTDYuNSw0LjUgTDEsNC41IEwxLDQuNSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2FydFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBjeD1cXFwiNy4zXFxcIiBjeT1cXFwiMTcuM1xcXCIgcj1cXFwiMS40XFxcIi8+PGNpcmNsZSBjeD1cXFwiMTMuM1xcXCIgY3k9XFxcIjE3LjNcXFwiIHI9XFxcIjEuNFxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMCAyIDMuMiA0IDUuMyAxMi41IDE2IDEyLjUgMTggNi41IDggNi41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hlY2tcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBwb2ludHM9XFxcIjQsMTAgOCwxNSAxNyw0XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi1kb3VibGUtbGVmdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBwb2ludHM9XFxcIjEwIDE0IDYgMTAgMTAgNlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgcG9pbnRzPVxcXCIxNCAxNCAxMCAxMCAxNCA2XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi1kb3VibGUtcmlnaHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgcG9pbnRzPVxcXCIxMCA2IDE0IDEwIDEwIDE0XFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAzXFxcIiBwb2ludHM9XFxcIjYgNiAxMCAxMCA2IDE0XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2hldnJvbi1kb3duXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiMTYgNyAxMCAxMyA0IDdcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjaGV2cm9uLWxlZnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wM1xcXCIgcG9pbnRzPVxcXCIxMyAxNiA3IDEwIDEzIDRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjaGV2cm9uLXJpZ2h0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiNyA0IDEzIDEwIDcgMTZcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjaGV2cm9uLXVwXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIHBvaW50cz1cXFwiNCAxMyAxMCA3IDE2IDEzXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY2xvY2tcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48cmVjdCB4PVxcXCI5XFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI3XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEzLjAxOCwxNC4xOTcgTDkuNDQ1LDEwLjYyNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNsb3NlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wNlxcXCIgZD1cXFwiTTE2LDE2IEw0LDRcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wNlxcXCIgZD1cXFwiTTE2LDQgTDQsMTZcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjbG91ZC1kb3dubG9hZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTYuNSwxNC42MSBMMy43NSwxNC42MSBDMS45NiwxNC42MSAwLjUsMTMuMTcgMC41LDExLjM5IEMwLjUsOS43NiAxLjcyLDguNDEgMy4zLDguMiBDMy4zOCw1LjMxIDUuNzUsMyA4LjY4LDMgQzExLjE5LDMgMTMuMzEsNC43MSAxMy44OSw3LjAyIEMxNC4zOSw2LjggMTQuOTMsNi42OCAxNS41LDYuNjggQzE3LjcxLDYuNjggMTkuNSw4LjQ1IDE5LjUsMTAuNjQgQzE5LjUsMTIuODMgMTcuNzEsMTQuNiAxNS41LDE0LjYgTDEyLjUsMTQuNlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTEuNzUgMTYgOS41IDE4LjI1IDcuMjUgMTZcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk05LjUsMTggTDkuNSw5LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjbG91ZC11cGxvYWRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk02LjUsMTQuNjEgTDMuNzUsMTQuNjEgQzEuOTYsMTQuNjEgMC41LDEzLjE3IDAuNSwxMS4zOSBDMC41LDkuNzYgMS43Miw4LjQxIDMuMzEsOC4yIEMzLjM4LDUuMzEgNS43NSwzIDguNjgsMyBDMTEuMTksMyAxMy4zMSw0LjcxIDEzLjg5LDcuMDIgQzE0LjM5LDYuOCAxNC45Myw2LjY4IDE1LjUsNi42OCBDMTcuNzEsNi42OCAxOS41LDguNDUgMTkuNSwxMC42NCBDMTkuNSwxMi44MyAxNy43MSwxNC42IDE1LjUsMTQuNiBMMTIuNSwxNC42XFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI3LjI1IDExLjc1IDkuNSA5LjUgMTEuNzUgMTEuNzVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk05LjUsMTggTDkuNSw5LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJjb2RlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDFcXFwiIHBvaW50cz1cXFwiMTMsNCAxOSwxMCAxMywxNlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wMVxcXCIgcG9pbnRzPVxcXCI3LDQgMSwxMCA3LDE2XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY29nXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjkuOTk3XFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjMuMzFcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xOC40ODgsMTIuMjg1IEwxNi4yMDUsMTYuMjM3IEMxNS4zMjIsMTUuNDk2IDE0LjE4NSwxNS4yODEgMTMuMzAzLDE1Ljc5MSBDMTIuNDI4LDE2LjI4OSAxMi4wNDcsMTcuMzczIDEyLjI0NiwxOC41IEw3LjczNSwxOC41IEM3LjkzOCwxNy4zNzQgNy41NTMsMTYuMjk5IDYuNjg0LDE1Ljc5MSBDNS44MDEsMTUuMjcgNC42NTUsMTUuNDkyIDMuNzczLDE2LjIzNyBMMS41LDEyLjI4NSBDMi41NzMsMTEuODcxIDMuMzE3LDEwLjk5OSAzLjMxNyw5Ljk5MSBDMy4zMDUsOC45OCAyLjU3Myw4LjEyMSAxLjUsNy43MTYgTDMuNzY1LDMuNzg0IEM0LjY0NSw0LjUxNiA1Ljc5NCw0LjczOCA2LjY4Nyw0LjIzMiBDNy41NTUsMy43MjIgNy45MzksMi42MzcgNy43MzUsMS41IEwxMi4yNjMsMS41IEMxMi4wNzIsMi42MzcgMTIuNDQxLDMuNzEgMTMuMzE0LDQuMjIgQzE0LjIwNiw0LjczIDE1LjM0Myw0LjUxNiAxNi4yMjUsMy43OTQgTDE4LjQ4Nyw3LjcxNCBDMTcuNDA0LDguMTE3IDE2LjY2MSw4Ljk4OCAxNi42NywxMC4wMDkgQzE2LjY3MiwxMS4wMTggMTcuNDE1LDExLjg4IDE4LjQ4OCwxMi4yODUgTDE4LjQ4OCwxMi4yODUgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNvbW1lbnRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk02LDE4LjcxIEw2LDE0IEwxLDE0IEwxLDEgTDE5LDEgTDE5LDE0IEwxMC43MSwxNCBMNiwxOC43MSBMNiwxOC43MSBaIE0yLDEzIEw3LDEzIEw3LDE2LjI5IEwxMC4yOSwxMyBMMTgsMTMgTDE4LDIgTDIsMiBMMiwxMyBMMiwxMyBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY29tbWVudGluZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjEuNSwxLjUgMTguNSwxLjUgMTguNSwxMy41IDEwLjUsMTMuNSA2LjUsMTcuNSA2LjUsMTMuNSAxLjUsMTMuNVxcXCIvPjxjaXJjbGUgY3g9XFxcIjEwXFxcIiBjeT1cXFwiOFxcXCIgcj1cXFwiMVxcXCIvPjxjaXJjbGUgY3g9XFxcIjZcXFwiIGN5PVxcXCI4XFxcIiByPVxcXCIxXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTRcXFwiIGN5PVxcXCI4XFxcIiByPVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiY29tbWVudHNcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMiAwLjUgMTkuNSAwLjUgMTkuNSAxM1xcXCIvPjxwYXRoIGQ9XFxcIk01LDE5LjcxIEw1LDE1IEwwLDE1IEwwLDIgTDE4LDIgTDE4LDE1IEw5LjcxLDE1IEw1LDE5LjcxIEw1LDE5LjcxIEw1LDE5LjcxIFogTTEsMTQgTDYsMTQgTDYsMTcuMjkgTDkuMjksMTQgTDE3LDE0IEwxNywzIEwxLDMgTDEsMTQgTDEsMTQgTDEsMTQgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNvcHlcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMy41XFxcIiB5PVxcXCIyLjVcXFwiIHdpZHRoPVxcXCIxMlxcXCIgaGVpZ2h0PVxcXCIxNlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNSAwLjUgMTcuNSAwLjUgMTcuNSAxN1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImNyZWRpdC1jYXJkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjEuNVxcXCIgeT1cXFwiNC41XFxcIiB3aWR0aD1cXFwiMTdcXFwiIGhlaWdodD1cXFwiMTJcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCI3XFxcIiB3aWR0aD1cXFwiMThcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImRhdGFiYXNlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48ZWxsaXBzZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjQuNjRcXFwiIHJ4PVxcXCI3LjVcXFwiIHJ5PVxcXCIzLjE0XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTcuNSw4LjExIEMxNy41LDkuODUgMTQuMTQsMTEuMjUgMTAsMTEuMjUgQzUuODYsMTEuMjUgMi41LDkuODQgMi41LDguMTFcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNy41LDExLjI1IEMxNy41LDEyLjk5IDE0LjE0LDE0LjM5IDEwLDE0LjM5IEM1Ljg2LDE0LjM5IDIuNSwxMi45OCAyLjUsMTEuMjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNy40OSw0LjY0IEwxNy41LDE0LjM2IEMxNy41LDE2LjEgMTQuMTQsMTcuNSAxMCwxNy41IEM1Ljg2LDE3LjUgMi41LDE2LjA5IDIuNSwxNC4zNiBMMi41LDQuNjRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJkZXNrdG9wXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCI4XFxcIiB5PVxcXCIxNVxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjExXFxcIiB5PVxcXCIxNVxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjVcXFwiIHk9XFxcIjE2XFxcIiB3aWR0aD1cXFwiMTBcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeD1cXFwiMS41XFxcIiB5PVxcXCIzLjVcXFwiIHdpZHRoPVxcXCIxN1xcXCIgaGVpZ2h0PVxcXCIxMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImRpc2NvcmRcIjogXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiPjxwYXRoIGQ9XFxcIk0xNi4wNzQsNC4zNjFhMTQuMjQzLDE0LjI0MywwLDAsMC0zLjYxLTEuMTM0LDEwLjYxLDEwLjYxLDAsMCwwLS40NjMuOTYsMTMuMjE5LDEzLjIxOSwwLDAsMC00LDAsMTAuMTM4LDEwLjEzOCwwLDAsMC0uNDY4LS45NkExNC4yMDYsMTQuMjA2LDAsMCwwLDMuOTE5LDQuMzY0LDE1LjE0NiwxNS4xNDYsMCwwLDAsMS4zMjQsMTQuNWExNC40MzUsMTQuNDM1LDAsMCwwLDQuNDI4LDIuMjY5QTEwLjk4MiwxMC45ODIsMCwwLDAsNi43LDE1LjIxYTkuMjk0LDkuMjk0LDAsMCwxLTEuNDk0LS43MjdjLjEyNS0uMDkzLjI0OC0uMTkuMzY2LS4yODlhMTAuMjEyLDEwLjIxMiwwLDAsMCw4Ljg1NCwwYy4xMTkuMS4yNDIuMi4zNjYuMjg5YTkuMjc0LDkuMjc0LDAsMCwxLTEuNS43MjgsMTAuOCwxMC44LDAsMCwwLC45NDgsMS41NjIsMTQuNDE5LDE0LjQxOSwwLDAsMCw0LjQzMS0yLjI3QTE1LjEyOCwxNS4xMjgsMCwwLDAsMTYuMDc0LDQuMzYxWm0tOC45ODEsOC4xYTEuNywxLjcsMCwwLDEtMS41NzMtMS43OUExLjY4OSwxLjY4OSwwLDAsMSw3LjA5Myw4Ljg4MWExLjY3OSwxLjY3OSwwLDAsMSwxLjU3MywxLjc5MUExLjY4NywxLjY4NywwLDAsMSw3LjA5MywxMi40NjJabTUuODE0LDBhMS43LDEuNywwLDAsMS0xLjU3My0xLjc5LDEuNjg5LDEuNjg5LDAsMCwxLDEuNTczLTEuNzkxLDEuNjc5LDEuNjc5LDAsMCwxLDEuNTczLDEuNzkxQTEuNjg4LDEuNjg4LDAsMCwxLDEyLjkwNywxMi40NjJaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZG93bmxvYWRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTQsMTAgOS41LDE0LjUgNSwxMFxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjE3XFxcIiB3aWR0aD1cXFwiMTNcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjkuNVxcXCIgeTE9XFxcIjEzLjkxXFxcIiB4Mj1cXFwiOS41XFxcIiB5Mj1cXFwiM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImRyaWJiYmxlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiBkPVxcXCJNMS4zLDguOWMwLDAsNSwwLjEsOC42LTFjMS40LTAuNCwyLjYtMC45LDQtMS45IGMxLjQtMS4xLDIuNS0yLjUsMi41LTIuNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIGQ9XFxcIk0zLjksMTYuNmMwLDAsMS43LTIuOCwzLjUtNC4yIGMxLjgtMS4zLDQtMiw1LjctMi4yQzE2LDEwLDE5LDEwLjYsMTksMTAuNlxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIGQ9XFxcIk02LjksMS42YzAsMCwzLjMsNC42LDQuMiw2LjggYzAuNCwwLjksMS4zLDMuMSwxLjksNS4yYzAuNiwyLDAuOSw0LjQsMC45LDQuNFxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJldHN5XCI6IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIj48cGF0aCBkPVxcXCJNOCw0LjI2QzgsNC4wNyw4LDQsOC4zMSw0aDQuNDZjLjc5LDAsMS4yMi42NywxLjUzLDEuOTFsLjI1LDFoLjc2Yy4xNC0yLjgyLjI2LTQsLjI2LTRTMTMuNjUsMywxMi41MiwzSDYuODFMMy43NSwyLjkydi44NGwxLC4yYy43My4xMS45LjI3LDEsMSwwLDAsLjA2LDIsLjA2LDUuMTdzLS4wNiw1LjE0LS4wNiw1LjE0YzAsLjU5LS4yMy44MS0xLC45NGwtMSwuMnYuODRsMy4wNi0uMWg1LjExYzEuMTUsMCwzLjgyLjEsMy44Mi4xLDAtLjcuNDUtMy44OC41MS00LjIyaC0uNzNsLS43NiwxLjY5YTIuMjUsMi4yNSwwLDAsMS0yLjQ1LDEuNDdIOS40Yy0xLDAtMS40NC0uNC0xLjQ0LTEuMjRWMTAuNDRzMi4xNiwwLDIuODYuMDZjLjU1LDAsLjg1LjE5LDEuMDYsMWwuMjMsMUgxM0wxMi45LDkuOTQsMTMsNy40MWgtLjg1bC0uMjgsMS4xM2MtLjE2Ljc0LS4yOC44NC0xLDEtMSwuMS0yLjg5LjA5LTIuODkuMDlaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZXhwYW5kXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjEzIDIgMTggMiAxOCA3IDE3IDcgMTcgMyAxMyAzXFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCIyIDEzIDMgMTMgMyAxNyA3IDE3IDcgMTggMiAxOFxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMSw5IEwxNywzXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTMsMTcgTDksMTFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmYWNlYm9va1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTExLDEwaDIuNmwwLjQtM0gxMVY1LjNjMC0wLjksMC4yLTEuNSwxLjUtMS41SDE0VjEuMWMtMC4zLDAtMS0wLjEtMi4xLTAuMUM5LjYsMSw4LDIuNCw4LDV2Mkg1LjV2M0g4djhoM1YxMHpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmaWxlLWVkaXRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTE4LjY1LDEuNjggQzE4LjQxLDEuNDUgMTguMTA5LDEuMzMgMTcuODEsMS4zMyBDMTcuNDk5LDEuMzMgMTcuMjA5LDEuNDUgMTYuOTgsMS42OCBMOC45Miw5Ljc2IEw4LDEyLjMzIEwxMC41NSwxMS40MSBMMTguNjUxLDMuMzQgQzE5LjEyLDIuODcgMTkuMTIsMi4xNSAxOC42NSwxLjY4IEwxOC42NSwxLjY4IEwxOC42NSwxLjY4IFpcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjE2LjUgOC40ODIgMTYuNSAxOC41IDMuNSAxOC41IDMuNSAxLjUgMTQuMjExIDEuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZpbGUtcGRmXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHdpZHRoPVxcXCIxM1xcXCIgaGVpZ2h0PVxcXCIxN1xcXCIgeD1cXFwiMy41XFxcIiB5PVxcXCIxLjVcXFwiLz48cGF0aCBkPVxcXCJNMTQuNjUgMTEuNjdjLS40OC4zLTEuMzctLjE5LTEuNzktLjM3YTQuNjUgNC42NSAwIDAgMSAxLjQ5LjA2Yy4zNS4xLjM2LjI4LjMuMzF6bS02LjMuMDZsLjQzLS43OWExNC43IDE0LjcgMCAwIDAgLjc1LTEuNjQgNS40OCA1LjQ4IDAgMCAwIDEuMjUgMS41NWwuMi4xNWExNi4zNiAxNi4zNiAwIDAgMC0yLjYzLjczek05LjUgNS4zMmMuMiAwIC4zMi41LjMyLjk3YTEuOTkgMS45OSAwIDAgMS0uMjMgMS4wNCA1LjA1IDUuMDUgMCAwIDEtLjE3LTEuM3MwLS43MS4wOC0uNzF6bS0zLjkgOWE0LjM1IDQuMzUgMCAwIDEgMS4yMS0xLjQ2bC4yNC0uMjJhNC4zNSA0LjM1IDAgMCAxLTEuNDYgMS42OHptOS4yMy0zLjNhMi4wNSAyLjA1IDAgMCAwLTEuMzItLjMgMTEuMDcgMTEuMDcgMCAwIDAtMS41OC4xMSA0LjA5IDQuMDkgMCAwIDEtLjc0LS41IDUuMzkgNS4zOSAwIDAgMS0xLjMyLTIuMDYgMTAuMzcgMTAuMzcgMCAwIDAgLjI4LTIuNjIgMS44MyAxLjgzIDAgMCAwLS4wNy0uMjUuNTcuNTcgMCAwIDAtLjUyLS40SDkuNGEuNTkuNTkgMCAwIDAtLjYuMzggNi45NSA2Ljk1IDAgMCAwIC4zNyAzLjE0Yy0uMjYuNjMtMSAyLjEyLTEgMi4xMi0uMy41OC0uNTcgMS4wOC0uODIgMS41bC0uOC40NEEzLjExIDMuMTEgMCAwIDAgNSAxNC4xNmEuMzkuMzkgMCAwIDAgLjE1LjQybC4yNC4xM2MxLjE1LjU2IDIuMjgtMS43NCAyLjY2LTIuNDJhMjMuMSAyMy4xIDAgMCAxIDMuNTktLjg1IDQuNTYgNC41NiAwIDAgMCAyLjkxLjguNS41IDAgMCAwIC4zLS4yMSAxLjEgMS4xIDAgMCAwIC4xMi0uNzUuODQuODQgMCAwIDAtLjE0LS4yNXpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmaWxlLXRleHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgd2lkdGg9XFxcIjEzXFxcIiBoZWlnaHQ9XFxcIjE3XFxcIiB4PVxcXCIzLjVcXFwiIHk9XFxcIjEuNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjZcXFwiIHgyPVxcXCIxMlxcXCIgeTE9XFxcIjEyLjVcXFwiIHkyPVxcXCIxMi41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiNlxcXCIgeDI9XFxcIjE0XFxcIiB5MT1cXFwiOC41XFxcIiB5Mj1cXFwiOC41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiNlxcXCIgeDI9XFxcIjE0XFxcIiB5MT1cXFwiNi41XFxcIiB5Mj1cXFwiNi41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiNlxcXCIgeDI9XFxcIjE0XFxcIiB5MT1cXFwiMTAuNVxcXCIgeTI9XFxcIjEwLjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmaWxlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiMS41XFxcIiB3aWR0aD1cXFwiMTNcXFwiIGhlaWdodD1cXFwiMTdcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJmbGlja3JcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjUuNVxcXCIgY3k9XFxcIjkuNVxcXCIgcj1cXFwiMy41XFxcIi8+PGNpcmNsZSBjeD1cXFwiMTQuNVxcXCIgY3k9XFxcIjkuNVxcXCIgcj1cXFwiMy41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZm9sZGVyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiOS41IDUuNSA4LjUgMy41IDEuNSAzLjUgMS41IDE2LjUgMTguNSAxNi41IDE4LjUgNS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZm9yd2FyZFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTIuNDcsMTMuMTEgQzQuMDIsMTAuMDIgNi4yNyw3Ljg1IDkuMDQsNi42MSBDOS40OCw2LjQxIDEwLjI3LDYuMTMgMTEsNS45MSBMMTEsMiBMMTguODksOSBMMTEsMTYgTDExLDEyLjEzIEM5LjI1LDEyLjQ3IDcuNTgsMTMuMTkgNi4wMiwxNC4yNSBDMy4wMywxNi4yOCAxLjYzLDE4LjU0IDEuNjMsMTguNTQgQzEuNjMsMTguNTQgMS4zOCwxNS4yOCAyLjQ3LDEzLjExIEwyLjQ3LDEzLjExIFogTTUuMywxMy41MyBDNi45MiwxMi40IDkuMDQsMTEuNCAxMiwxMC45MiBMMTIsMTMuNjMgTDE3LjM2LDkgTDEyLDQuMjUgTDEyLDYuOCBDMTEuNzEsNi44NiAxMC44Niw3LjAyIDkuNjcsNy40OSBDNi43OSw4LjY1IDQuNTgsMTAuOTYgMy40OSwxMy4wOCBDMy4xOCwxMy43IDIuNjgsMTQuODcgMi40OSwxNiBDMy4yOCwxNS4wNSA0LjQsMTQuMTUgNS4zLDEzLjUzIEw1LjMsMTMuNTMgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImZvdXJzcXVhcmVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNS4yMywyIEMxNS45NiwyIDE2LjQsMi40MSAxNi41LDIuODYgQzE2LjU3LDMuMTUgMTYuNTYsMy40NCAxNi41MSwzLjczIEMxNi40Niw0LjA0IDE0Ljg2LDExLjcyIDE0Ljc1LDEyLjAzIEMxNC41NiwxMi41NiAxNC4xNiwxMi44MiAxMy42MSwxMi44MyBDMTMuMDMsMTIuODQgMTEuMDksMTIuNTEgMTAuNjksMTMgQzEwLjM4LDEzLjM4IDcuNzksMTYuMzkgNi44MSwxNy41MyBDNi42MSwxNy43NiA2LjQsMTcuOTYgNi4wOCwxNy45OSBDNS42OCwxOC4wNCA1LjI5LDE3Ljg3IDUuMTcsMTcuNDUgQzUuMTIsMTcuMjggNS4xLDE3LjA5IDUuMSwxNi45MSBDNS4xLDEyLjQgNC44Niw3LjgxIDUuMTEsMy4zMSBDNS4xNywyLjUgNS44MSwyLjEyIDYuNTMsMiBMMTUuMjMsMiBMMTUuMjMsMiBaIE05Ljc2LDExLjQyIEM5Ljk0LDExLjE5IDEwLjE3LDExLjEgMTAuNDUsMTEuMSBMMTIuODYsMTEuMSBDMTMuMTIsMTEuMSAxMy4zMSwxMC45NCAxMy4zNiwxMC42OSBDMTMuMzcsMTAuNjQgMTMuNjIsOS40MSAxMy43NCw4LjgzIEMxMy44MSw4LjUyIDEzLjUzLDguMjggMTMuMjcsOC4yOCBDMTIuMzUsOC4yOSAxMS40Miw4LjI4IDEwLjUsOC4yOCBDOS44NCw4LjI4IDkuODMsNy42OSA5LjgyLDcuMjEgQzkuOCw2Ljg1IDEwLjEzLDYuNTUgMTAuNSw2LjU1IEMxMS41OSw2LjU2IDEyLjY3LDYuNTUgMTMuNzYsNi41NSBDMTQuMDMsNi41NSAxNC4yMyw2LjQgMTQuMjgsNi4xNCBDMTQuMzQsNS44NyAxNC42Nyw0LjI5IDE0LjY3LDQuMjkgQzE0LjY3LDQuMjkgMTQuODIsMy43NCAxNC4xOSwzLjc0IEw3LjM0LDMuNzQgQzcsMy43NSA2Ljg0LDQuMDIgNi44NCw0LjMzIEM2Ljg0LDcuNTggNi44NSwxNC45NSA2Ljg1LDE0Ljk5IEM2Ljg3LDE1IDguODksMTIuNTEgOS43NiwxMS40MiBMOS43NiwxMS40MiBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZnV0dXJlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgcG9pbnRzPVxcXCIxOSAyIDE4IDIgMTggNiAxNCA2IDE0IDcgMTkgNyAxOSAyXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE4LDYuNTQ4IEMxNi43MDksMy4yOSAxMy4zNTQsMSA5LjYsMSBDNC42LDEgMC42LDUgMC42LDEwIEMwLjYsMTUgNC42LDE5IDkuNiwxOSBDMTQuNiwxOSAxOC42LDE1IDE4LjYsMTBcXFwiLz48cmVjdCB4PVxcXCI5XFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI3XFxcIi8+PHBhdGggZD1cXFwiTTEzLjAxOCwxNC4xOTcgTDkuNDQ1LDEwLjYyNVxcXCIgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImdpdC1icmFuY2hcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgY3g9XFxcIjdcXFwiIGN5PVxcXCIzXFxcIiByPVxcXCIyXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBjeD1cXFwiMTRcXFwiIGN5PVxcXCI2XFxcIiByPVxcXCIyXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBjeD1cXFwiN1xcXCIgY3k9XFxcIjE3XFxcIiByPVxcXCIyXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjJcXFwiIGQ9XFxcIk0xNCw4IEMxNCwxMC40MSAxMi40MywxMC44NyAxMC41NiwxMS4yNSBDOS4wOSwxMS41NCA3LDEyLjA2IDcsMTUgTDcsNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImdpdC1mb3JrXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIGN4PVxcXCI1Ljc5XFxcIiBjeT1cXFwiMi43OVxcXCIgcj1cXFwiMS43OVxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgY3g9XFxcIjE0LjE5XFxcIiBjeT1cXFwiMi43OVxcXCIgcj1cXFwiMS43OVxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgY3g9XFxcIjEwLjAzXFxcIiBjeT1cXFwiMTYuNzlcXFwiIHI9XFxcIjEuNzlcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMlxcXCIgZD1cXFwiTTUuNzksNC41NyBMNS43OSw2LjU2IEM1Ljc5LDkuMTkgMTAuMDMsMTAuMjIgMTAuMDMsMTMuMzEgQzEwLjAzLDE0Ljg2IDEwLjA0LDE0LjU1IDEwLjA0LDE0LjU1IEMxMC4wNCwxNC4zNyAxMC4wNCwxNC44NiAxMC4wNCwxMy4zMSBDMTAuMDQsMTAuMjIgMTQuMiw5LjE5IDE0LjIsNi41NiBMMTQuMiw0LjU3XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ2l0aHViLWFsdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEwLDAuNSBDNC43NSwwLjUgMC41LDQuNzYgMC41LDEwLjAxIEMwLjUsMTUuMjYgNC43NSwxOS41MSAxMCwxOS41MSBDMTUuMjQsMTkuNTEgMTkuNSwxNS4yNiAxOS41LDEwLjAxIEMxOS41LDQuNzYgMTUuMjUsMC41IDEwLDAuNSBMMTAsMC41IFogTTEyLjgxLDE3LjY5IEMxMi44MSwxNy42OSAxMi44MSwxNy43IDEyLjc5LDE3LjY5IEMxMi40NywxNy43NSAxMi4zNSwxNy41OSAxMi4zNSwxNy4zNiBMMTIuMzUsMTYuMTcgQzEyLjM1LDE1LjQ1IDEyLjA5LDE0LjkyIDExLjU4LDE0LjU2IEMxMi4yLDE0LjUxIDEyLjc3LDE0LjM5IDEzLjI2LDE0LjIxIEMxMy44NywxMy45OCAxNC4zNiwxMy42OSAxNC43NCwxMy4yOSBDMTUuNDIsMTIuNTkgMTUuNzYsMTEuNTUgMTUuNzYsMTAuMTcgQzE1Ljc2LDkuMjUgMTUuNDUsOC40NiAxNC44Myw3LjggQzE1LjEsNy4wOCAxNS4wNyw2LjI5IDE0Ljc1LDUuNDQgTDE0LjUxLDUuNDIgQzE0LjM0LDUuNCAxNC4wNiw1LjQ2IDEzLjY3LDUuNjEgQzEzLjI1LDUuNzggMTIuNzksNi4wMyAxMi4zMSw2LjM1IEMxMS41NSw2LjE2IDEwLjgxLDYuMDUgMTAuMDksNi4wNSBDOS4zNiw2LjA1IDguNjEsNi4xNSA3Ljg4LDYuMzUgQzcuMjgsNS45NiA2Ljc1LDUuNjggNi4yNiw1LjU0IEM2LjA3LDUuNDcgNS45LDUuNDQgNS43OCw1LjQ0IEw1LjQyLDUuNDQgQzUuMDYsNi4yOSA1LjA0LDcuMDggNS4zMiw3LjggQzQuNyw4LjQ2IDQuNCw5LjI1IDQuNCwxMC4xNyBDNC40LDExLjk0IDQuOTYsMTMuMTYgNi4wOCwxMy44NCBDNi41MywxNC4xMyA3LjA1LDE0LjMyIDcuNjksMTQuNDMgQzguMDMsMTQuNSA4LjMyLDE0LjU0IDguNTUsMTQuNTUgQzguMDcsMTQuODkgNy44MiwxNS40MiA3LjgyLDE2LjE2IEw3LjgyLDE3LjUxIEM3LjgsMTcuNjkgNy43LDE3LjggNy41MSwxNy44IEM0LjIxLDE2Ljc0IDEuODIsMTMuNjUgMS44MiwxMC4wMSBDMS44Miw1LjUgNS40OSwxLjgzIDEwLDEuODMgQzE0LjUsMS44MyAxOC4xNyw1LjUgMTguMTcsMTAuMDEgQzE4LjE4LDEzLjUzIDE1Ljk0LDE2LjU0IDEyLjgxLDE3LjY5IEwxMi44MSwxNy42OSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ2l0aHViXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTAsMSBDNS4wMywxIDEsNS4wMyAxLDEwIEMxLDEzLjk4IDMuNTgsMTcuMzUgNy4xNiwxOC41NCBDNy42MSwxOC42MiA3Ljc3LDE4LjM0IDcuNzcsMTguMTEgQzcuNzcsMTcuOSA3Ljc2LDE3LjMzIDcuNzYsMTYuNTggQzUuMjYsMTcuMTIgNC43MywxNS4zNyA0LjczLDE1LjM3IEM0LjMyLDE0LjMzIDMuNzMsMTQuMDUgMy43MywxNC4wNSBDMi45MSwxMy41IDMuNzksMTMuNSAzLjc5LDEzLjUgQzQuNjksMTMuNTYgNS4xNywxNC40MyA1LjE3LDE0LjQzIEM1Ljk3LDE1LjggNy4yOCwxNS40MSA3Ljc5LDE1LjE4IEM3Ljg3LDE0LjYgOC4xLDE0LjIgOC4zNiwxMy45OCBDNi4zNiwxMy43NSA0LjI2LDEyLjk4IDQuMjYsOS41MyBDNC4yNiw4LjU1IDQuNjEsNy43NCA1LjE5LDcuMTEgQzUuMSw2Ljg4IDQuNzksNS45NyA1LjI4LDQuNzMgQzUuMjgsNC43MyA2LjA0LDQuNDkgNy43NSw1LjY1IEM4LjQ3LDUuNDUgOS4yNCw1LjM1IDEwLDUuMzUgQzEwLjc2LDUuMzUgMTEuNTMsNS40NSAxMi4yNSw1LjY1IEMxMy45Nyw0LjQ4IDE0LjcyLDQuNzMgMTQuNzIsNC43MyBDMTUuMjEsNS45NyAxNC45LDYuODggMTQuODEsNy4xMSBDMTUuMzksNy43NCAxNS43Myw4LjU0IDE1LjczLDkuNTMgQzE1LjczLDEyLjk5IDEzLjYzLDEzLjc1IDExLjYyLDEzLjk3IEMxMS45NCwxNC4yNSAxMi4yMywxNC44IDEyLjIzLDE1LjY0IEMxMi4yMywxNi44NCAxMi4yMiwxNy44MSAxMi4yMiwxOC4xMSBDMTIuMjIsMTguMzUgMTIuMzgsMTguNjMgMTIuODQsMTguNTQgQzE2LjQyLDE3LjM1IDE5LDEzLjk4IDE5LDEwIEMxOSw1LjAzIDE0Ljk3LDEgMTAsMSBMMTAsMSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ2l0dGVyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCIzLjVcXFwiIHk9XFxcIjFcXFwiIHdpZHRoPVxcXCIxLjUzMVxcXCIgaGVpZ2h0PVxcXCIxMS40NzFcXFwiLz48cmVjdCB4PVxcXCI3LjMyNFxcXCIgeT1cXFwiNC4wNTlcXFwiIHdpZHRoPVxcXCIxLjUyOVxcXCIgaGVpZ2h0PVxcXCIxNS4yOTRcXFwiLz48cmVjdCB4PVxcXCIxMS4xNDhcXFwiIHk9XFxcIjQuMDU5XFxcIiB3aWR0aD1cXFwiMS41MjdcXFwiIGhlaWdodD1cXFwiMTUuMjk0XFxcIi8+PHJlY3QgeD1cXFwiMTQuOTcxXFxcIiB5PVxcXCI0LjA1OVxcXCIgd2lkdGg9XFxcIjEuNTI5XFxcIiBoZWlnaHQ9XFxcIjguNDEyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiZ29vZ2xlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTcuODYsOS4wOSBDMTguNDYsMTIuMTIgMTcuMTQsMTYuMDUgMTMuODEsMTcuNTYgQzkuNDUsMTkuNTMgNC4xMywxNy42OCAyLjQ3LDEyLjg3IEMwLjY4LDcuNjggNC4yMiwyLjQyIDkuNSwyLjAzIEMxMS41NywxLjg4IDEzLjQyLDIuMzcgMTUuMDUsMy42NSBDMTUuMjIsMy43OCAxNS4zNywzLjkzIDE1LjYxLDQuMTQgQzE0LjksNC44MSAxNC4yMyw1LjQ1IDEzLjUsNi4xNCBDMTIuMjcsNS4wOCAxMC44NCw0LjcyIDkuMjgsNC45OCBDOC4xMiw1LjE3IDcuMTYsNS43NiA2LjM3LDYuNjMgQzQuODgsOC4yNyA0LjYyLDEwLjg2IDUuNzYsMTIuODIgQzYuOTUsMTQuODcgOS4xNywxNS44IDExLjU3LDE1LjI1IEMxMy4yNywxNC44NyAxNC43NiwxMy4zMyAxNC44OSwxMS43NSBMMTAuNTEsMTEuNzUgTDEwLjUxLDkuMDkgTDE3Ljg2LDkuMDkgTDE3Ljg2LDkuMDkgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImdyaWRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjJcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCI4XFxcIiB5PVxcXCIyXFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiMTRcXFwiIHk9XFxcIjJcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCI4XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiOFxcXCIgeT1cXFwiOFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjE0XFxcIiB5PVxcXCI4XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIzXFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiMTRcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCI4XFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjxyZWN0IHg9XFxcIjE0XFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImhhcHB5XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIxM1xcXCIgY3k9XFxcIjdcXFwiIHI9XFxcIjFcXFwiLz48Y2lyY2xlIGN4PVxcXCI3XFxcIiBjeT1cXFwiN1xcXCIgcj1cXFwiMVxcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOC41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTQuNiwxMS40IEMxMy45LDEzLjMgMTIuMSwxNC41IDEwLDE0LjUgQzcuOSwxNC41IDYuMSwxMy4zIDUuNCwxMS40XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaGFzaHRhZ1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE1LjQzMSw4IEwxNS42NjEsNyBMMTIuOTExLDcgTDEzLjgzMSwzIEwxMi45MDEsMyBMMTEuOTgsNyBMOS4yOSw3IEwxMC4yMSwzIEw5LjI4MSwzIEw4LjM2MSw3IEw1LjIzLDcgTDUsOCBMOC4xMyw4IEw3LjIxLDEyIEw0LjIzLDEyIEw0LDEzIEw2Ljk4LDEzIEw2LjA2MSwxNyBMNi45OTEsMTcgTDcuOTExLDEzIEwxMC42MDEsMTMgTDkuNjgxLDE3IEwxMC42MTEsMTcgTDExLjUzMSwxMyBMMTQuNDMxLDEzIEwxNC42NjEsMTIgTDExLjc2LDEyIEwxMi42ODEsOCBMMTUuNDMxLDggWiBNMTAuODMxLDEyIEw4LjE0MSwxMiBMOS4wNjEsOCBMMTEuNzUsOCBMMTAuODMxLDEyIFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJoZWFydFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDNcXFwiIGQ9XFxcIk0xMCw0IEMxMCw0IDguMSwyIDUuNzQsMiBDMy4zOCwyIDEsMy41NSAxLDYuNzMgQzEsOC44NCAyLjY3LDEwLjQ0IDIuNjcsMTAuNDQgTDEwLDE4IEwxNy4zMywxMC40NCBDMTcuMzMsMTAuNDQgMTksOC44NCAxOSw2LjczIEMxOSwzLjU1IDE2LjYyLDIgMTQuMjYsMiBDMTEuOSwyIDEwLDQgMTAsNCBMMTAsNCBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaGlzdG9yeVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMSAyIDIgMiAyIDYgNiA2IDYgNyAxIDcgMSAyXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTIuMSw2LjU0OCBDMy4zOTEsMy4yOSA2Ljc0NiwxIDEwLjUsMSBDMTUuNSwxIDE5LjUsNSAxOS41LDEwIEMxOS41LDE1IDE1LjUsMTkgMTAuNSwxOSBDNS41LDE5IDEuNSwxNSAxLjUsMTBcXFwiLz48cmVjdCB4PVxcXCI5XFxcIiB5PVxcXCI0XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI3XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEzLjAxOCwxNC4xOTcgTDkuNDQ1LDEwLjYyNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImhvbWVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiMTguNjUgMTEuMzUgMTAgMi43MSAxLjM1IDExLjM1IDAuNjUgMTAuNjUgMTAgMS4yOSAxOS4zNSAxMC42NVxcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiMTUgNCAxOCA0IDE4IDcgMTcgNyAxNyA1IDE1IDVcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjMgMTEgNCAxMSA0IDE4IDcgMTggNyAxMiAxMiAxMiAxMiAxOCAxNiAxOCAxNiAxMSAxNyAxMSAxNyAxOSAxMSAxOSAxMSAxMyA4IDEzIDggMTkgMyAxOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImltYWdlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIxNi4xXFxcIiBjeT1cXFwiNi4xXFxcIiByPVxcXCIxLjFcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIi41XFxcIiB5PVxcXCIyLjVcXFwiIHdpZHRoPVxcXCIxOVxcXCIgaGVpZ2h0PVxcXCIxNVxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wMVxcXCIgcG9pbnRzPVxcXCI0LDEzIDgsOSAxMywxNFxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wMVxcXCIgcG9pbnRzPVxcXCIxMSwxMiAxMi41LDEwLjUgMTYsMTRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJpbmZvXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTIuMTMsMTEuNTkgQzExLjk3LDEyLjg0IDEwLjM1LDE0LjEyIDkuMSwxNC4xNiBDNi4xNywxNC4yIDkuODksOS40NiA4Ljc0LDguMzcgQzkuMyw4LjE2IDEwLjYyLDcuODMgMTAuNjIsOC44MSBDMTAuNjIsOS42MyAxMC4xMiwxMC41NSA5Ljg4LDExLjMyIEM4LjY2LDE1LjE2IDEyLjEzLDExLjE1IDEyLjE0LDExLjE4IEMxMi4xNiwxMS4yMSAxMi4xNiwxMS4zNSAxMi4xMywxMS41OSBDMTIuMDgsMTEuOTUgMTIuMTYsMTEuMzUgMTIuMTMsMTEuNTkgTDEyLjEzLDExLjU5IFogTTExLjU2LDUuNjcgQzExLjU2LDYuNjcgOS4zNiw3LjE1IDkuMzYsNi4wMyBDOS4zNiw1IDExLjU2LDQuNTQgMTEuNTYsNS42NyBMMTEuNTYsNS42NyBaXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImluc3RhZ3JhbVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEzLjU1LDFINi40NkMzLjQ1LDEsMSwzLjQ0LDEsNi40NHY3LjEyYzAsMywyLjQ1LDUuNDQsNS40Niw1LjQ0aDcuMDhjMy4wMiwwLDUuNDYtMi40NCw1LjQ2LTUuNDRWNi40NCBDMTkuMDEsMy40NCwxNi41NiwxLDEzLjU1LDF6IE0xNy41LDE0YzAsMS45My0xLjU3LDMuNS0zLjUsMy41SDZjLTEuOTMsMC0zLjUtMS41Ny0zLjUtMy41VjZjMC0xLjkzLDEuNTctMy41LDMuNS0zLjVoOCBjMS45MywwLDMuNSwxLjU3LDMuNSwzLjVWMTR6XFxcIi8+PGNpcmNsZSBjeD1cXFwiMTQuODdcXFwiIGN5PVxcXCI1LjI2XFxcIiByPVxcXCIxLjA5XFxcIi8+PHBhdGggZD1cXFwiTTEwLjAzLDUuNDVjLTIuNTUsMC00LjYzLDIuMDYtNC42Myw0LjZjMCwyLjU1LDIuMDcsNC42MSw0LjYzLDQuNjFjMi41NiwwLDQuNjMtMi4wNjEsNC42My00LjYxIEMxNC42NSw3LjUxLDEyLjU4LDUuNDUsMTAuMDMsNS40NUwxMC4wMyw1LjQ1TDEwLjAzLDUuNDV6IE0xMC4wOCwxM2MtMS42NiwwLTMtMS4zNC0zLTIuOTljMC0xLjY1LDEuMzQtMi45OSwzLTIuOTlzMywxLjM0LDMsMi45OSBDMTMuMDgsMTEuNjYsMTEuNzQsMTMsMTAuMDgsMTNMMTAuMDgsMTNMMTAuMDgsMTN6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwiaXRhbGljXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTIuNjMsNS40OCBMMTAuMTUsMTQuNTIgQzEwLDE1LjA4IDEwLjM3LDE1LjI1IDExLjkyLDE1LjMgTDExLjcyLDE2IEw2LDE2IEw2LjIsMTUuMzEgQzcuNzgsMTUuMjYgOC4xOSwxNS4wOSA4LjM0LDE0LjUzIEwxMC44Miw1LjQ5IEMxMC45Nyw0LjkyIDEwLjYzLDQuNzYgOS4wOSw0LjcxIEw5LjI4LDQgTDE1LDQgTDE0LjgxLDQuNjkgQzEzLjIzLDQuNzUgMTIuNzgsNC45MSAxMi42Myw1LjQ4IEwxMi42Myw1LjQ4IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJqb29tbGFcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk03LjgsMTMuNGwxLjctMS43TDUuOSw4Yy0wLjYtMC41LTAuNi0xLjUsMC0yYzAuNi0wLjYsMS40LTAuNiwyLDBsMS43LTEuN2MtMS0xLTIuMy0xLjMtMy42LTFDNS44LDIuMiw0LjgsMS40LDMuNywxLjQgYy0xLjMsMC0yLjMsMS0yLjMsMi4zYzAsMS4xLDAuOCwyLDEuOCwyLjNjLTAuNCwxLjMtMC4xLDIuOCwxLDMuOEw3LjgsMTMuNEw3LjgsMTMuNHpcXFwiLz48cGF0aCBkPVxcXCJNMTAuMiw0LjNjMS0xLDIuNS0xLjQsMy44LTFjMC4yLTEuMSwxLjEtMiwyLjMtMmMxLjMsMCwyLjMsMSwyLjMsMi4zYzAsMS4yLTAuOSwyLjItMiwyLjNjMC40LDEuMywwLDIuOC0xLDMuOEwxMy45LDggYzAuNi0wLjUsMC42LTEuNSwwLTJjLTAuNS0wLjYtMS41LTAuNi0yLDBMOC4yLDkuN0w2LjUsOFxcXCIvPjxwYXRoIGQ9XFxcIk0xNC4xLDE2LjhjLTEuMywwLjQtMi44LDAuMS0zLjgtMWwxLjctMS43YzAuNiwwLjYsMS41LDAuNiwyLDBjMC41LTAuNiwwLjYtMS41LDAtMmwtMy43LTMuN0wxMiw2LjdsMy43LDMuNyBjMSwxLDEuMywyLjQsMSwzLjZjMS4xLDAuMiwyLDEuMSwyLDIuM2MwLDEuMy0xLDIuMy0yLjMsMi4zQzE1LjIsMTguNiwxNC4zLDE3LjgsMTQuMSwxNi44XFxcIi8+PHBhdGggZD1cXFwiTTEzLjIsMTIuMmwtMy43LDMuN2MtMSwxLTIuNCwxLjMtMy42LDFjLTAuMiwxLTEuMiwxLjgtMi4yLDEuOGMtMS4zLDAtMi4zLTEtMi4zLTIuM2MwLTEuMSwwLjgtMiwxLjgtMi4zIGMtMC4zLTEuMywwLTIuNywxLTMuN2wxLjcsMS43Yy0wLjYsMC42LTAuNiwxLjUsMCwyYzAuNiwwLjYsMS40LDAuNiwyLDBsMy43LTMuN1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImxhcHRvcFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeT1cXFwiMTZcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIyLjVcXFwiIHk9XFxcIjQuNVxcXCIgd2lkdGg9XFxcIjE1XFxcIiBoZWlnaHQ9XFxcIjEwXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibGlmZXNhdmVyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTAsMC41IEM0Ljc2LDAuNSAwLjUsNC43NiAwLjUsMTAgQzAuNSwxNS4yNCA0Ljc2LDE5LjUgMTAsMTkuNSBDMTUuMjQsMTkuNSAxOS41LDE1LjI0IDE5LjUsMTAgQzE5LjUsNC43NiAxNS4yNCwwLjUgMTAsMC41IEwxMCwwLjUgWiBNMTAsMS41IEMxMS40OSwxLjUgMTIuODksMS44OCAxNC4xMSwyLjU2IEwxMS44NSw0LjgyIEMxMS4yNyw0LjYxIDEwLjY1LDQuNSAxMCw0LjUgQzkuMjEsNC41IDguNDcsNC42NyA3Ljc5LDQuOTYgTDUuNTgsMi43NSBDNi44NywxLjk1IDguMzgsMS41IDEwLDEuNSBMMTAsMS41IFogTTQuOTYsNy44IEM0LjY3LDguNDggNC41LDkuMjEgNC41LDEwIEM0LjUsMTAuNjUgNC42MSwxMS4yNyA0LjgzLDExLjg1IEwyLjU2LDE0LjExIEMxLjg4LDEyLjg5IDEuNSwxMS40OSAxLjUsMTAgQzEuNSw4LjM4IDEuOTUsNi44NyAyLjc1LDUuNTggTDQuOTYsNy43OSBMNC45Niw3LjggTDQuOTYsNy44IFogTTEwLDE4LjUgQzguMjUsMTguNSA2LjYyLDE3Ljk3IDUuMjcsMTcuMDYgTDcuNDYsMTQuODcgQzguMjIsMTUuMjcgOS4wOCwxNS41IDEwLDE1LjUgQzEwLjc5LDE1LjUgMTEuNTMsMTUuMzMgMTIuMjEsMTUuMDQgTDE0LjQyLDE3LjI1IEMxMy4xMywxOC4wNSAxMS42MiwxOC41IDEwLDE4LjUgTDEwLDE4LjUgWiBNMTAsMTQuNSBDNy41MiwxNC41IDUuNSwxMi40OCA1LjUsMTAgQzUuNSw3LjUyIDcuNTIsNS41IDEwLDUuNSBDMTIuNDgsNS41IDE0LjUsNy41MiAxNC41LDEwIEMxNC41LDEyLjQ4IDEyLjQ4LDE0LjUgMTAsMTQuNSBMMTAsMTQuNSBaIE0xNS4wNCwxMi4yMSBDMTUuMzMsMTEuNTMgMTUuNSwxMC43OSAxNS41LDEwIEMxNS41LDkuMDggMTUuMjcsOC4yMiAxNC44Nyw3LjQ2IEwxNy4wNiw1LjI3IEMxNy45Nyw2LjYyIDE4LjUsOC4yNSAxOC41LDEwIEMxOC41LDExLjYyIDE4LjA1LDEzLjEzIDE3LjI1LDE0LjQyIEwxNS4wNCwxMi4yMSBMMTUuMDQsMTIuMjEgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImxpbmtcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMC42MjUsMTIuMzc1IEw3LjUyNSwxNS40NzUgQzYuODI1LDE2LjE3NSA1LjkyNSwxNi4xNzUgNS4yMjUsMTUuNDc1IEw0LjUyNSwxNC43NzUgQzMuODI1LDE0LjA3NCAzLjgyNSwxMy4xNzUgNC41MjUsMTIuNDc1IEw3LjYyNSw5LjM3NVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk05LjMyNSw3LjM3NSBMMTIuNDI1LDQuMjc1IEMxMy4xMjUsMy41NzUgMTQuMDI1LDMuNTc1IDE0LjcyNCw0LjI3NSBMMTUuNDI1LDQuOTc1IEMxNi4xMjUsNS42NzUgMTYuMTI1LDYuNTc1IDE1LjQyNSw3LjI3NSBMMTIuMzI1LDEwLjM3NVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk03LjkyNSwxMS44NzUgTDExLjkyNSw3Ljk3NVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcImxpbmtlZGluXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNS43NywxNy44OSBMNS43Nyw3LjE3IEwyLjIxLDcuMTcgTDIuMjEsMTcuODkgTDUuNzcsMTcuODkgTDUuNzcsMTcuODkgWiBNMy45OSw1LjcxIEM1LjIzLDUuNzEgNi4wMSw0Ljg5IDYuMDEsMy44NiBDNS45OSwyLjggNS4yNCwyIDQuMDIsMiBDMi44LDIgMiwyLjggMiwzLjg1IEMyLDQuODggMi43Nyw1LjcgMy45Nyw1LjcgTDMuOTksNS43IEwzLjk5LDUuNzEgTDMuOTksNS43MSBaXFxcIi8+PHBhdGggZD1cXFwiTTcuNzUsMTcuODkgTDExLjMxLDE3Ljg5IEwxMS4zMSwxMS45IEMxMS4zMSwxMS41OCAxMS4zMywxMS4yNiAxMS40MywxMS4wMyBDMTEuNjksMTAuMzkgMTIuMjcsOS43MyAxMy4yNiw5LjczIEMxNC41NSw5LjczIDE1LjA2LDEwLjcxIDE1LjA2LDEyLjE1IEwxNS4wNiwxNy44OSBMMTguNjIsMTcuODkgTDE4LjYyLDExLjc0IEMxOC42Miw4LjQ1IDE2Ljg2LDYuOTIgMTQuNTIsNi45MiBDMTIuNiw2LjkyIDExLjc1LDcuOTkgMTEuMjgsOC43MyBMMTEuMyw4LjczIEwxMS4zLDcuMTcgTDcuNzUsNy4xNyBDNy43OSw4LjE3IDcuNzUsMTcuODkgNy43NSwxNy44OSBMNy43NSwxNy44OSBMNy43NSwxNy44OSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibGlzdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiNlxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjEyXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCI2XFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMTJcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjZcXFwiIHk9XFxcIjE0XFxcIiB3aWR0aD1cXFwiMTJcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjRcXFwiIHdpZHRoPVxcXCIyXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiMTRcXFwiIHdpZHRoPVxcXCIyXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJsb2NhdGlvblwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMDFcXFwiIGQ9XFxcIk0xMCwwLjUgQzYuNDEsMC41IDMuNSwzLjM5IDMuNSw2Ljk4IEMzLjUsMTEuODMgMTAsMTkgMTAsMTkgQzEwLDE5IDE2LjUsMTEuODMgMTYuNSw2Ljk4IEMxNi41LDMuMzkgMTMuNTksMC41IDEwLDAuNSBMMTAsMC41IFpcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiNi44XFxcIiByPVxcXCIyLjNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJsb2NrXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGhlaWdodD1cXFwiMTBcXFwiIHdpZHRoPVxcXCIxM1xcXCIgeT1cXFwiOC41XFxcIiB4PVxcXCIzLjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk02LjUsOCBMNi41LDQuODggQzYuNSwzLjAxIDguMDcsMS41IDEwLDEuNSBDMTEuOTMsMS41IDEzLjUsMy4wMSAxMy41LDQuODggTDEzLjUsOFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1haWxcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMS40LDYuNSAxMCwxMSAxOC42LDYuNVxcXCIvPjxwYXRoIGQ9XFxcIk0gMSw0IDEsMTYgMTksMTYgMTksNCAxLDQgWiBNIDE4LDE1IDIsMTUgMiw1IDE4LDUgMTgsMTUgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1lbnVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjJcXFwiIHk9XFxcIjRcXFwiIHdpZHRoPVxcXCIxNlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjE2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIyXFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjE2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtaWNyb3Bob25lXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCIxMFxcXCIgeDI9XFxcIjEwXFxcIiB5MT1cXFwiMTYuNDRcXFwiIHkyPVxcXCIxOC41XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiN1xcXCIgeDI9XFxcIjEzXFxcIiB5MT1cXFwiMTguNVxcXCIgeTI9XFxcIjE4LjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTMuNSA0Ljg5djUuODdhMy41IDMuNSAwIDAgMS03IDBWNC44OWEzLjUgMy41IDAgMCAxIDcgMHpcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTUuNSAxMC4zNlYxMWE1LjUgNS41IDAgMCAxLTExIDB2LS42XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibWludXMtY2lyY2xlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI5LjVcXFwiIGN5PVxcXCI5LjVcXFwiIHI9XFxcIjlcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI1XFxcIiB5MT1cXFwiOS41XFxcIiB4Mj1cXFwiMTRcXFwiIHkyPVxcXCI5LjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtaW51c1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgaGVpZ2h0PVxcXCIxXFxcIiB3aWR0aD1cXFwiMThcXFwiIHk9XFxcIjlcXFwiIHg9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJtb3JlLXZlcnRpY2FsXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjNcXFwiIHI9XFxcIjJcXFwiLz48Y2lyY2xlIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCIyXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxN1xcXCIgcj1cXFwiMlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm1vcmVcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgY3g9XFxcIjNcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiMlxcXCIvPjxjaXJjbGUgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjJcXFwiLz48Y2lyY2xlIGN4PVxcXCIxN1xcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCIyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwibW92ZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCI0LDUgMSw1IDEsOSAyLDkgMiw2IDQsNlxcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiMSwxNiAyLDE2IDIsMTggNCwxOCA0LDE5IDEsMTlcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjE0LDE2IDE0LDE5IDExLDE5IDExLDE4IDEzLDE4IDEzLDE2XFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCI1LjVcXFwiIHk9XFxcIjEuNVxcXCIgd2lkdGg9XFxcIjEzXFxcIiBoZWlnaHQ9XFxcIjEzXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiMTFcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjNcXFwiLz48cmVjdCB4PVxcXCI2XFxcIiB5PVxcXCIxOFxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIm51dFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjIuNSw1LjcgMTAsMS4zIDE3LjUsNS43IDE3LjUsMTQuMyAxMCwxOC43IDIuNSwxNC4zXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjEwXFxcIiByPVxcXCIzLjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwYWdla2l0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjMsMSAxNywxIDE3LDE2IDEwLDE2IDEwLDEzIDE0LDEzIDE0LDQgNiw0IDYsMTYgMTAsMTYgMTAsMTkgMywxOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBhaW50LWJ1Y2tldFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEwLjIxLDEgTDAsMTEuMjEgTDguMSwxOS4zMSBMMTguMzEsOS4xIEwxMC4yMSwxIEwxMC4yMSwxIFogTTE2Ljg5LDkuMSBMMTUsMTEgTDEuNywxMSBMMTAuMjEsMi40MiBMMTYuODksOS4xIFpcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNNi40MiwyLjMzIEwxMS43LDcuNjFcXFwiLz48cGF0aCBkPVxcXCJNMTguNDksMTIgQzE4LjQ5LDEyIDIwLDE0LjA2IDIwLDE1LjM2IEMyMCwxNi4yOCAxOS4yNCwxNyAxOC40OSwxNyBMMTguNDksMTcgQzE3Ljc0LDE3IDE3LDE2LjI4IDE3LDE1LjM2IEMxNywxNC4wNiAxOC40OSwxMiAxOC40OSwxMiBMMTguNDksMTIgWlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBlbmNpbFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTcuMjUsNi4wMSBMNy4xMiwxNi4xIEwzLjgyLDE3LjIgTDUuMDIsMTMuOSBMMTUuMTIsMy44OCBDMTUuNzEsMy4yOSAxNi42NiwzLjI5IDE3LjI1LDMuODggQzE3LjgzLDQuNDcgMTcuODMsNS40MiAxNy4yNSw2LjAxIEwxNy4yNSw2LjAxIFpcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNS45OCw3LjI2OCBMMTMuODUxLDUuMTQ4XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGhvbmUtbGFuZHNjYXBlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xNyw1LjUgQzE3LjgsNS41IDE4LjUsNi4yIDE4LjUsNyBMMTguNSwxNCBDMTguNSwxNC44IDE3LjgsMTUuNSAxNywxNS41IEwzLDE1LjUgQzIuMiwxNS41IDEuNSwxNC44IDEuNSwxNCBMMS41LDcgQzEuNSw2LjIgMi4yLDUuNSAzLDUuNSBMMTcsNS41IEwxNyw1LjUgTDE3LDUuNSBaXFxcIi8+PGNpcmNsZSBjeD1cXFwiMy44XFxcIiBjeT1cXFwiMTAuNVxcXCIgcj1cXFwiLjhcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwaG9uZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMTUuNSwxNyBDMTUuNSwxNy44IDE0LjgsMTguNSAxNCwxOC41IEw3LDE4LjUgQzYuMiwxOC41IDUuNSwxNy44IDUuNSwxNyBMNS41LDMgQzUuNSwyLjIgNi4yLDEuNSA3LDEuNSBMMTQsMS41IEMxNC44LDEuNSAxNS41LDIuMiAxNS41LDMgTDE1LjUsMTcgTDE1LjUsMTcgTDE1LjUsMTcgWlxcXCIvPjxjaXJjbGUgY3g9XFxcIjEwLjVcXFwiIGN5PVxcXCIxNi41XFxcIiByPVxcXCIuOFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInBpbnRlcmVzdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTEwLjIxLDEgQzUuNSwxIDMsNC4xNiAzLDcuNjEgQzMsOS4yMSAzLjg1LDExLjIgNS4yMiwxMS44NCBDNS40MywxMS45NCA1LjU0LDExLjg5IDUuNTgsMTEuNjkgQzUuNjIsMTEuNTQgNS44LDEwLjggNS44OCwxMC40NSBDNS45MSwxMC4zNCA1Ljg5LDEwLjI0IDUuOCwxMC4xNCBDNS4zNiw5LjU5IDUsOC41OCA1LDcuNjUgQzUsNS4yNCA2LjgyLDIuOTEgOS45MywyLjkxIEMxMi42MSwyLjkxIDE0LjQ5LDQuNzQgMTQuNDksNy4zNSBDMTQuNDksMTAuMyAxMywxMi4zNSAxMS4wNiwxMi4zNSBDOS45OSwxMi4zNSA5LjE5LDExLjQ3IDkuNDQsMTAuMzggQzkuNzUsOS4wOCAxMC4zNSw3LjY4IDEwLjM1LDYuNzUgQzEwLjM1LDUuOTEgOS45LDUuMjEgOC45Nyw1LjIxIEM3Ljg3LDUuMjEgNi45OSw2LjM0IDYuOTksNy44NiBDNi45OSw4LjgzIDcuMzIsOS40OCA3LjMyLDkuNDggQzcuMzIsOS40OCA2LjI0LDE0LjA2IDYuMDQsMTQuOTEgQzUuNywxNi4zNSA2LjA4LDE4LjcgNi4xMiwxOC45IEM2LjE0LDE5LjAxIDYuMjYsMTkuMDUgNi4zMywxOC45NSBDNi40NCwxOC44MSA3Ljc0LDE2Ljg1IDguMTEsMTUuNDQgQzguMjQsMTQuOTMgOC43OSwxMi44NCA4Ljc5LDEyLjg0IEM5LjE1LDEzLjUyIDEwLjE5LDE0LjA5IDExLjI5LDE0LjA5IEMxNC41OCwxNC4wOSAxNi45NiwxMS4wNiAxNi45Niw3LjMgQzE2Ljk0LDMuNyAxNCwxIDEwLjIxLDFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwbGF5LWNpcmNsZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgcG9pbnRzPVxcXCI4LjUgNyAxMy41IDEwIDguNSAxM1xcXCIvPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwbGF5XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNi41LDUgMTQuNSwxMCA2LjUsMTVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJwbHVzLWNpcmNsZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiOS41XFxcIiBjeT1cXFwiOS41XFxcIiByPVxcXCI5XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiOS41XFxcIiB5MT1cXFwiNVxcXCIgeDI9XFxcIjkuNVxcXCIgeTI9XFxcIjE0XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4MT1cXFwiNVxcXCIgeTE9XFxcIjkuNVxcXCIgeDI9XFxcIjE0XFxcIiB5Mj1cXFwiOS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicGx1c1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiOVxcXCIgeT1cXFwiMVxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMTdcXFwiLz48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMTdcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInByaW50XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjQuNSAxMy41IDEuNSAxMy41IDEuNSA2LjUgMTguNSA2LjUgMTguNSAxMy41IDE1LjUgMTMuNVxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTUuNSA2LjUgMTUuNSAyLjUgNC41IDIuNSA0LjUgNi41XFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB3aWR0aD1cXFwiMTFcXFwiIGhlaWdodD1cXFwiNlxcXCIgeD1cXFwiNC41XFxcIiB5PVxcXCIxMS41XFxcIi8+PHJlY3Qgd2lkdGg9XFxcIjhcXFwiIGhlaWdodD1cXFwiMVxcXCIgeD1cXFwiNlxcXCIgeT1cXFwiMTNcXFwiLz48cmVjdCB3aWR0aD1cXFwiOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIiB4PVxcXCI2XFxcIiB5PVxcXCIxNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInB1bGxcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5Z29uIHBvaW50cz1cXFwiNi44NSw4IDkuNSwxMC42IDEyLjE1LDggMTIuODUsOC43IDkuNSwxMiA2LjE1LDguN1xcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjkuNVxcXCIgeTE9XFxcIjExXFxcIiB4Mj1cXFwiOS41XFxcIiB5Mj1cXFwiMlxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNiw1LjUgMy41LDUuNSAzLjUsMTguNSAxNS41LDE4LjUgMTUuNSw1LjUgMTMsNS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicHVzaFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMi4xNSw0IDkuNSwxLjQgNi44NSw0IDYuMTUsMy4zIDkuNSwwIDEyLjg1LDMuM1xcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgeDE9XFxcIjkuNVxcXCIgeTE9XFxcIjEwXFxcIiB4Mj1cXFwiOS41XFxcIiB5Mj1cXFwiMVxcXCIvPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiNiA1LjUgMy41IDUuNSAzLjUgMTguNSAxNS41IDE4LjUgMTUuNSA1LjUgMTMgNS41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicXVlc3Rpb25cIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjlcXFwiLz48Y2lyY2xlIGN4PVxcXCIxMC40NFxcXCIgY3k9XFxcIjE0LjQyXFxcIiByPVxcXCIxLjA1XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgZD1cXFwiTTguMTcsNy43OSBDOC4xNyw0Ljc1IDEyLjcyLDQuNzMgMTIuNzIsNy43MiBDMTIuNzIsOC42NyAxMS44MSw5LjE1IDExLjIzLDkuNzUgQzEwLjc1LDEwLjI0IDEwLjUxLDEwLjczIDEwLjQ1LDExLjQgQzEwLjQ0LDExLjUzIDEwLjQzLDExLjY0IDEwLjQzLDExLjc1XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicXVvdGUtcmlnaHRcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNy4yNyw3Ljc5IEMxNy4yNyw5LjQ1IDE2Ljk3LDEwLjQzIDE1Ljk5LDEyLjAyIEMxNC45OCwxMy42NCAxMywxNS4yMyAxMS41NiwxNS45NyBMMTEuMSwxNS4wOCBDMTIuMzQsMTQuMiAxMy4xNCwxMy41MSAxNC4wMiwxMS44MiBDMTQuMjcsMTEuMzQgMTQuNDEsMTAuOTIgMTQuNDksMTAuNTQgQzE0LjMsMTAuNTggMTQuMDksMTAuNiAxMy44OCwxMC42IEMxMi4wNiwxMC42IDEwLjU5LDkuMTIgMTAuNTksNy4zIEMxMC41OSw1LjQ4IDEyLjA2LDQgMTMuODgsNCBDMTUuMzksNCAxNi42Nyw1LjAyIDE3LjA1LDYuNDIgQzE3LjE5LDYuODIgMTcuMjcsNy4yNyAxNy4yNyw3Ljc5IEwxNy4yNyw3Ljc5IFpcXFwiLz48cGF0aCBkPVxcXCJNOC42OCw3Ljc5IEM4LjY4LDkuNDUgOC4zOCwxMC40MyA3LjQsMTIuMDIgQzYuMzksMTMuNjQgNC40MSwxNS4yMyAyLjk3LDE1Ljk3IEwyLjUxLDE1LjA4IEMzLjc1LDE0LjIgNC41NSwxMy41MSA1LjQzLDExLjgyIEM1LjY4LDExLjM0IDUuODIsMTAuOTIgNS45LDEwLjU0IEM1LjcxLDEwLjU4IDUuNSwxMC42IDUuMjksMTAuNiBDMy40NywxMC42IDIsOS4xMiAyLDcuMyBDMiw1LjQ4IDMuNDcsNCA1LjI5LDQgQzYuOCw0IDguMDgsNS4wMiA4LjQ2LDYuNDIgQzguNiw2LjgyIDguNjgsNy4yNyA4LjY4LDcuNzkgTDguNjgsNy43OSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicmVjZWl2ZXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjAxXFxcIiBkPVxcXCJNNi4xODksMTMuNjExQzguMTM0LDE1LjUyNSAxMS4wOTcsMTguMjM5IDEzLjg2NywxOC4yNTdDMTYuNDcsMTguMjc1IDE4LjIsMTYuMjQxIDE4LjIsMTYuMjQxTDE0LjUwOSwxMi41NTFMMTEuNTM5LDEzLjYzOUw2LjE4OSw4LjI5TDcuMzEzLDUuMzU1TDMuNzYsMS44QzMuNzYsMS44IDEuNzMyLDMuNTM3IDEuNyw2LjA5MkMxLjY2Nyw4LjgwOSA0LjM0NywxMS43MzggNi4xODksMTMuNjExXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicmVkZGl0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTkgOS4wNWEyLjU2IDIuNTYgMCAwIDAtMi41Ni0yLjU2IDIuNTkgMi41OSAwIDAgMC0xLjg4LjgyIDEwLjYzIDEwLjYzIDAgMCAwLTQuMTQtMXYtLjA4Yy41OC0xLjYyIDEuNTgtMy44OSAyLjctNC4xLjM4LS4wOC43Ny4xMiAxLjE5LjU3YTEuMTUgMS4xNSAwIDAgMC0uMDYuMzcgMS40OCAxLjQ4IDAgMSAwIDEuNTEtMS40NSAxLjQzIDEuNDMgMCAwIDAtLjc2LjE5QTIuMjkgMi4yOSAwIDAgMCAxMi45MSAxYy0yLjExLjQzLTMuMzkgNC4zOC0zLjYzIDUuMTkgMCAwIDAgLjExLS4wNi4xMWExMC42NSAxMC42NSAwIDAgMC0zLjc1IDFBMi41NiAyLjU2IDAgMCAwIDEgOS4wNWEyLjQyIDIuNDIgMCAwIDAgLjcyIDEuNzZBNS4xOCA1LjE4IDAgMCAwIDEuMjQgMTNjMCAzLjY2IDMuOTIgNi42NCA4LjczIDYuNjRzOC43NC0zIDguNzQtNi42NGE1LjIzIDUuMjMgMCAwIDAtLjQ2LTIuMTNBMi41OCAyLjU4IDAgMCAwIDE5IDkuMDV6bS0xNi44OCAwYTEuNDQgMS40NCAwIDAgMSAyLjI3LTEuMTkgNy42OCA3LjY4IDAgMCAwLTIuMDcgMS45MSAxLjMzIDEuMzMgMCAwIDEtLjItLjcyek0xMCAxOC40Yy00LjE3IDAtNy41NS0yLjQtNy41NS01LjRTNS44MyA3LjUzIDEwIDcuNTMgMTcuNSAxMCAxNy41IDEzcy0zLjM4IDUuNC03LjUgNS40em03LjY5LTguNjFhNy42MiA3LjYyIDAgMCAwLTIuMDktMS45MSAxLjQxIDEuNDEgMCAwIDEgLjg0LS4yOCAxLjQ3IDEuNDcgMCAwIDEgMS40NCAxLjQ1IDEuMzQgMS4zNCAwIDAgMS0uMjEuNzJ6XFxcIi8+PHBhdGggZD1cXFwiTTYuNjkgMTIuNThhMS4zOSAxLjM5IDAgMSAxIDEuMzktMS4zOSAxLjM4IDEuMzggMCAwIDEtMS4zOCAxLjM5elxcXCIvPjxwYXRoIGQ9XFxcIk0xNC4yNiAxMS4yYTEuMzkgMS4zOSAwIDEgMS0xLjM5LTEuMzkgMS4zOSAxLjM5IDAgMCAxIDEuMzkgMS4zOXpcXFwiLz48cGF0aCBkPVxcXCJNMTMuMDkgMTQuODhhLjU0LjU0IDAgMCAxLS4wOS43NyA1LjMgNS4zIDAgMCAxLTMuMjYgMS4xOSA1LjYxIDUuNjEgMCAwIDEtMy40LTEuMjIuNTUuNTUgMCAxIDEgLjczLS44MyA0LjA5IDQuMDkgMCAwIDAgNS4yNSAwIC41Ni41NiAwIDAgMSAuNzcuMDl6XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicmVmcmVzaFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTE3LjA4LDExLjE1IEMxNy4wOSwxMS4zMSAxNy4xLDExLjQ3IDE3LjEsMTEuNjQgQzE3LjEsMTUuNTMgMTMuOTQsMTguNjkgMTAuMDUsMTguNjkgQzYuMTYsMTguNjggMywxNS41MyAzLDExLjYzIEMzLDcuNzQgNi4xNiw0LjU4IDEwLjA1LDQuNTggQzEwLjksNC41OCAxMS43MSw0LjczIDEyLjQ2LDVcXFwiLz48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjkuOSAyIDEyLjc5IDQuODkgOS43OSA3LjlcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJyZXBseVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE3LjcsMTMuMTEgQzE2LjEyLDEwLjAyIDEzLjg0LDcuODUgMTEuMDIsNi42MSBDMTAuNTcsNi40MSA5Ljc1LDYuMTMgOSw1LjkxIEw5LDIgTDEsOSBMOSwxNiBMOSwxMi4xMyBDMTAuNzgsMTIuNDcgMTIuNSwxMy4xOSAxNC4wOSwxNC4yNSBDMTcuMTMsMTYuMjggMTguNTYsMTguNTQgMTguNTYsMTguNTQgQzE4LjU2LDE4LjU0IDE4LjgxLDE1LjI4IDE3LjcsMTMuMTEgTDE3LjcsMTMuMTEgWiBNMTQuODIsMTMuNTMgQzEzLjE3LDEyLjQgMTEuMDEsMTEuNCA4LDEwLjkyIEw4LDEzLjYzIEwyLjU1LDkgTDgsNC4yNSBMOCw2LjggQzguMyw2Ljg2IDkuMTYsNy4wMiAxMC4zNyw3LjQ5IEMxMy4zLDguNjUgMTUuNTQsMTAuOTYgMTYuNjUsMTMuMDggQzE2Ljk3LDEzLjcgMTcuNDgsMTQuODYgMTcuNjgsMTYgQzE2Ljg3LDE1LjA1IDE1LjczLDE0LjE1IDE0LjgyLDEzLjUzIEwxNC44MiwxMy41MyBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwicnNzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIzLjEyXFxcIiBjeT1cXFwiMTYuOFxcXCIgcj1cXFwiMS44NVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xLjUsOC4yIEMxLjc4LDguMTggMi4wNiw4LjE2IDIuMzUsOC4xNiBDNy41Nyw4LjE2IDExLjgxLDEyLjM3IDExLjgxLDE3LjU3IEMxMS44MSwxNy44OSAxMS43OSwxOC4xOSAxMS43NiwxOC41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEuNSwyLjUyIEMxLjc4LDIuNTEgMi4wNiwyLjUgMi4zNSwyLjUgQzEwLjcyLDIuNSAxNy41LDkuMjQgMTcuNSwxNy41NyBDMTcuNSwxNy44OSAxNy40OSwxOC4xOSAxNy40NywxOC41XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic2VhcmNoXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI5XFxcIiBjeT1cXFwiOVxcXCIgcj1cXFwiN1xcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xNCwxNCBMMTgsMTggTDE0LDE0IFpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzZXJ2ZXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjNcXFwiIHdpZHRoPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB4PVxcXCI1XFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeD1cXFwiN1xcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjE2XFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMTZcXFwiIHk9XFxcIjEwXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCI5LjlcXFwiIGN5PVxcXCIxNy40XFxcIiByPVxcXCIxLjRcXFwiLz48cmVjdCB4PVxcXCIzXFxcIiB5PVxcXCIxMFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjVcXFwiIHk9XFxcIjEwXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCIyXFxcIi8+PHJlY3QgeD1cXFwiOS41XFxcIiB5PVxcXCIxNFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjE3XFxcIiB3aWR0aD1cXFwiNlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMTFcXFwiIHk9XFxcIjE3XFxcIiB3aWR0aD1cXFwiNlxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxLjVcXFwiIHk9XFxcIjEuNVxcXCIgd2lkdGg9XFxcIjE3XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjEuNVxcXCIgeT1cXFwiOC41XFxcIiB3aWR0aD1cXFwiMTdcXFwiIGhlaWdodD1cXFwiNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInNldHRpbmdzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48ZWxsaXBzZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGN4PVxcXCI2LjExXFxcIiBjeT1cXFwiMy41NVxcXCIgcng9XFxcIjIuMTFcXFwiIHJ5PVxcXCIyLjE1XFxcIi8+PGVsbGlwc2UgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiNi4xMVxcXCIgY3k9XFxcIjE1LjU1XFxcIiByeD1cXFwiMi4xMVxcXCIgcnk9XFxcIjIuMTVcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjEzLjE1XFxcIiBjeT1cXFwiOS41NVxcXCIgcj1cXFwiMi4xNVxcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjNcXFwiIHdpZHRoPVxcXCIzXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxMFxcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjhcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjlcXFwiIHdpZHRoPVxcXCI4XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCB4PVxcXCIxNVxcXCIgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjE1XFxcIiB3aWR0aD1cXFwiM1xcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMTBcXFwiIHk9XFxcIjE1XFxcIiB3aWR0aD1cXFwiOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwic2hyaW5rXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjExIDQgMTIgNCAxMiA4IDE2IDggMTYgOSAxMSA5XFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCI0IDExIDkgMTEgOSAxNiA4IDE2IDggMTIgNCAxMlxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xMiw4IEwxOCwyXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTIsMTggTDgsMTJcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzaWduLWluXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjcgMiAxNyAyIDE3IDE3IDcgMTcgNyAxNiAxNiAxNiAxNiAzIDcgM1xcXCIvPjxwb2x5Z29uIHBvaW50cz1cXFwiOS4xIDEzLjQgOC41IDEyLjggMTEuMjggMTAgNCAxMCA0IDkgMTEuMjggOSA4LjUgNi4yIDkuMSA1LjYyIDEzIDkuNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInNpZ24tb3V0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjEzLjEgMTMuNCAxMi41IDEyLjggMTUuMjggMTAgOCAxMCA4IDkgMTUuMjggOSAxMi41IDYuMiAxMy4xIDUuNjIgMTcgOS41XFxcIi8+PHBvbHlnb24gcG9pbnRzPVxcXCIxMyAyIDMgMiAzIDE3IDEzIDE3IDEzIDE2IDQgMTYgNCAzIDEzIDNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzb2NpYWxcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHgxPVxcXCIxMy40XFxcIiB5MT1cXFwiMTRcXFwiIHgyPVxcXCI2LjNcXFwiIHkyPVxcXCIxMC43XFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjEzLjVcXFwiIHkxPVxcXCI1LjVcXFwiIHgyPVxcXCI2LjVcXFwiIHkyPVxcXCI4LjhcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxNS41XFxcIiBjeT1cXFwiNC42XFxcIiByPVxcXCIyLjNcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCIxNS41XFxcIiBjeT1cXFwiMTQuOFxcXCIgcj1cXFwiMi4zXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiNC41XFxcIiBjeT1cXFwiOS44XFxcIiByPVxcXCIyLjNcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzb3VuZGNsb3VkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTcuMiw5LjRjLTAuNCwwLTAuOCwwLjEtMS4xMDEsMC4yYy0wLjE5OS0yLjUtMi4zOTktNC41LTUtNC41Yy0wLjYsMC0xLjIsMC4xLTEuNywwLjNDOS4yLDUuNSw5LjEsNS42LDkuMSw1LjZWMTVoOCBjMS42MDEsMCwyLjgwMS0xLjIsMi44MDEtMi44QzIwLDEwLjcsMTguNyw5LjQsMTcuMiw5LjRMMTcuMiw5LjR6XFxcIi8+PHJlY3QgeD1cXFwiNlxcXCIgeT1cXFwiNi41XFxcIiB3aWR0aD1cXFwiMS41XFxcIiBoZWlnaHQ9XFxcIjguNVxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjhcXFwiIHdpZHRoPVxcXCIxLjVcXFwiIGhlaWdodD1cXFwiN1xcXCIvPjxyZWN0IHk9XFxcIjEwXFxcIiB3aWR0aD1cXFwiMS41XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzdGFyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4wMVxcXCIgcG9pbnRzPVxcXCIxMCAyIDEyLjYzIDcuMjcgMTguNSA4LjEyIDE0LjI1IDEyLjIyIDE1LjI1IDE4IDEwIDE1LjI3IDQuNzUgMTggNS43NSAxMi4yMiAxLjUgOC4xMiA3LjM3IDcuMjdcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJzdHJpa2V0aHJvdWdoXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNNiwxMy4wMiBMNi42NSwxMy4wMiBDNy42NCwxNS4xNiA4Ljg2LDE2LjEyIDEwLjQxLDE2LjEyIEMxMi4yMiwxNi4xMiAxMi45MiwxNC45MyAxMi45MiwxMy44OSBDMTIuOTIsMTIuNTUgMTEuOTksMTIuMDMgOS43NCwxMS4yMyBDOC4wNSwxMC42NCA2LjIzLDEwLjExIDYuMjMsNy44MyBDNi4yMyw1LjUgOC4wOSw0LjA5IDEwLjQsNC4wOSBDMTEuNDQsNC4wOSAxMi4xMyw0LjMxIDEyLjcyLDQuNTQgTDEzLjMzLDQgTDEzLjgxLDQgTDEzLjgxLDcuNTkgTDEzLjE2LDcuNTkgQzEyLjU1LDUuODggMTEuNTIsNC44OSAxMC4wNyw0Ljg5IEM4Ljg0LDQuODkgNy44OSw1LjY5IDcuODksNy4wMyBDNy44OSw4LjI5IDguODksOC43OCAxMC44OCw5LjQ1IEMxMi41NywxMC4wMyAxNC4zOCwxMC42IDE0LjM4LDEyLjkxIEMxNC4zOCwxNC43NSAxMy4yNywxNi45MyAxMC4xOCwxNi45MyBDOS4xOCwxNi45MyA4LjE3LDE2LjY5IDcuNDYsMTYuMzkgTDYuNTIsMTcgTDYsMTcgTDYsMTMuMDIgTDYsMTMuMDIgWlxcXCIvPjxyZWN0IHg9XFxcIjNcXFwiIHk9XFxcIjEwXFxcIiB3aWR0aD1cXFwiMTVcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRhYmxlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCB4PVxcXCIxXFxcIiB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMThcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjxyZWN0IHg9XFxcIjFcXFwiIHk9XFxcIjdcXFwiIHdpZHRoPVxcXCIxOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiMTFcXFwiIHdpZHRoPVxcXCIxOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PHJlY3QgeD1cXFwiMVxcXCIgeT1cXFwiMTVcXFwiIHdpZHRoPVxcXCIxOFxcXCIgaGVpZ2h0PVxcXCIxXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidGFibGV0LWxhbmRzY2FwZVwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBkPVxcXCJNMS41LDUgQzEuNSw0LjIgMi4yLDMuNSAzLDMuNSBMMTcsMy41IEMxNy44LDMuNSAxOC41LDQuMiAxOC41LDUgTDE4LjUsMTYgQzE4LjUsMTYuOCAxNy44LDE3LjUgMTcsMTcuNSBMMywxNy41IEMyLjIsMTcuNSAxLjUsMTYuOCAxLjUsMTYgTDEuNSw1IEwxLjUsNSBMMS41LDUgWlxcXCIvPjxjaXJjbGUgY3g9XFxcIjMuN1xcXCIgY3k9XFxcIjEwLjVcXFwiIHI9XFxcIi44XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidGFibGV0XCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk01LDE4LjUgQzQuMiwxOC41IDMuNSwxNy44IDMuNSwxNyBMMy41LDMgQzMuNSwyLjIgNC4yLDEuNSA1LDEuNSBMMTYsMS41IEMxNi44LDEuNSAxNy41LDIuMiAxNy41LDMgTDE3LjUsMTcgQzE3LjUsMTcuOCAxNi44LDE4LjUgMTYsMTguNSBMNSwxOC41IEw1LDE4LjUgTDUsMTguNSBaXFxcIi8+PGNpcmNsZSBjeD1cXFwiMTAuNVxcXCIgY3k9XFxcIjE2LjNcXFwiIHI9XFxcIi44XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidGFnXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTcuNSwzLjcxIEwxNy41LDcuNzIgQzE3LjUsNy45NiAxNy40LDguMiAxNy4yMSw4LjM5IEw4LjM5LDE3LjIgQzcuOTksMTcuNiA3LjMzLDE3LjYgNi45MywxNy4yIEwyLjgsMTMuMDcgQzIuNCwxMi42NyAyLjQsMTIuMDEgMi44LDExLjYxIEwxMS42MSwyLjggQzExLjgxLDIuNiAxMi4wOCwyLjUgMTIuMzQsMi41IEwxNi4xOSwyLjUgQzE2LjUyLDIuNSAxNi44NiwyLjYzIDE3LjExLDIuODggQzE3LjM1LDMuMTEgMTcuNDgsMy40IDE3LjUsMy43MSBMMTcuNSwzLjcxIFpcXFwiLz48Y2lyY2xlIGN4PVxcXCIxNFxcXCIgY3k9XFxcIjZcXFwiIHI9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0aHVtYm5haWxzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiMy41XFxcIiB3aWR0aD1cXFwiNVxcXCIgaGVpZ2h0PVxcXCI1XFxcIi8+PHJlY3QgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiB4PVxcXCIxMS41XFxcIiB5PVxcXCIzLjVcXFwiIHdpZHRoPVxcXCI1XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjExLjVcXFwiIHk9XFxcIjExLjVcXFwiIHdpZHRoPVxcXCI1XFxcIiBoZWlnaHQ9XFxcIjVcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiMTEuNVxcXCIgd2lkdGg9XFxcIjVcXFwiIGhlaWdodD1cXFwiNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRpa3Rva1wiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE3LjI0LDZWOC44MmE2Ljc5LDYuNzksMCwwLDEtNC0xLjI4djUuODFBNS4yNiw1LjI2LDAsMSwxLDgsOC4xYTQuMzYsNC4zNiwwLDAsMSwuNzIuMDV2Mi45QTIuNTcsMi41NywwLDAsMCw3LjY0LDExYTIuNCwyLjQsMCwxLDAsMi43NywyLjM4VjJoMi44NmE0LDQsMCwwLDAsMS44NCwzLjM4QTQsNCwwLDAsMCwxNy4yNCw2WlxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRyYXNoXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjYuNSAzIDYuNSAxLjUgMTMuNSAxLjUgMTMuNSAzXFxcIi8+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgcG9pbnRzPVxcXCI0LjUgNCA0LjUgMTguNSAxNS41IDE4LjUgMTUuNSA0XFxcIi8+PHJlY3QgeD1cXFwiOFxcXCIgeT1cXFwiN1xcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiOVxcXCIvPjxyZWN0IHg9XFxcIjExXFxcIiB5PVxcXCI3XFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI5XFxcIi8+PHJlY3QgeD1cXFwiMlxcXCIgeT1cXFwiM1xcXCIgd2lkdGg9XFxcIjE2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0cmlhbmdsZS1kb3duXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjUgNyAxNSA3IDEwIDEyXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidHJpYW5nbGUtbGVmdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxMiA1IDcgMTAgMTIgMTVcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0cmlhbmdsZS1yaWdodFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCI4IDUgMTMgMTAgOCAxNVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRyaWFuZ2xlLXVwXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBwb2ludHM9XFxcIjUgMTMgMTAgOCAxNSAxM1xcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInRyaXBhZHZpc29yXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTkuMDIxLDcuODY2QzE5LjI1Niw2Ljg2MiwyMCw1Ljg1NCwyMCw1Ljg1NGgtMy4zNDZDMTQuNzgxLDQuNjQxLDEyLjUwNCw0LDkuOTgsNEM3LjM2Myw0LDQuOTk5LDQuNjUxLDMuMTM1LDUuODc2SDBcXHRjMCwwLDAuNzM4LDAuOTg3LDAuOTc2LDEuOTg4Yy0wLjYxMSwwLjgzNy0wLjk3MywxLjg1Mi0wLjk3MywyLjk2NGMwLDIuNzYzLDIuMjQ5LDUuMDA5LDUuMDExLDUuMDA5XFx0YzEuNTc2LDAsMi45NzYtMC43MzcsMy45MDEtMS44NzlsMS4wNjMsMS41OTlsMS4wNzUtMS42MTVjMC40NzUsMC42MTEsMS4xLDEuMTExLDEuODM4LDEuNDUxYzEuMjEzLDAuNTQ3LDIuNTc0LDAuNjEyLDMuODI1LDAuMTVcXHRjMi41ODktMC45NjMsMy45MTMtMy44NTIsMi45NjQtNi40MzljLTAuMTc1LTAuNDYzLTAuNC0wLjg3Ni0wLjY3NS0xLjIzOEgxOS4wMjF6IE0xNi4zOCwxNC41OTRcXHRjLTEuMDAyLDAuMzcxLTIuMDg4LDAuMzI4LTMuMDYtMC4xMTljLTAuNjg4LTAuMzE3LTEuMjUyLTAuODE3LTEuNjU3LTEuNDM4Yy0wLjE2NC0wLjI1LTAuMzEzLTAuNTItMC40MTctMC44MTFcXHRjLTAuMTI0LTAuMzI4LTAuMTg2LTAuNjY4LTAuMjE3LTEuMDE0Yy0wLjA2My0wLjY4OSwwLjAzNy0xLjM5NiwwLjMzOS0yLjA0M2MwLjQ0OC0wLjk3MSwxLjI1MS0xLjcxLDIuMjUtMi4wNzlcXHRjMi4wNzUtMC43NjUsNC4zNzUsMC4zLDUuMTQsMi4zNjZjMC43NjIsMi4wNjYtMC4zMDEsNC4zNy0yLjM2Myw1LjEzNEwxNi4zOCwxNC41OTRMMTYuMzgsMTQuNTk0eiBNOC4zMjIsMTMuMDY2XFx0Yy0wLjcyLDEuMDU5LTEuOTM1LDEuNzYtMy4zMDksMS43NmMtMi4yMDcsMC00LjAwMS0xLjc5Ny00LjAwMS0zLjk5NmMwLTIuMjAzLDEuNzk1LTQuMDAyLDQuMDAxLTQuMDAyXFx0YzIuMjA0LDAsMy45OTksMS44LDMuOTk5LDQuMDAyYzAsMC4xMzctMC4wMjQsMC4yNjEtMC4wNCwwLjM5NmMtMC4wNjcsMC42NzgtMC4yODQsMS4zMTMtMC42NDgsMS44NTN2LTAuMDEzSDguMzIyeiBNMi40NzIsMTAuNzc1XFx0YzAsMS4zNjcsMS4xMTIsMi40NzksMi40NzYsMi40NzljMS4zNjMsMCwyLjQ3Mi0xLjExLDIuNDcyLTIuNDc5YzAtMS4zNTktMS4xMS0yLjQ2OC0yLjQ3Mi0yLjQ2OFxcdEMzLjU4NCw4LjMwNiwyLjQ3Myw5LjQxNiwyLjQ3MiwxMC43NzVMMi40NzIsMTAuNzc1eiBNMTIuNTE0LDEwLjc3NWMwLDEuMzY3LDEuMTA0LDIuNDc5LDIuNDcxLDIuNDc5XFx0YzEuMzYzLDAsMi40NzQtMS4xMDgsMi40NzQtMi40NzljMC0xLjM1OS0xLjExLTIuNDY4LTIuNDc0LTIuNDY4Yy0xLjM2NCwwLTIuNDc3LDEuMTA5LTIuNDc3LDIuNDY4SDEyLjUxNHogTTMuMzI0LDEwLjc3NVxcdGMwLTAuODkzLDAuNzI2LTEuNjE4LDEuNjE0LTEuNjE4YzAuODg5LDAsMS42MjUsMC43MjcsMS42MjUsMS42MThjMCwwLjg5OC0wLjcyNSwxLjYyNy0xLjYyNSwxLjYyN1xcdGMtMC45MDEsMC0xLjYyNS0wLjcyOS0xLjYyNS0xLjYyN0gzLjMyNHogTTEzLjM1NCwxMC43NzVjMC0wLjg5MywwLjcyNi0xLjYxOCwxLjYyNy0xLjYxOGMwLjg4NiwwLDEuNjEsMC43MjcsMS42MSwxLjYxOFxcdGMwLDAuODk4LTAuNzI2LDEuNjI3LTEuNjI2LDEuNjI3cy0xLjYyNS0wLjcyOS0xLjYyNS0xLjYyN0gxMy4zNTR6IE05Ljk3Nyw0Ljg3NWMxLjc5OCwwLDMuNDI1LDAuMzI0LDQuODQ5LDAuOTY4XFx0Yy0wLjUzNSwwLjAxNS0xLjA2MSwwLjEwOC0xLjU4NiwwLjNjLTEuMjY0LDAuNDYzLTIuMjY0LDEuMzg4LTIuODE1LDIuNjA0Yy0wLjI2MiwwLjU1MS0wLjM5OCwxLjEzMy0wLjQ0OCwxLjcyXFx0QzkuNzksNy45MDUsNy42NzcsNS44NzMsNS4wNzYsNS44MkM2LjUwMSw1LjIwOCw4LjE1Myw0Ljg3NSw5Ljk0LDQuODc1SDkuOTc3elxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInR1bWJsclwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTYuODg1LDguNTk4YzAsMCwwLDMuMzkzLDAsNC45OTZjMCwwLjI4MiwwLDAuNjYsMC4wOTQsMC45NDJjMC4zNzcsMS41MDksMS4xMzEsMi41NDUsMi41NDUsMy4xMSBjMS4zMTksMC40NzIsMi4zNTYsMC40NzIsMy42NzYsMGMwLjU2NS0wLjE4OCwxLjEzMi0wLjY1OSwxLjEzMi0wLjY1OWwtMC44NDktMi4yNjNjMCwwLTEuMDM2LDAuMzc4LTEuNjAzLDAuMjgzIGMtMC41NjUtMC4wOTQtMS4yMjYtMC42Ni0xLjIyNi0xLjUwOGMwLTEuNjAzLDAtNC45MDIsMC00LjkwMmgyLjgyOFY1Ljc3MWgtMi44MjhWMkg4LjIwNWMwLDAtMC4wOTQsMC42Ni0wLjE4OCwwLjk0MiBDNy44MjgsMy43OTEsNy4yNjIsNC43MzMsNi42MDMsNS4zOTRDNS44NDgsNi4xNDcsNSw2LjQzLDUsNi40M3YyLjE2OEg2Ljg4NXpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ0dlwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiN1xcXCIgeT1cXFwiMTZcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIi41XFxcIiB5PVxcXCIzLjVcXFwiIHdpZHRoPVxcXCIxOVxcXCIgaGVpZ2h0PVxcXCIxMVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInR3aXRjaFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTUuMjMsMSwyLDQuMjNWMTUuODVINS44OHYzLjIzTDkuMSwxNS44NWgyLjU5TDE3LjUsMTBWMVptMTEsOC40TDEzLjYyLDEySDExTDguNzgsMTQuMjRWMTJINS44OFYyLjI5SDE2LjIxWlxcXCIvPjxyZWN0IHg9XFxcIjEyLjk4XFxcIiB5PVxcXCI0LjU1XFxcIiB3aWR0aD1cXFwiMS4yOVxcXCIgaGVpZ2h0PVxcXCIzLjg4XFxcIi8+PHJlY3QgeD1cXFwiOS40M1xcXCIgeT1cXFwiNC41NVxcXCIgd2lkdGg9XFxcIjEuMjlcXFwiIGhlaWdodD1cXFwiMy44OFxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInR3aXR0ZXJcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xOSw0Ljc0IEMxOC4zMzksNS4wMjkgMTcuNjI2LDUuMjI5IDE2Ljg4MSw1LjMyIEMxNy42NDQsNC44NiAxOC4yMjcsNC4xMzkgMTguNTAzLDMuMjggQzE3Ljc5LDMuNyAxNy4wMDEsNC4wMDkgMTYuMTU5LDQuMTcgQzE1LjQ4NSwzLjQ1IDE0LjUyNiwzIDEzLjQ2NCwzIEMxMS40MjMsMyA5Ljc3MSw0LjY2IDkuNzcxLDYuNyBDOS43NzEsNi45OSA5LjgwNCw3LjI2OSA5Ljg2OCw3LjUzOSBDNi43OTUsNy4zOCA0LjA3Niw1LjkxOSAyLjI1NCwzLjY3OSBDMS45MzYsNC4yMTkgMS43NTQsNC44NiAxLjc1NCw1LjUzOSBDMS43NTQsNi44MiAyLjQwNSw3Ljk1IDMuMzk3LDguNjEgQzIuNzksOC41ODkgMi4yMiw4LjQyOSAxLjcyMyw4LjE0OSBMMS43MjMsOC4xODkgQzEuNzIzLDkuOTc4IDIuOTk3LDExLjQ3OCA0LjY4NiwxMS44MiBDNC4zNzYsMTEuODk5IDQuMDQ5LDExLjkzOSAzLjcxMywxMS45MzkgQzMuNDc1LDExLjkzOSAzLjI0NSwxMS45MTkgMy4wMTgsMTEuODggQzMuNDksMTMuMzQ5IDQuODUyLDE0LjQxOSA2LjQ2OSwxNC40NDkgQzUuMjA1LDE1LjQyOSAzLjYxMiwxNi4wMTkgMS44ODIsMTYuMDE5IEMxLjU4MywxNi4wMTkgMS4yOSwxNi4wMDkgMSwxNS45NjkgQzIuNjM1LDE3LjAxOSA0LjU3NiwxNy42MjkgNi42NjIsMTcuNjI5IEMxMy40NTQsMTcuNjI5IDE3LjE3LDEyIDE3LjE3LDcuMTI5IEMxNy4xNyw2Ljk2OSAxNy4xNjYsNi44MDkgMTcuMTU3LDYuNjQ5IEMxNy44NzksNi4xMjkgMTguNTA0LDUuNDc4IDE5LDQuNzRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ1aWtpdFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIxNC40LDMuMSAxMS4zLDUuMSAxNSw3LjMgMTUsMTIuOSAxMCwxNS43IDUsMTIuOSA1LDguNSAyLDYuOCAyLDE0LjggOS45LDE5LjUgMTgsMTQuOCAxOCw1LjNcXFwiLz48cG9seWdvbiBwb2ludHM9XFxcIjkuOCw0LjIgNi43LDIuNCA5LjgsMC40IDEyLjksMi4zXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidW5sb2NrXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cmVjdCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHg9XFxcIjMuNVxcXCIgeT1cXFwiOC41XFxcIiB3aWR0aD1cXFwiMTNcXFwiIGhlaWdodD1cXFwiMTBcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk02LjUsOC41IEw2LjUsNC45IEM2LjUsMyA4LjEsMS41IDEwLDEuNSBDMTEuOSwxLjUgMTMuNSwzIDEzLjUsNC45XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidXBsb2FkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBwb2ludHM9XFxcIjUgOCA5LjUgMy41IDE0IDhcXFwiLz48cmVjdCB4PVxcXCIzXFxcIiB5PVxcXCIxN1xcXCIgd2lkdGg9XFxcIjEzXFxcIiBoZWlnaHQ9XFxcIjFcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHgxPVxcXCI5LjVcXFwiIHkxPVxcXCIxNVxcXCIgeDI9XFxcIjkuNVxcXCIgeTI9XFxcIjRcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ1c2VyXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI5LjlcXFwiIGN5PVxcXCI2LjRcXFwiIHI9XFxcIjQuNFxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xLjUsMTkgQzIuMywxNC41IDUuOCwxMS4yIDEwLDExLjIgQzE0LjIsMTEuMiAxNy43LDE0LjYgMTguNSwxOS4yXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidXNlcnNcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjcuN1xcXCIgY3k9XFxcIjguNlxcXCIgcj1cXFwiMy41XFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTEsMTguMSBDMS43LDE0LjYgNC40LDEyLjEgNy42LDEyLjEgQzEwLjksMTIuMSAxMy43LDE0LjggMTQuMywxOC4zXFxcIi8+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgZD1cXFwiTTExLjQsNCBDMTIuOCwyLjQgMTUuNCwyLjggMTYuMyw0LjcgQzE3LjIsNi42IDE1LjcsOC45IDEzLjYsOC45IEMxNi41LDguOSAxOC44LDExLjMgMTkuMiwxNC4xXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwidmlkZW8tY2FtZXJhXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWdvbiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHBvaW50cz1cXFwiMTcuNSA2LjkgMTcuNSAxMy4xIDEzLjUgMTAuNCAxMy41IDE0LjUgMi41IDE0LjUgMi41IDUuNSAxMy41IDUuNSAxMy41IDkuNiAxNy41IDYuOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInZpbWVvXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMi4wNjUsNy41OUMxLjg0LDcuMzY3LDEuNjU0LDcuMDgyLDEuNDY4LDYuODM4Yy0wLjMzMi0wLjQyLTAuMTM3LTAuNDExLDAuMjc0LTAuNzcyYzEuMDI2LTAuOTEsMi4wMDQtMS44OTYsMy4xMjctMi42ODggYzEuMDE3LTAuNzEzLDIuMzY1LTEuMTczLDMuMjg2LTAuMDM5YzAuODQ5LDEuMDQ1LDAuODY5LDIuNjI5LDEuMDg0LDMuODkxYzAuMjE1LDEuMzA5LDAuNDIxLDIuNjQ4LDAuODgsMy45MDEgYzAuMTI3LDAuMzUyLDAuMzcsMS4wMTgsMC44MSwxLjA3NGMwLjU2NywwLjA3OCwxLjE0NS0wLjkxNywxLjQwOC0xLjI4OWMwLjY4NC0wLjk4NywxLjYxMS0yLjMxNywxLjQ5NC0zLjU4NyBjLTAuMTE1LTEuMzQ5LTEuNTcyLTEuMDk1LTIuNDgyLTAuNzczYzAuMTQ2LTEuNTE0LDEuNTU1LTMuMjE2LDIuOTEyLTMuNzkyYzEuNDM5LTAuNTk3LDMuNTc5LTAuNTg3LDQuMzAyLDEuMDM2IGMwLjc3MiwxLjc1OSwwLjA3OCwzLjgwMi0wLjc2Myw1LjM5NmMtMC45MTgsMS43MzEtMi4xLDMuMzMzLTMuMzYzLDQuODI5Yy0xLjExNCwxLjMyOS0yLjQzMiwyLjc4Ny00LjA5MywzLjQyMiBjLTEuODk3LDAuNzIzLTMuMDIxLTAuNjg2LTMuNjY3LTIuMzE4Yy0wLjcwNS0xLjc3Ny0xLjA1Ni0zLjc3MS0xLjU2NS01LjYyMUM0Ljg5OCw4LjcyNiw0LjY0NCw3LjgzNiw0LjEzNiw3LjE5MSBDMy40NzMsNi4zNTgsMi43Miw3LjE0MSwyLjA2NSw3LjU5QzEuOTc3LDcuNTAyLDIuMTE1LDcuNTUxLDIuMDY1LDcuNTlMMi4wNjUsNy41OXpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ3YXJuaW5nXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGN4PVxcXCIxMFxcXCIgY3k9XFxcIjE0XFxcIiByPVxcXCIxXFxcIi8+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOVxcXCIvPjxwYXRoIGQ9XFxcIk0xMC45Nyw3LjcyIEMxMC44NSw5LjU0IDEwLjU2LDExLjI5IDEwLjU2LDExLjI5IEMxMC41MSwxMS44NyAxMC4yNywxMiA5Ljk5LDEyIEM5LjY5LDEyIDkuNDksMTEuODcgOS40MywxMS4yOSBDOS40MywxMS4yOSA5LjE2LDkuNTQgOS4wMyw3LjcyIEM4Ljk2LDYuNTQgOS4wMyw2IDkuMDMsNiBDOS4wMyw1LjQ1IDkuNDYsNS4wMiA5Ljk5LDUgQzEwLjUzLDUuMDEgMTAuOTcsNS40NCAxMC45Nyw2IEMxMC45Nyw2IDExLjA0LDYuNTQgMTAuOTcsNy43MiBMMTAuOTcsNy43MiBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwid2hhdHNhcHBcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk0xNi43LDMuM2MtMS44LTEuOC00LjEtMi44LTYuNy0yLjhjLTUuMiwwLTkuNCw0LjItOS40LDkuNGMwLDEuNywwLjQsMy4zLDEuMyw0LjdsLTEuMyw0LjlsNS0xLjNjMS40LDAuOCwyLjksMS4yLDQuNSwxLjIgbDAsMGwwLDBjNS4yLDAsOS40LTQuMiw5LjQtOS40QzE5LjUsNy40LDE4LjUsNSwxNi43LDMuMyBNMTAuMSwxNy43TDEwLjEsMTcuN2MtMS40LDAtMi44LTAuNC00LTEuMWwtMC4zLTAuMmwtMywwLjhsMC44LTIuOSBsLTAuMi0wLjNjLTAuOC0xLjItMS4yLTIuNy0xLjItNC4yYzAtNC4zLDMuNS03LjgsNy44LTcuOGMyLjEsMCw0LjEsMC44LDUuNSwyLjNjMS41LDEuNSwyLjMsMy40LDIuMyw1LjUgQzE3LjksMTQuMiwxNC40LDE3LjcsMTAuMSwxNy43IE0xNC40LDExLjljLTAuMi0wLjEtMS40LTAuNy0xLjYtMC44Yy0wLjItMC4xLTAuNC0wLjEtMC41LDAuMWMtMC4yLDAuMi0wLjYsMC44LTAuOCwwLjkgYy0wLjEsMC4yLTAuMywwLjItMC41LDAuMWMtMC4yLTAuMS0xLTAuNC0xLjktMS4yYy0wLjctMC42LTEuMi0xLjQtMS4zLTEuNmMtMC4xLTAuMiwwLTAuNCwwLjEtMC41QzgsOC44LDguMSw4LjcsOC4yLDguNSBjMC4xLTAuMSwwLjItMC4yLDAuMi0wLjRjMC4xLTAuMiwwLTAuMywwLTAuNEM4LjQsNy42LDcuOSw2LjUsNy43LDZDNy41LDUuNSw3LjMsNS42LDcuMiw1LjZjLTAuMSwwLTAuMywwLTAuNCwwIGMtMC4yLDAtMC40LDAuMS0wLjYsMC4zYy0wLjIsMC4yLTAuOCwwLjgtMC44LDJjMCwxLjIsMC44LDIuMywxLDIuNGMwLjEsMC4yLDEuNywyLjUsNCwzLjVjMC42LDAuMiwxLDAuNCwxLjMsMC41IGMwLjYsMC4yLDEuMSwwLjIsMS41LDAuMWMwLjUtMC4xLDEuNC0wLjYsMS42LTEuMWMwLjItMC41LDAuMi0xLDAuMS0xLjFDMTQuOCwxMi4xLDE0LjYsMTIsMTQuNCwxMS45XFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwid29yZHByZXNzXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTAsMC41Yy01LjIsMC05LjUsNC4zLTkuNSw5LjVzNC4zLDkuNSw5LjUsOS41YzUuMiwwLDkuNS00LjMsOS41LTkuNVMxNS4yLDAuNSwxMCwwLjVMMTAsMC41TDEwLDAuNXogTTE1LjYsMy45aC0wLjEgYy0wLjgsMC0xLjQsMC43LTEuNCwxLjVjMCwwLjcsMC40LDEuMywwLjgsMS45YzAuMywwLjYsMC43LDEuMywwLjcsMi4zYzAsMC43LTAuMywxLjUtMC42LDIuN0wxNC4xLDE1bC0zLTguOSBjMC41LDAsMC45LTAuMSwwLjktMC4xQzEyLjUsNiwxMi41LDUuMywxMiw1LjRjMCwwLTEuMywwLjEtMi4yLDAuMUM5LDUuNSw3LjcsNS40LDcuNyw1LjRDNy4yLDUuMyw3LjIsNiw3LjYsNmMwLDAsMC40LDAuMSwwLjksMC4xIGwxLjMsMy41TDgsMTVMNSw2LjFDNS41LDYuMSw1LjksNiw1LjksNkM2LjQsNiw2LjMsNS4zLDUuOSw1LjRjMCwwLTEuMywwLjEtMi4yLDAuMWMtMC4yLDAtMC4zLDAtMC41LDBjMS41LTIuMiw0LTMuNyw2LjktMy43IEMxMi4yLDEuNywxNC4xLDIuNiwxNS42LDMuOUwxNS42LDMuOUwxNS42LDMuOXogTTIuNSw2LjZsMy45LDEwLjhjLTIuNy0xLjMtNC42LTQuMi00LjYtNy40QzEuOCw4LjgsMiw3LjYsMi41LDYuNkwyLjUsNi42TDIuNSw2LjYgeiBNMTAuMiwxMC43bDIuNSw2LjljMCwwLDAsMC4xLDAuMSwwLjFDMTEuOSwxOCwxMSwxOC4yLDEwLDE4LjJjLTAuOCwwLTEuNi0wLjEtMi4zLTAuM0wxMC4yLDEwLjdMMTAuMiwxMC43TDEwLjIsMTAuN3ogTTE0LjIsMTcuMSBsMi41LTcuM2MwLjUtMS4yLDAuNi0yLjEsMC42LTIuOWMwLTAuMywwLTAuNi0wLjEtMC44YzAuNiwxLjIsMSwyLjUsMSw0QzE4LjMsMTMsMTYuNiwxNS43LDE0LjIsMTcuMUwxNC4yLDE3LjFMMTQuMiwxNy4xelxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcIndvcmxkXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0xLDEwLjUgTDE5LDEwLjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0yLjM1LDE1LjUgTDE3LjY1LDE1LjVcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIGQ9XFxcIk0yLjM1LDUuNSBMMTcuNTIzLDUuNVxcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgZD1cXFwiTTEwLDE5LjQ2IEw5Ljk4LDE5LjQ2IEM3LjMxLDE3LjMzIDUuNjEsMTQuMTQxIDUuNjEsMTAuNTggQzUuNjEsNy4wMiA3LjMzLDMuODMgMTAsMS43IEMxMC4wMSwxLjcgOS45OSwxLjcgMTAsMS43IEwxMCwxLjcgQzEyLjY3LDMuODMgMTQuNCw3LjAyIDE0LjQsMTAuNTggQzE0LjQsMTQuMTQxIDEyLjY3LDE3LjMzIDEwLDE5LjQ2IEwxMCwxOS40NiBMMTAsMTkuNDYgTDEwLDE5LjQ2IFpcXFwiLz48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTAuNVxcXCIgcj1cXFwiOVxcXCIvPjwvc3ZnPlwiLFxuICAgICAgICBcInhpbmdcIjogXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwYXRoIGQ9XFxcIk00LjQsNC41NiBDNC4yNCw0LjU2IDQuMTEsNC42MSA0LjA1LDQuNzIgQzMuOTgsNC44MyAzLjk5LDQuOTcgNC4wNyw1LjEyIEw1LjgyLDguMTYgTDUuODIsOC4xNyBMMy4wNiwxMy4wNCBDMi45OSwxMy4xOCAyLjk5LDEzLjMzIDMuMDYsMTMuNDQgQzMuMTIsMTMuNTUgMy4yNCwxMy42MiAzLjQsMTMuNjIgTDYsMTMuNjIgQzYuMzksMTMuNjIgNi41NywxMy4zNiA2LjcxLDEzLjEyIEM2LjcxLDEzLjEyIDkuNDEsOC4zNSA5LjUxLDguMTYgQzkuNDksOC4xNCA3LjcyLDUuMDQgNy43Miw1LjA0IEM3LjU4LDQuODEgNy4zOSw0LjU2IDYuOTksNC41NiBMNC40LDQuNTYgTDQuNCw0LjU2IFpcXFwiLz48cGF0aCBkPVxcXCJNMTUuMywxIEMxNC45MSwxIDE0Ljc0LDEuMjUgMTQuNiwxLjUgQzE0LjYsMS41IDkuMDEsMTEuNDIgOC44MiwxMS43NCBDOC44MywxMS43NiAxMi41MSwxOC41MSAxMi41MSwxOC41MSBDMTIuNjQsMTguNzQgMTIuODQsMTkgMTMuMjMsMTkgTDE1LjgyLDE5IEMxNS45OCwxOSAxNi4xLDE4Ljk0IDE2LjE2LDE4LjgzIEMxNi4yMywxOC43MiAxNi4yMywxOC41NyAxNi4xNiwxOC40MyBMMTIuNSwxMS43NCBMMTIuNSwxMS43MiBMMTguMjUsMS41NiBDMTguMzIsMS40MiAxOC4zMiwxLjI3IDE4LjI1LDEuMTYgQzE4LjIxLDEuMDYgMTguMDgsMSAxNy45MywxIEwxNS4zLDEgTDE1LjMsMSBaXFxcIi8+PC9zdmc+XCIsXG4gICAgICAgIFwieWVscFwiOiBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwiTTE3LjE3NSwxNC45NzFjLTAuMTEyLDAuNzctMS42ODYsMi43NjctMi40MDYsMy4wNTRjLTAuMjQ2LDAuMS0wLjQ4NywwLjA3Ni0wLjY3NS0wLjA2OVxcdGMtMC4xMjItMC4wOTYtMi40NDYtMy44NTktMi40NDYtMy44NTljLTAuMTk0LTAuMjkzLTAuMTU3LTAuNjgyLDAuMDgzLTAuOTc4YzAuMjM0LTAuMjg0LDAuNTgxLTAuMzkzLDAuODgxLTAuMjc2XFx0YzAuMDE2LDAuMDEsNC4yMSwxLjM5NCw0LjMzMiwxLjQ4MmMwLjE3OCwwLjE0OCwwLjI2MywwLjM3OSwwLjIyNSwwLjY0NkwxNy4xNzUsMTQuOTcxTDE3LjE3NSwxNC45NzF6IE0xMS40NjQsMTAuNzg5XFx0Yy0wLjIwMy0wLjMwNy0wLjE5OS0wLjY2NiwwLjAwOS0wLjkxNmMwLDAsMi42MjUtMy41NzQsMi43NDUtMy42NTdjMC4yMDMtMC4xMzUsMC40NTItMC4xNDEsMC42OS0wLjAyNVxcdGMwLjY5MSwwLjMzNSwyLjA4NSwyLjQwNSwyLjE2NywzLjE5OXYwLjAyN2MwLjAyNCwwLjI3MS0wLjA4MiwwLjQ5MS0wLjI3MywwLjYyM2MtMC4xMzIsMC4wODMtNC40MywxLjE1NS00LjQzLDEuMTU1XFx0Yy0wLjMyMiwwLjA5Ni0wLjY4LTAuMDYtMC44ODItMC4zODFMMTEuNDY0LDEwLjc4OXogTTkuNDc1LDkuNTYzQzkuMzIsOS42MDksOC44NDgsOS43NTcsOC4yNjksOC44MTdjMCwwLTMuOTE2LTYuMTYtNC4wMDctNi4zNTFcXHRjLTAuMDU3LTAuMjEyLDAuMDExLTAuNDU1LDAuMjAyLTAuNjVDNS4wNDcsMS4yMTEsOC4yMSwwLjMyNyw5LjAzNywwLjUyOWMwLjI3LDAuMDY5LDAuNDU3LDAuMjM4LDAuNTIyLDAuNDc5XFx0YzAuMDQ3LDAuMjY2LDAuNDMzLDUuOTgyLDAuNDg4LDcuMjY0QzEwLjA5OCw5LjM2OCw5LjYyOSw5LjUxNyw5LjQ3NSw5LjU2M3ogTTkuOTI3LDE5LjA2NmMtMC4wODMsMC4yMjUtMC4yNzMsMC4zNzMtMC41NCwwLjQyMVxcdGMtMC43NjIsMC4xMy0zLjE1LTAuNzUxLTMuNjQ3LTEuMzQyYy0wLjA5Ni0wLjEzMS0wLjE1NS0wLjI2Mi0wLjE2Ny0wLjM5NGMtMC4wMTEtMC4wOTUsMC0wLjE4OSwwLjAzNi0wLjI3MlxcdGMwLjA2MS0wLjE1NSwyLjkxNy0zLjUzOCwyLjkxNy0zLjUzOGMwLjIxNC0wLjI3MiwwLjU5NS0wLjM1NSwwLjk1Mi0wLjIxM2MwLjM0NSwwLjEzLDAuNTYsMC40MjgsMC41MzYsMC43NDlcXHRDMTAuMDE0LDE0LjQ3OSw5Ljk3NywxOC45MjMsOS45MjcsMTkuMDY2eiBNMy40OTUsMTMuOTEyYy0wLjIzNS0wLjAwOS0wLjQ0NC0wLjE0OC0wLjU2OC0wLjM4MmMtMC4wODktMC4xNy0wLjE1MS0wLjQ1My0wLjE5LTAuNzk0XFx0QzIuNjMsMTEuNzAxLDIuNzYxLDEwLjE0NCwzLjA3LDkuNjQ4YzAuMTQ1LTAuMjI2LDAuMzU3LTAuMzQ1LDAuNTkyLTAuMzM2YzAuMTU0LDAsNC4yNTUsMS42NjcsNC4yNTUsMS42NjdcXHRjMC4zMjEsMC4xMTgsMC41MjEsMC40NTMsMC41LDAuODMzYy0wLjAyMywwLjM3LTAuMjM2LDAuNjU1LTAuNTUxLDAuNzM4TDMuNDk1LDEzLjkxMnpcXFwiLz48L3N2Zz5cIixcbiAgICAgICAgXCJ5b3V0dWJlXCI6IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJNMTUsNC4xYzEsMC4xLDIuMywwLDMsMC44YzAuOCwwLjgsMC45LDIuMSwwLjksMy4xQzE5LDkuMiwxOSwxMC45LDE5LDEyYy0wLjEsMS4xLDAsMi40LTAuNSwzLjRjLTAuNSwxLjEtMS40LDEuNS0yLjUsMS42IGMtMS4yLDAuMS04LjYsMC4xLTExLDBjLTEuMS0wLjEtMi40LTAuMS0zLjItMWMtMC43LTAuOC0wLjctMi0wLjgtM0MxLDExLjgsMSwxMC4xLDEsOC45YzAtMS4xLDAtMi40LDAuNS0zLjRDMiw0LjUsMyw0LjMsNC4xLDQuMiBDNS4zLDQuMSwxMi42LDQsMTUsNC4xeiBNOCw3LjV2Nmw1LjUtM0w4LDcuNXpcXFwiLz48L3N2Zz5cIiB9KTtcblxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVUlraXQpIHtcbiAgICAgIHdpbmRvdy5VSWtpdC51c2UocGx1Z2luKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uikit/dist/js/uikit-icons.js\n");

/***/ }),

/***/ "./node_modules/uikit/dist/js/uikit.js":
/*!*********************************************!*\
  !*** ./node_modules/uikit/dist/js/uikit.js ***!
  \*********************************************/
/***/ (function(module) {

eval("/*! UIkit 3.14.1 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    const { hasOwnProperty, toString } = Object.prototype;\n\n    function hasOwn(obj, key) {\n      return hasOwnProperty.call(obj, key);\n    }\n\n    const hyphenateRe = /\\B([A-Z])/g;\n\n    const hyphenate = memoize((str) => str.replace(hyphenateRe, '-$1').toLowerCase());\n\n    const camelizeRe = /-(\\w)/g;\n\n    const camelize = memoize((str) => str.replace(camelizeRe, toUpper));\n\n    const ucfirst = memoize((str) =>\n    str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '');\n\n\n    function toUpper(_, c) {\n      return c ? c.toUpperCase() : '';\n    }\n\n    function startsWith(str, search) {\n      return str == null ? void 0 : str.startsWith == null ? void 0 : str.startsWith(search);\n    }\n\n    function endsWith(str, search) {\n      return str == null ? void 0 : str.endsWith == null ? void 0 : str.endsWith(search);\n    }\n\n    function includes(obj, search) {\n      return obj == null ? void 0 : obj.includes == null ? void 0 : obj.includes(search);\n    }\n\n    function findIndex(array, predicate) {\n      return array == null ? void 0 : array.findIndex == null ? void 0 : array.findIndex(predicate);\n    }\n\n    const { isArray, from: toArray } = Array;\n    const { assign } = Object;\n\n    function isFunction(obj) {\n      return typeof obj === 'function';\n    }\n\n    function isObject(obj) {\n      return obj !== null && typeof obj === 'object';\n    }\n\n    function isPlainObject(obj) {\n      return toString.call(obj) === '[object Object]';\n    }\n\n    function isWindow(obj) {\n      return isObject(obj) && obj === obj.window;\n    }\n\n    function isDocument(obj) {\n      return nodeType(obj) === 9;\n    }\n\n    function isNode(obj) {\n      return nodeType(obj) >= 1;\n    }\n\n    function isElement(obj) {\n      return nodeType(obj) === 1;\n    }\n\n    function nodeType(obj) {\n      return !isWindow(obj) && isObject(obj) && obj.nodeType;\n    }\n\n    function isBoolean(value) {\n      return typeof value === 'boolean';\n    }\n\n    function isString(value) {\n      return typeof value === 'string';\n    }\n\n    function isNumber(value) {\n      return typeof value === 'number';\n    }\n\n    function isNumeric(value) {\n      return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));\n    }\n\n    function isEmpty(obj) {\n      return !(isArray(obj) ? obj.length : isObject(obj) ? Object.keys(obj).length : false);\n    }\n\n    function isUndefined(value) {\n      return value === void 0;\n    }\n\n    function toBoolean(value) {\n      return isBoolean(value) ?\n      value :\n      value === 'true' || value === '1' || value === '' ?\n      true :\n      value === 'false' || value === '0' ?\n      false :\n      value;\n    }\n\n    function toNumber(value) {\n      const number = Number(value);\n      return isNaN(number) ? false : number;\n    }\n\n    function toFloat(value) {\n      return parseFloat(value) || 0;\n    }\n\n    function toNode(element) {\n      return toNodes(element)[0];\n    }\n\n    function toNodes(element) {\n      return element && (isNode(element) ? [element] : Array.from(element).filter(isNode)) || [];\n    }\n\n    function toWindow(element) {var _element;\n      if (isWindow(element)) {\n        return element;\n      }\n\n      element = toNode(element);\n      const document = isDocument(element) ? element : (_element = element) == null ? void 0 : _element.ownerDocument;\n\n      return (document == null ? void 0 : document.defaultView) || window;\n    }\n\n    function isEqual(value, other) {\n      return (\n        value === other ||\n        isObject(value) &&\n        isObject(other) &&\n        Object.keys(value).length === Object.keys(other).length &&\n        each(value, (val, key) => val === other[key]));\n\n    }\n\n    function swap(value, a, b) {\n      return value.replace(new RegExp(a + \"|\" + b, 'g'), (match) => match === a ? b : a);\n    }\n\n    function last(array) {\n      return array[array.length - 1];\n    }\n\n    function each(obj, cb) {\n      for (const key in obj) {\n        if (false === cb(obj[key], key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function sortBy$1(array, prop) {\n      return array.\n      slice().\n      sort((_ref, _ref2) => {let { [prop]: propA = 0 } = _ref;let { [prop]: propB = 0 } = _ref2;return (\n          propA > propB ? 1 : propB > propA ? -1 : 0);});\n\n    }\n\n    function uniqueBy(array, prop) {\n      const seen = new Set();\n      return array.filter((_ref3) => {let { [prop]: check } = _ref3;return seen.has(check) ? false : seen.add(check);});\n    }\n\n    function clamp(number, min, max) {if (min === void 0) {min = 0;}if (max === void 0) {max = 1;}\n      return Math.min(Math.max(toNumber(number) || 0, min), max);\n    }\n\n    function noop() {}\n\n    function intersectRect() {for (var _len = arguments.length, rects = new Array(_len), _key = 0; _key < _len; _key++) {rects[_key] = arguments[_key];}\n      return [\n      ['bottom', 'top'],\n      ['right', 'left']].\n      every(\n      (_ref4) => {let [minProp, maxProp] = _ref4;return (\n          Math.min(...rects.map((_ref5) => {let { [minProp]: min } = _ref5;return min;})) -\n          Math.max(...rects.map((_ref6) => {let { [maxProp]: max } = _ref6;return max;})) >\n          0);});\n\n    }\n\n    function pointInRect(point, rect) {\n      return (\n        point.x <= rect.right &&\n        point.x >= rect.left &&\n        point.y <= rect.bottom &&\n        point.y >= rect.top);\n\n    }\n\n    function ratio(dimensions, prop, value) {\n      const aProp = prop === 'width' ? 'height' : 'width';\n\n      return {\n        [aProp]: dimensions[prop] ?\n        Math.round(value * dimensions[aProp] / dimensions[prop]) :\n        dimensions[aProp],\n        [prop]: value };\n\n    }\n\n    function contain(dimensions, maxDimensions) {\n      dimensions = { ...dimensions };\n\n      for (const prop in dimensions) {\n        dimensions =\n        dimensions[prop] > maxDimensions[prop] ?\n        ratio(dimensions, prop, maxDimensions[prop]) :\n        dimensions;\n      }\n\n      return dimensions;\n    }\n\n    function cover$1(dimensions, maxDimensions) {\n      dimensions = contain(dimensions, maxDimensions);\n\n      for (const prop in dimensions) {\n        dimensions =\n        dimensions[prop] < maxDimensions[prop] ?\n        ratio(dimensions, prop, maxDimensions[prop]) :\n        dimensions;\n      }\n\n      return dimensions;\n    }\n\n    const Dimensions = { ratio, contain, cover: cover$1 };\n\n    function getIndex(i, elements, current, finite) {if (current === void 0) {current = 0;}if (finite === void 0) {finite = false;}\n      elements = toNodes(elements);\n\n      const { length } = elements;\n\n      if (!length) {\n        return -1;\n      }\n\n      i = isNumeric(i) ?\n      toNumber(i) :\n      i === 'next' ?\n      current + 1 :\n      i === 'previous' ?\n      current - 1 :\n      elements.indexOf(toNode(i));\n\n      if (finite) {\n        return clamp(i, 0, length - 1);\n      }\n\n      i %= length;\n\n      return i < 0 ? i + length : i;\n    }\n\n    function memoize(fn) {\n      const cache = Object.create(null);\n      return (key) => cache[key] || (cache[key] = fn(key));\n    }\n\n    class Deferred {\n      constructor() {\n        this.promise = new Promise((resolve, reject) => {\n          this.reject = reject;\n          this.resolve = resolve;\n        });\n      }}\n\n    function attr(element, name, value) {\n      if (isObject(name)) {\n        for (const key in name) {\n          attr(element, key, name[key]);\n        }\n        return;\n      }\n\n      if (isUndefined(value)) {var _toNode;\n        return (_toNode = toNode(element)) == null ? void 0 : _toNode.getAttribute(name);\n      } else {\n        for (const el of toNodes(element)) {\n          if (isFunction(value)) {\n            value = value.call(el, attr(el, name));\n          }\n\n          if (value === null) {\n            removeAttr(el, name);\n          } else {\n            el.setAttribute(name, value);\n          }\n        }\n      }\n    }\n\n    function hasAttr(element, name) {\n      return toNodes(element).some((element) => element.hasAttribute(name));\n    }\n\n    function removeAttr(element, name) {\n      const elements = toNodes(element);\n      for (const attribute of name.split(' ')) {\n        for (const element of elements) {\n          element.removeAttribute(attribute);\n        }\n      }\n    }\n\n    function data(element, attribute) {\n      for (const name of [attribute, \"data-\" + attribute]) {\n        if (hasAttr(element, name)) {\n          return attr(element, name);\n        }\n      }\n    }\n\n    const voidElements = {\n      area: true,\n      base: true,\n      br: true,\n      col: true,\n      embed: true,\n      hr: true,\n      img: true,\n      input: true,\n      keygen: true,\n      link: true,\n      menuitem: true,\n      meta: true,\n      param: true,\n      source: true,\n      track: true,\n      wbr: true };\n\n    function isVoidElement(element) {\n      return toNodes(element).some((element) => voidElements[element.tagName.toLowerCase()]);\n    }\n\n    function isVisible(element) {\n      return toNodes(element).some(\n      (element) => element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n\n    }\n\n    const selInput = 'input,select,textarea,button';\n    function isInput(element) {\n      return toNodes(element).some((element) => matches(element, selInput));\n    }\n\n    const selFocusable = selInput + \",a[href],[tabindex]\";\n    function isFocusable(element) {\n      return matches(element, selFocusable);\n    }\n\n    function parent(element) {var _toNode;\n      return (_toNode = toNode(element)) == null ? void 0 : _toNode.parentElement;\n    }\n\n    function filter$1(element, selector) {\n      return toNodes(element).filter((element) => matches(element, selector));\n    }\n\n    function matches(element, selector) {\n      return toNodes(element).some((element) => element.matches(selector));\n    }\n\n    function closest(element, selector) {\n      if (startsWith(selector, '>')) {\n        selector = selector.slice(1);\n      }\n\n      return isElement(element) ?\n      element.closest(selector) :\n      toNodes(element).\n      map((element) => closest(element, selector)).\n      filter(Boolean);\n    }\n\n    function within(element, selector) {\n      return isString(selector) ?\n      matches(element, selector) || !!closest(element, selector) :\n      element === selector || toNode(selector).contains(toNode(element));\n    }\n\n    function parents(element, selector) {\n      const elements = [];\n\n      while (element = parent(element)) {\n        if (!selector || matches(element, selector)) {\n          elements.push(element);\n        }\n      }\n\n      return elements;\n    }\n\n    function children(element, selector) {\n      element = toNode(element);\n      const children = element ? toNodes(element.children) : [];\n      return selector ? filter$1(children, selector) : children;\n    }\n\n    function index(element, ref) {\n      return ref ? toNodes(element).indexOf(toNode(ref)) : children(parent(element)).indexOf(element);\n    }\n\n    function query(selector, context) {\n      return find(selector, getContext(selector, context));\n    }\n\n    function queryAll(selector, context) {\n      return findAll(selector, getContext(selector, context));\n    }\n\n    function find(selector, context) {\n      return toNode(_query(selector, context, 'querySelector'));\n    }\n\n    function findAll(selector, context) {\n      return toNodes(_query(selector, context, 'querySelectorAll'));\n    }\n\n    const contextSelectorRe = /(^|[^\\\\],)\\s*[!>+~-]/;\n    const isContextSelector = memoize((selector) => selector.match(contextSelectorRe));\n\n    function getContext(selector, context) {if (context === void 0) {context = document;}\n      return isString(selector) && isContextSelector(selector) || isDocument(context) ?\n      context :\n      context.ownerDocument;\n    }\n\n    const contextSanitizeRe = /([!>+~-])(?=\\s+[!>+~-]|\\s*$)/g;\n    const sanatize = memoize((selector) => selector.replace(contextSanitizeRe, '$1 *'));\n\n    function _query(selector, context, queryFn) {if (context === void 0) {context = document;}\n      if (!selector || !isString(selector)) {\n        return selector;\n      }\n\n      selector = sanatize(selector);\n\n      if (isContextSelector(selector)) {\n        const split = splitSelector(selector);\n        selector = '';\n        for (let sel of split) {\n          let ctx = context;\n\n          if (sel[0] === '!') {\n            const selectors = sel.substr(1).trim().split(' ');\n            ctx = closest(parent(context), selectors[0]);\n            sel = selectors.slice(1).join(' ').trim();\n            if (!sel.length && split.length === 1) {\n              return ctx;\n            }\n          }\n\n          if (sel[0] === '-') {\n            const selectors = sel.substr(1).trim().split(' ');\n            const prev = (ctx || context).previousElementSibling;\n            ctx = matches(prev, sel.substr(1)) ? prev : null;\n            sel = selectors.slice(1).join(' ');\n          }\n\n          if (ctx) {\n            selector += \"\" + (selector ? ',' : '') + domPath(ctx) + \" \" + sel;\n          }\n        }\n\n        context = document;\n      }\n\n      try {\n        return context[queryFn](selector);\n      } catch (e) {\n        return null;\n      }\n    }\n\n    const selectorRe = /.*?[^\\\\](?:,|$)/g;\n\n    const splitSelector = memoize((selector) =>\n    selector.match(selectorRe).map((selector) => selector.replace(/,$/, '').trim()));\n\n\n    function domPath(element) {\n      const names = [];\n      while (element.parentNode) {\n        const id = attr(element, 'id');\n        if (id) {\n          names.unshift(\"#\" + escape(id));\n          break;\n        } else {\n          let { tagName } = element;\n          if (tagName !== 'HTML') {\n            tagName += \":nth-child(\" + (index(element) + 1) + \")\";\n          }\n          names.unshift(tagName);\n          element = element.parentNode;\n        }\n      }\n      return names.join(' > ');\n    }\n\n    function escape(css) {\n      return isString(css) ? CSS.escape(css) : '';\n    }\n\n    function on() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n      let [targets, types, selector, listener, useCapture = false] = getArgs(args);\n\n      if (listener.length > 1) {\n        listener = detail(listener);\n      }\n\n      if (useCapture != null && useCapture.self) {\n        listener = selfFilter(listener);\n      }\n\n      if (selector) {\n        listener = delegate(selector, listener);\n      }\n\n      for (const type of types) {\n        for (const target of targets) {\n          target.addEventListener(type, listener, useCapture);\n        }\n      }\n\n      return () => off(targets, types, listener, useCapture);\n    }\n\n    function off() {for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}\n      let [targets, types,, listener, useCapture = false] = getArgs(args);\n      for (const type of types) {\n        for (const target of targets) {\n          target.removeEventListener(type, listener, useCapture);\n        }\n      }\n    }\n\n    function once() {for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {args[_key3] = arguments[_key3];}\n      const [element, types, selector, listener, useCapture = false, condition] = getArgs(args);\n      const off = on(\n      element,\n      types,\n      selector,\n      (e) => {\n        const result = !condition || condition(e);\n        if (result) {\n          off();\n          listener(e, result);\n        }\n      },\n      useCapture);\n\n\n      return off;\n    }\n\n    function trigger(targets, event, detail) {\n      return toEventTargets(targets).every((target) =>\n      target.dispatchEvent(createEvent(event, true, true, detail)));\n\n    }\n\n    function createEvent(e, bubbles, cancelable, detail) {if (bubbles === void 0) {bubbles = true;}if (cancelable === void 0) {cancelable = false;}\n      if (isString(e)) {\n        e = new CustomEvent(e, { bubbles, cancelable, detail });\n      }\n\n      return e;\n    }\n\n    function getArgs(args) {\n      // Event targets\n      args[0] = toEventTargets(args[0]);\n\n      // Event types\n      if (isString(args[1])) {\n        args[1] = args[1].split(' ');\n      }\n\n      // Delegate?\n      if (isFunction(args[2])) {\n        args.splice(2, 0, false);\n      }\n\n      return args;\n    }\n\n    function delegate(selector, listener) {\n      return (e) => {\n        const current =\n        selector[0] === '>' ?\n        findAll(selector, e.currentTarget).\n        reverse().\n        filter((element) => within(e.target, element))[0] :\n        closest(e.target, selector);\n\n        if (current) {\n          e.current = current;\n          listener.call(this, e);\n        }\n      };\n    }\n\n    function detail(listener) {\n      return (e) => isArray(e.detail) ? listener(e, ...e.detail) : listener(e);\n    }\n\n    function selfFilter(listener) {\n      return function (e) {\n        if (e.target === e.currentTarget || e.target === e.current) {\n          return listener.call(null, e);\n        }\n      };\n    }\n\n    function isEventTarget(target) {\n      return target && 'addEventListener' in target;\n    }\n\n    function toEventTarget(target) {\n      return isEventTarget(target) ? target : toNode(target);\n    }\n\n    function toEventTargets(target) {\n      return isArray(target) ?\n      target.map(toEventTarget).filter(Boolean) :\n      isString(target) ?\n      findAll(target) :\n      isEventTarget(target) ?\n      [target] :\n      toNodes(target);\n    }\n\n    function isTouch(e) {\n      return e.pointerType === 'touch' || !!e.touches;\n    }\n\n    function getEventPos(e) {var _e$touches, _e$changedTouches;\n      const { clientX: x, clientY: y } = ((_e$touches = e.touches) == null ? void 0 : _e$touches[0]) || ((_e$changedTouches = e.changedTouches) == null ? void 0 : _e$changedTouches[0]) || e;\n\n      return { x, y };\n    }\n\n    function ajax(url, options) {\n      const env = {\n        data: null,\n        method: 'GET',\n        headers: {},\n        xhr: new XMLHttpRequest(),\n        beforeSend: noop,\n        responseType: '',\n        ...options };\n\n      return Promise.resolve().\n      then(() => env.beforeSend(env)).\n      then(() => send(url, env));\n    }\n\n    function send(url, env) {\n      return new Promise((resolve, reject) => {\n        const { xhr } = env;\n\n        for (const prop in env) {\n          if (prop in xhr) {\n            try {\n              xhr[prop] = env[prop];\n            } catch (e) {\n              // noop\n            }\n          }\n        }\n\n        xhr.open(env.method.toUpperCase(), url);\n\n        for (const header in env.headers) {\n          xhr.setRequestHeader(header, env.headers[header]);\n        }\n\n        on(xhr, 'load', () => {\n          if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n            resolve(xhr);\n          } else {\n            reject(\n            assign(Error(xhr.statusText), {\n              xhr,\n              status: xhr.status }));\n\n\n          }\n        });\n\n        on(xhr, 'error', () => reject(assign(Error('Network Error'), { xhr })));\n        on(xhr, 'timeout', () => reject(assign(Error('Network Timeout'), { xhr })));\n\n        xhr.send(env.data);\n      });\n    }\n\n    function getImage(src, srcset, sizes) {\n      return new Promise((resolve, reject) => {\n        const img = new Image();\n\n        img.onerror = (e) => {\n          reject(e);\n        };\n        img.onload = () => {\n          resolve(img);\n        };\n\n        sizes && (img.sizes = sizes);\n        srcset && (img.srcset = srcset);\n        img.src = src;\n      });\n    }\n\n    const cssNumber = {\n      'animation-iteration-count': true,\n      'column-count': true,\n      'fill-opacity': true,\n      'flex-grow': true,\n      'flex-shrink': true,\n      'font-weight': true,\n      'line-height': true,\n      opacity: true,\n      order: true,\n      orphans: true,\n      'stroke-dasharray': true,\n      'stroke-dashoffset': true,\n      widows: true,\n      'z-index': true,\n      zoom: true };\n\n\n    function css(element, property, value, priority) {if (priority === void 0) {priority = '';}\n      const elements = toNodes(element);\n      for (const element of elements) {\n        if (isString(property)) {\n          property = propName(property);\n\n          if (isUndefined(value)) {\n            return getComputedStyle(element).getPropertyValue(property);\n          } else {\n            element.style.setProperty(\n            property,\n            isNumeric(value) && !cssNumber[property] ?\n            value + \"px\" :\n            value || isNumber(value) ?\n            value :\n            '',\n            priority);\n\n          }\n        } else if (isArray(property)) {\n          const props = {};\n          for (const prop of property) {\n            props[prop] = css(element, prop);\n          }\n          return props;\n        } else if (isObject(property)) {\n          priority = value;\n          each(property, (value, property) => css(element, property, value, priority));\n        }\n      }\n      return elements[0];\n    }\n\n    const propertyRe = /^\\s*([\"'])?(.*?)\\1\\s*$/;\n    function getCssVar(name, element) {if (element === void 0) {element = document.documentElement;}\n      return css(element, \"--uk-\" + name).replace(propertyRe, '$2');\n    }\n\n    // https://drafts.csswg.org/cssom/#dom-cssstyledeclaration-setproperty\n    const propName = memoize((name) => vendorPropName(name));\n\n    const cssPrefixes = ['webkit', 'moz'];\n\n    function vendorPropName(name) {\n      if (name[0] === '-') {\n        return name;\n      }\n\n      name = hyphenate(name);\n\n      const { style } = document.documentElement;\n\n      if (name in style) {\n        return name;\n      }\n\n      let i = cssPrefixes.length,\n      prefixedName;\n\n      while (i--) {\n        prefixedName = \"-\" + cssPrefixes[i] + \"-\" + name;\n        if (prefixedName in style) {\n          return prefixedName;\n        }\n      }\n    }\n\n    function addClass(element) {for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {args[_key - 1] = arguments[_key];}\n      apply$1(element, args, 'add');\n    }\n\n    function removeClass(element) {for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {args[_key2 - 1] = arguments[_key2];}\n      apply$1(element, args, 'remove');\n    }\n\n    function removeClasses(element, cls) {\n      attr(element, 'class', (value) => (value || '').replace(new RegExp(\"\\\\b\" + cls + \"\\\\b\", 'g'), ''));\n    }\n\n    function replaceClass(element) {\n      (arguments.length <= 1 ? undefined : arguments[1]) && removeClass(element, arguments.length <= 1 ? undefined : arguments[1]);\n      (arguments.length <= 2 ? undefined : arguments[2]) && addClass(element, arguments.length <= 2 ? undefined : arguments[2]);\n    }\n\n    function hasClass(element, cls) {\n      [cls] = getClasses(cls);\n      return !!cls && toNodes(element).some((node) => node.classList.contains(cls));\n    }\n\n    function toggleClass(element, cls, force) {\n      const classes = getClasses(cls);\n\n      if (!isUndefined(force)) {\n        force = !!force;\n      }\n\n      for (const node of toNodes(element)) {\n        for (const cls of classes) {\n          node.classList.toggle(cls, force);\n        }\n      }\n    }\n\n    function apply$1(element, args, fn) {\n      args = args.reduce((args, arg) => args.concat(getClasses(arg)), []);\n\n      for (const node of toNodes(element)) {\n        node.classList[fn](...args);\n      }\n    }\n\n    function getClasses(str) {\n      return String(str).split(/\\s|,/).filter(Boolean);\n    }\n\n    function transition(element, props, duration, timing) {if (duration === void 0) {duration = 400;}if (timing === void 0) {timing = 'linear';}\n      return Promise.all(\n      toNodes(element).map(\n      (element) =>\n      new Promise((resolve, reject) => {\n        for (const name in props) {\n          const value = css(element, name);\n          if (value === '') {\n            css(element, name, value);\n          }\n        }\n\n        const timer = setTimeout(() => trigger(element, 'transitionend'), duration);\n\n        once(\n        element,\n        'transitionend transitioncanceled',\n        (_ref) => {let { type } = _ref;\n          clearTimeout(timer);\n          removeClass(element, 'uk-transition');\n          css(element, {\n            transitionProperty: '',\n            transitionDuration: '',\n            transitionTimingFunction: '' });\n\n          type === 'transitioncanceled' ? reject() : resolve(element);\n        },\n        { self: true });\n\n\n        addClass(element, 'uk-transition');\n        css(element, {\n          transitionProperty: Object.keys(props).map(propName).join(','),\n          transitionDuration: duration + \"ms\",\n          transitionTimingFunction: timing,\n          ...props });\n\n      })));\n\n\n    }\n\n    const Transition = {\n      start: transition,\n\n      stop(element) {\n        trigger(element, 'transitionend');\n        return Promise.resolve();\n      },\n\n      cancel(element) {\n        trigger(element, 'transitioncanceled');\n      },\n\n      inProgress(element) {\n        return hasClass(element, 'uk-transition');\n      } };\n\n\n    const animationPrefix = 'uk-animation-';\n\n    function animate$1(element, animation, duration, origin, out) {if (duration === void 0) {duration = 200;}\n      return Promise.all(\n      toNodes(element).map(\n      (element) =>\n      new Promise((resolve, reject) => {\n        trigger(element, 'animationcanceled');\n        const timer = setTimeout(() => trigger(element, 'animationend'), duration);\n\n        once(\n        element,\n        'animationend animationcanceled',\n        (_ref2) => {let { type } = _ref2;\n          clearTimeout(timer);\n\n          type === 'animationcanceled' ? reject() : resolve(element);\n\n          css(element, 'animationDuration', '');\n          removeClasses(element, animationPrefix + \"\\\\S*\");\n        },\n        { self: true });\n\n\n        css(element, 'animationDuration', duration + \"ms\");\n        addClass(element, animation, animationPrefix + (out ? 'leave' : 'enter'));\n\n        if (startsWith(animation, animationPrefix)) {\n          origin && addClass(element, \"uk-transform-origin-\" + origin);\n          out && addClass(element, animationPrefix + \"reverse\");\n        }\n      })));\n\n\n    }\n\n    const inProgress = new RegExp(animationPrefix + \"(enter|leave)\");\n    const Animation = {\n      in: animate$1,\n\n      out(element, animation, duration, origin) {\n        return animate$1(element, animation, duration, origin, true);\n      },\n\n      inProgress(element) {\n        return inProgress.test(attr(element, 'class'));\n      },\n\n      cancel(element) {\n        trigger(element, 'animationcanceled');\n      } };\n\n    const dirs$1 = {\n      width: ['left', 'right'],\n      height: ['top', 'bottom'] };\n\n\n    function dimensions$1(element) {\n      const rect = isElement(element) ?\n      toNode(element).getBoundingClientRect() :\n      { height: height(element), width: width(element), top: 0, left: 0 };\n\n      return {\n        height: rect.height,\n        width: rect.width,\n        top: rect.top,\n        left: rect.left,\n        bottom: rect.top + rect.height,\n        right: rect.left + rect.width };\n\n    }\n\n    function offset(element, coordinates) {\n      const currentOffset = dimensions$1(element);\n\n      if (element) {\n        const { scrollY, scrollX } = toWindow(element);\n        const offsetBy = { height: scrollY, width: scrollX };\n\n        for (const dir in dirs$1) {\n          for (const prop of dirs$1[dir]) {\n            currentOffset[prop] += offsetBy[dir];\n          }\n        }\n      }\n\n      if (!coordinates) {\n        return currentOffset;\n      }\n\n      const pos = css(element, 'position');\n\n      each(css(element, ['left', 'top']), (value, prop) =>\n      css(\n      element,\n      prop,\n      coordinates[prop] -\n      currentOffset[prop] +\n      toFloat(pos === 'absolute' && value === 'auto' ? position(element)[prop] : value)));\n\n\n    }\n\n    function position(element) {\n      let { top, left } = offset(element);\n\n      const {\n        ownerDocument: { body, documentElement },\n        offsetParent } =\n      toNode(element);\n      let parent = offsetParent || documentElement;\n\n      while (\n      parent && (\n      parent === body || parent === documentElement) &&\n      css(parent, 'position') === 'static')\n      {\n        parent = parent.parentNode;\n      }\n\n      if (isElement(parent)) {\n        const parentOffset = offset(parent);\n        top -= parentOffset.top + toFloat(css(parent, 'borderTopWidth'));\n        left -= parentOffset.left + toFloat(css(parent, 'borderLeftWidth'));\n      }\n\n      return {\n        top: top - toFloat(css(element, 'marginTop')),\n        left: left - toFloat(css(element, 'marginLeft')) };\n\n    }\n\n    function offsetPosition(element) {\n      const offset = [0, 0];\n\n      element = toNode(element);\n\n      do {\n        offset[0] += element.offsetTop;\n        offset[1] += element.offsetLeft;\n\n        if (css(element, 'position') === 'fixed') {\n          const win = toWindow(element);\n          offset[0] += win.scrollY;\n          offset[1] += win.scrollX;\n          return offset;\n        }\n      } while (element = element.offsetParent);\n\n      return offset;\n    }\n\n    const height = dimension('height');\n    const width = dimension('width');\n\n    function dimension(prop) {\n      const propName = ucfirst(prop);\n      return (element, value) => {\n        if (isUndefined(value)) {\n          if (isWindow(element)) {\n            return element[\"inner\" + propName];\n          }\n\n          if (isDocument(element)) {\n            const doc = element.documentElement;\n            return Math.max(doc[\"offset\" + propName], doc[\"scroll\" + propName]);\n          }\n\n          element = toNode(element);\n\n          value = css(element, prop);\n          value = value === 'auto' ? element[\"offset\" + propName] : toFloat(value) || 0;\n\n          return value - boxModelAdjust(element, prop);\n        } else {\n          return css(\n          element,\n          prop,\n          !value && value !== 0 ? '' : +value + boxModelAdjust(element, prop) + 'px');\n\n        }\n      };\n    }\n\n    function boxModelAdjust(element, prop, sizing) {if (sizing === void 0) {sizing = 'border-box';}\n      return css(element, 'boxSizing') === sizing ?\n      dirs$1[prop].\n      map(ucfirst).\n      reduce(\n      (value, prop) =>\n      value +\n      toFloat(css(element, \"padding\" + prop)) +\n      toFloat(css(element, \"border\" + prop + \"Width\")),\n      0) :\n\n      0;\n    }\n\n    function flipPosition(pos) {\n      for (const dir in dirs$1) {\n        for (const i in dirs$1[dir]) {\n          if (dirs$1[dir][i] === pos) {\n            return dirs$1[dir][1 - i];\n          }\n        }\n      }\n      return pos;\n    }\n\n    function toPx(value, property, element, offsetDim) {if (property === void 0) {property = 'width';}if (element === void 0) {element = window;}if (offsetDim === void 0) {offsetDim = false;}\n      if (!isString(value)) {\n        return toFloat(value);\n      }\n\n      return parseCalc(value).reduce((result, value) => {\n        const unit = parseUnit(value);\n        if (unit) {\n          value = percent(\n          unit === 'vh' ?\n          height(toWindow(element)) :\n          unit === 'vw' ?\n          width(toWindow(element)) :\n          offsetDim ?\n          element[\"offset\" + ucfirst(property)] :\n          dimensions$1(element)[property],\n          value);\n\n        }\n\n        return result + toFloat(value);\n      }, 0);\n    }\n\n    const calcRe = /-?\\d+(?:\\.\\d+)?(?:v[wh]|%|px)?/g;\n    const parseCalc = memoize((calc) => calc.toString().replace(/\\s/g, '').match(calcRe) || []);\n    const unitRe$1 = /(?:v[hw]|%)$/;\n    const parseUnit = memoize((str) => (str.match(unitRe$1) || [])[0]);\n\n    function percent(base, value) {\n      return base * toFloat(value) / 100;\n    }\n\n    function ready(fn) {\n      if (document.readyState !== 'loading') {\n        fn();\n        return;\n      }\n\n      once(document, 'DOMContentLoaded', fn);\n    }\n\n    function isTag(element, tagName) {var _element$tagName;\n      return (element == null ? void 0 : (_element$tagName = element.tagName) == null ? void 0 : _element$tagName.toLowerCase()) === tagName.toLowerCase();\n    }\n\n    function empty(element) {\n      return replaceChildren(element, '');\n    }\n\n    function html(parent, html) {\n      return isUndefined(html) ? $(parent).innerHTML : replaceChildren(parent, html);\n    }\n\n    const replaceChildren = applyFn('replaceChildren');\n    const prepend = applyFn('prepend');\n    const append = applyFn('append');\n    const before = applyFn('before');\n    const after = applyFn('after');\n\n    function applyFn(fn) {\n      return function (ref, element) {var _$;\n        const nodes = toNodes(isString(element) ? fragment(element) : element);\n        (_$ = $(ref)) == null ? void 0 : _$[fn](...nodes);\n        return unwrapSingle(nodes);\n      };\n    }\n\n    function remove$1(element) {\n      toNodes(element).forEach((element) => element.remove());\n    }\n\n    function wrapAll(element, structure) {\n      structure = toNode(before(element, structure));\n\n      while (structure.firstChild) {\n        structure = structure.firstChild;\n      }\n\n      append(structure, element);\n\n      return structure;\n    }\n\n    function wrapInner(element, structure) {\n      return toNodes(\n      toNodes(element).map((element) =>\n      element.hasChildNodes() ?\n      wrapAll(toNodes(element.childNodes), structure) :\n      append(element, structure)));\n\n\n    }\n\n    function unwrap(element) {\n      toNodes(element).\n      map(parent).\n      filter((value, index, self) => self.indexOf(value) === index).\n      forEach((parent) => parent.replaceWith(...parent.childNodes));\n    }\n\n    const fragmentRe = /^\\s*<(\\w+|!)[^>]*>/;\n    const singleTagRe = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\n\n    function fragment(html) {\n      const matches = singleTagRe.exec(html);\n      if (matches) {\n        return document.createElement(matches[1]);\n      }\n\n      const container = document.createElement('div');\n      if (fragmentRe.test(html)) {\n        container.insertAdjacentHTML('beforeend', html.trim());\n      } else {\n        container.textContent = html;\n      }\n\n      return unwrapSingle(container.childNodes);\n    }\n\n    function unwrapSingle(nodes) {\n      return nodes.length > 1 ? nodes : nodes[0];\n    }\n\n    function apply(node, fn) {\n      if (!isElement(node)) {\n        return;\n      }\n\n      fn(node);\n      node = node.firstElementChild;\n      while (node) {\n        const next = node.nextElementSibling;\n        apply(node, fn);\n        node = next;\n      }\n    }\n\n    function $(selector, context) {\n      return isHtml(selector) ? toNode(fragment(selector)) : find(selector, context);\n    }\n\n    function $$(selector, context) {\n      return isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context);\n    }\n\n    function isHtml(str) {\n      return isString(str) && startsWith(str.trim(), '<');\n    }\n\n    const inBrowser = typeof window !== 'undefined';\n    const isRtl = inBrowser && attr(document.documentElement, 'dir') === 'rtl';\n\n    const hasTouch = inBrowser && 'ontouchstart' in window;\n    const hasPointerEvents = inBrowser && window.PointerEvent;\n\n    const pointerDown = hasPointerEvents ? 'pointerdown' : hasTouch ? 'touchstart' : 'mousedown';\n    const pointerMove = hasPointerEvents ? 'pointermove' : hasTouch ? 'touchmove' : 'mousemove';\n    const pointerUp = hasPointerEvents ? 'pointerup' : hasTouch ? 'touchend' : 'mouseup';\n    const pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouch ? '' : 'mouseenter';\n    const pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouch ? '' : 'mouseleave';\n    const pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';\n\n    /*\n        Based on:\n        Copyright (c) 2016 Wilson Page wilsonpage@me.com\n        https://github.com/wilsonpage/fastdom\n    */\n\n    const fastdom = {\n      reads: [],\n      writes: [],\n\n      read(task) {\n        this.reads.push(task);\n        scheduleFlush();\n        return task;\n      },\n\n      write(task) {\n        this.writes.push(task);\n        scheduleFlush();\n        return task;\n      },\n\n      clear(task) {\n        remove(this.reads, task);\n        remove(this.writes, task);\n      },\n\n      flush };\n\n\n    function flush(recursion) {\n      runTasks(fastdom.reads);\n      runTasks(fastdom.writes.splice(0));\n\n      fastdom.scheduled = false;\n\n      if (fastdom.reads.length || fastdom.writes.length) {\n        scheduleFlush(recursion + 1);\n      }\n    }\n\n    const RECURSION_LIMIT = 4;\n    function scheduleFlush(recursion) {\n      if (fastdom.scheduled) {\n        return;\n      }\n\n      fastdom.scheduled = true;\n      if (recursion && recursion < RECURSION_LIMIT) {\n        Promise.resolve().then(() => flush(recursion));\n      } else {\n        requestAnimationFrame(() => flush(1));\n      }\n    }\n\n    function runTasks(tasks) {\n      let task;\n      while (task = tasks.shift()) {\n        try {\n          task();\n        } catch (e) {\n          console.error(e);\n        }\n      }\n    }\n\n    function remove(array, item) {\n      const index = array.indexOf(item);\n      return ~index && array.splice(index, 1);\n    }\n\n    function MouseTracker() {}\n\n    MouseTracker.prototype = {\n      positions: [],\n\n      init() {\n        this.positions = [];\n\n        let position;\n        this.unbind = on(document, 'mousemove', (e) => position = getEventPos(e));\n        this.interval = setInterval(() => {\n          if (!position) {\n            return;\n          }\n\n          this.positions.push(position);\n\n          if (this.positions.length > 5) {\n            this.positions.shift();\n          }\n        }, 50);\n      },\n\n      cancel() {var _this$unbind;\n        (_this$unbind = this.unbind) == null ? void 0 : _this$unbind.call(this);\n        this.interval && clearInterval(this.interval);\n      },\n\n      movesTo(target) {\n        if (this.positions.length < 2) {\n          return false;\n        }\n\n        const p = target.getBoundingClientRect();\n        const { left, right, top, bottom } = p;\n\n        const [prevPosition] = this.positions;\n        const position = last(this.positions);\n        const path = [prevPosition, position];\n\n        if (pointInRect(position, p)) {\n          return false;\n        }\n\n        const diagonals = [\n        [\n        { x: left, y: top },\n        { x: right, y: bottom }],\n\n        [\n        { x: left, y: bottom },\n        { x: right, y: top }]];\n\n\n\n        return diagonals.some((diagonal) => {\n          const intersection = intersect(path, diagonal);\n          return intersection && pointInRect(intersection, p);\n        });\n      } };\n\n\n    // Inspired by http://paulbourke.net/geometry/pointlineplane/\n    function intersect(_ref, _ref2) {let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = _ref;let [{ x: x3, y: y3 }, { x: x4, y: y4 }] = _ref2;\n      const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n      // Lines are parallel\n      if (denominator === 0) {\n        return false;\n      }\n\n      const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n\n      if (ua < 0) {\n        return false;\n      }\n\n      // Return an object with the x and y coordinates of the intersection\n      return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };\n    }\n\n    function observeIntersection(targets, cb, options, intersecting) {if (intersecting === void 0) {intersecting = true;}\n      const observer = new IntersectionObserver(\n      intersecting ?\n      (entries, observer) => {\n        if (entries.some((entry) => entry.isIntersecting)) {\n          cb(entries, observer);\n        }\n      } :\n      cb,\n      options);\n\n      for (const el of toNodes(targets)) {\n        observer.observe(el);\n      }\n\n      return observer;\n    }\n\n    const hasResizeObserver = inBrowser && window.ResizeObserver;\n    function observeResize(targets, cb, options) {if (options === void 0) {options = { box: 'border-box' };}\n      if (hasResizeObserver) {\n        return observe(ResizeObserver, targets, cb, options);\n      }\n\n      // Fallback Safari < 13.1\n      initResizeListener();\n      listeners.add(cb);\n\n      return {\n        disconnect() {\n          listeners.delete(cb);\n        } };\n\n    }\n\n    let listeners;\n    function initResizeListener() {\n      if (listeners) {\n        return;\n      }\n\n      listeners = new Set();\n\n      // throttle 'resize'\n      let pendingResize;\n      const handleResize = () => {\n        if (pendingResize) {\n          return;\n        }\n        pendingResize = true;\n        fastdom.read(() => pendingResize = false);\n        for (const listener of listeners) {\n          listener();\n        }\n      };\n\n      on(window, 'load resize', handleResize);\n      on(document, 'loadedmetadata load', handleResize, true);\n    }\n\n    function observeMutation(targets, cb, options) {\n      return observe(MutationObserver, targets, cb, options);\n    }\n\n    function observe(Observer, targets, cb, options) {\n      const observer = new Observer(cb);\n      for (const el of toNodes(targets)) {\n        observer.observe(el, options);\n      }\n\n      return observer;\n    }\n\n    const strats = {};\n\n    strats.events =\n    strats.created =\n    strats.beforeConnect =\n    strats.connected =\n    strats.beforeDisconnect =\n    strats.disconnected =\n    strats.destroy =\n    concatStrat;\n\n    // args strategy\n    strats.args = function (parentVal, childVal) {\n      return childVal !== false && concatStrat(childVal || parentVal);\n    };\n\n    // update strategy\n    strats.update = function (parentVal, childVal) {\n      return sortBy$1(\n      concatStrat(parentVal, isFunction(childVal) ? { read: childVal } : childVal),\n      'order');\n\n    };\n\n    // property strategy\n    strats.props = function (parentVal, childVal) {\n      if (isArray(childVal)) {\n        const value = {};\n        for (const key of childVal) {\n          value[key] = String;\n        }\n        childVal = value;\n      }\n\n      return strats.methods(parentVal, childVal);\n    };\n\n    // extend strategy\n    strats.computed = strats.methods = function (parentVal, childVal) {\n      return childVal ? parentVal ? { ...parentVal, ...childVal } : childVal : parentVal;\n    };\n\n    // data strategy\n    strats.data = function (parentVal, childVal, vm) {\n      if (!vm) {\n        if (!childVal) {\n          return parentVal;\n        }\n\n        if (!parentVal) {\n          return childVal;\n        }\n\n        return function (vm) {\n          return mergeFnData(parentVal, childVal, vm);\n        };\n      }\n\n      return mergeFnData(parentVal, childVal, vm);\n    };\n\n    function mergeFnData(parentVal, childVal, vm) {\n      return strats.computed(\n      isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal,\n      isFunction(childVal) ? childVal.call(vm, vm) : childVal);\n\n    }\n\n    // concat strategy\n    function concatStrat(parentVal, childVal) {\n      parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;\n\n      return childVal ?\n      parentVal ?\n      parentVal.concat(childVal) :\n      isArray(childVal) ?\n      childVal :\n      [childVal] :\n      parentVal;\n    }\n\n    // default strategy\n    function defaultStrat(parentVal, childVal) {\n      return isUndefined(childVal) ? parentVal : childVal;\n    }\n\n    function mergeOptions(parent, child, vm) {\n      const options = {};\n\n      if (isFunction(child)) {\n        child = child.options;\n      }\n\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n\n      if (child.mixins) {\n        for (const mixin of child.mixins) {\n          parent = mergeOptions(parent, mixin, vm);\n        }\n      }\n\n      for (const key in parent) {\n        mergeKey(key);\n      }\n\n      for (const key in child) {\n        if (!hasOwn(parent, key)) {\n          mergeKey(key);\n        }\n      }\n\n      function mergeKey(key) {\n        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);\n      }\n\n      return options;\n    }\n\n    function parseOptions(options, args) {if (args === void 0) {args = [];}\n      try {\n        return options ?\n        startsWith(options, '{') ?\n        JSON.parse(options) :\n        args.length && !includes(options, ':') ?\n        { [args[0]]: options } :\n        options.split(';').reduce((options, option) => {\n          const [key, value] = option.split(/:(.*)/);\n          if (key && !isUndefined(value)) {\n            options[key.trim()] = value.trim();\n          }\n          return options;\n        }, {}) :\n        {};\n      } catch (e) {\n        return {};\n      }\n    }\n\n    function play(el) {\n      if (isIFrame(el)) {\n        call(el, { func: 'playVideo', method: 'play' });\n      }\n\n      if (isHTML5(el)) {\n        try {\n          el.play().catch(noop);\n        } catch (e) {\n          // noop\n        }\n      }\n    }\n\n    function pause(el) {\n      if (isIFrame(el)) {\n        call(el, { func: 'pauseVideo', method: 'pause' });\n      }\n\n      if (isHTML5(el)) {\n        el.pause();\n      }\n    }\n\n    function mute(el) {\n      if (isIFrame(el)) {\n        call(el, { func: 'mute', method: 'setVolume', value: 0 });\n      }\n\n      if (isHTML5(el)) {\n        el.muted = true;\n      }\n    }\n\n    function isVideo(el) {\n      return isHTML5(el) || isIFrame(el);\n    }\n\n    function isHTML5(el) {\n      return isTag(el, 'video');\n    }\n\n    function isIFrame(el) {\n      return isTag(el, 'iframe') && (isYoutube(el) || isVimeo(el));\n    }\n\n    function isYoutube(el) {\n      return !!el.src.match(\n      /\\/\\/.*?youtube(-nocookie)?\\.[a-z]+\\/(watch\\?v=[^&\\s]+|embed)|youtu\\.be\\/.*/);\n\n    }\n\n    function isVimeo(el) {\n      return !!el.src.match(/vimeo\\.com\\/video\\/.*/);\n    }\n\n    async function call(el, cmd) {\n      await enableApi(el);\n      post(el, cmd);\n    }\n\n    function post(el, cmd) {\n      try {\n        el.contentWindow.postMessage(JSON.stringify({ event: 'command', ...cmd }), '*');\n      } catch (e) {\n        // noop\n      }\n    }\n\n    const stateKey = '_ukPlayer';\n    let counter = 0;\n    function enableApi(el) {\n      if (el[stateKey]) {\n        return el[stateKey];\n      }\n\n      const youtube = isYoutube(el);\n      const vimeo = isVimeo(el);\n\n      const id = ++counter;\n      let poller;\n\n      return el[stateKey] = new Promise((resolve) => {\n        youtube &&\n        once(el, 'load', () => {\n          const listener = () => post(el, { event: 'listening', id });\n          poller = setInterval(listener, 100);\n          listener();\n        });\n\n        once(window, 'message', resolve, false, (_ref) => {let { data } = _ref;\n          try {\n            data = JSON.parse(data);\n            return (\n              data && (\n              youtube && data.id === id && data.event === 'onReady' ||\n              vimeo && Number(data.player_id) === id));\n\n          } catch (e) {\n            // noop\n          }\n        });\n\n        el.src = \"\" + el.src + (includes(el.src, '?') ? '&' : '?') + (\n        youtube ? 'enablejsapi=1' : \"api=1&player_id=\" + id);\n\n      }).then(() => clearInterval(poller));\n    }\n\n    function isInView(element, offsetTop, offsetLeft) {if (offsetTop === void 0) {offsetTop = 0;}if (offsetLeft === void 0) {offsetLeft = 0;}\n      if (!isVisible(element)) {\n        return false;\n      }\n\n      return intersectRect(\n      ...scrollParents(element).\n      map((parent) => {\n        const { top, left, bottom, right } = offsetViewport(parent);\n\n        return {\n          top: top - offsetTop,\n          left: left - offsetLeft,\n          bottom: bottom + offsetTop,\n          right: right + offsetLeft };\n\n      }).\n      concat(offset(element)));\n\n    }\n\n    function scrollTop(element, top) {\n      if (isWindow(element) || isDocument(element)) {\n        element = scrollingElement(element);\n      } else {\n        element = toNode(element);\n      }\n\n      if (isUndefined(top)) {\n        return element.scrollTop;\n      } else {\n        element.scrollTop = top;\n      }\n    }\n\n    function scrollIntoView(element, _temp) {let { offset: offsetBy = 0 } = _temp === void 0 ? {} : _temp;\n      const parents = isVisible(element) ? scrollParents(element) : [];\n      return parents.reduce(\n      (fn, scrollElement, i) => {\n        const { scrollTop, scrollHeight, offsetHeight } = scrollElement;\n        const viewport = offsetViewport(scrollElement);\n        const maxScroll = scrollHeight - viewport.height;\n        const { height: elHeight, top: elTop } = parents[i - 1] ?\n        offsetViewport(parents[i - 1]) :\n        offset(element);\n\n        let top = Math.ceil(elTop - viewport.top - offsetBy + scrollTop);\n\n        if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) {\n          top += offsetBy;\n        } else {\n          offsetBy = 0;\n        }\n\n        if (top > maxScroll) {\n          offsetBy -= top - maxScroll;\n          top = maxScroll;\n        } else if (top < 0) {\n          offsetBy -= top;\n          top = 0;\n        }\n\n        return () => scrollTo(scrollElement, top - scrollTop).then(fn);\n      },\n      () => Promise.resolve())();\n\n\n      function scrollTo(element, top) {\n        return new Promise((resolve) => {\n          const scroll = element.scrollTop;\n          const duration = getDuration(Math.abs(top));\n          const start = Date.now();\n\n          (function step() {\n            const percent = ease(clamp((Date.now() - start) / duration));\n\n            scrollTop(element, scroll + top * percent);\n\n            // scroll more if we have not reached our destination\n            if (percent === 1) {\n              resolve();\n            } else {\n              requestAnimationFrame(step);\n            }\n          })();\n        });\n      }\n\n      function getDuration(dist) {\n        return 40 * Math.pow(dist, 0.375);\n      }\n\n      function ease(k) {\n        return 0.5 * (1 - Math.cos(Math.PI * k));\n      }\n    }\n\n    function scrolledOver(element, startOffset, endOffset) {if (startOffset === void 0) {startOffset = 0;}if (endOffset === void 0) {endOffset = 0;}\n      if (!isVisible(element)) {\n        return 0;\n      }\n\n      const [scrollElement] = scrollParents(element, /auto|scroll/, true);\n      const { scrollHeight, scrollTop } = scrollElement;\n      const { height: viewportHeight } = offsetViewport(scrollElement);\n      const maxScroll = scrollHeight - viewportHeight;\n      const elementOffsetTop = offsetPosition(element)[0] - offsetPosition(scrollElement)[0];\n\n      const start = Math.max(0, elementOffsetTop - viewportHeight + startOffset);\n      const end = Math.min(maxScroll, elementOffsetTop + element.offsetHeight - endOffset);\n\n      return clamp((scrollTop - start) / (end - start));\n    }\n\n    function scrollParents(element, overflowRe, scrollable) {if (overflowRe === void 0) {overflowRe = /auto|scroll|hidden/;}if (scrollable === void 0) {scrollable = false;}\n      const scrollEl = scrollingElement(element);\n\n      let ancestors = parents(element).reverse();\n      ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1);\n\n      const fixedIndex = findIndex(ancestors, (el) => css(el, 'position') === 'fixed');\n      if (~fixedIndex) {\n        ancestors = ancestors.slice(fixedIndex);\n      }\n\n      return [scrollEl].\n      concat(\n      ancestors.filter(\n      (parent) =>\n      overflowRe.test(css(parent, 'overflow')) && (\n      !scrollable || parent.scrollHeight > offsetViewport(parent).height))).\n\n\n      reverse();\n    }\n\n    function offsetViewport(scrollElement) {\n      let viewportElement = getViewport$1(scrollElement);\n\n      // iOS 12 returns <body> as scrollingElement\n      if (viewportElement === scrollingElement(viewportElement)) {\n        viewportElement = document.documentElement;\n      }\n\n      let rect = offset(viewportElement);\n      for (let [prop, dir, start, end] of [\n      ['width', 'x', 'left', 'right'],\n      ['height', 'y', 'top', 'bottom']])\n      {\n        if (!isWindow(getViewport$1(viewportElement))) {\n          rect[start] += toFloat(css(viewportElement, \"border\" + ucfirst(start) + \"Width\"));\n        }\n        rect[prop] = rect[dir] = (\n        isWindow(viewportElement) ? scrollingElement(viewportElement) : viewportElement)[\"client\" +\n        ucfirst(prop)];\n        rect[end] = rect[prop] + rect[start];\n      }\n      return rect;\n    }\n\n    function scrollingElement(element) {\n      const {\n        document: { scrollingElement } } =\n      toWindow(element);\n      return scrollingElement;\n    }\n\n    function getViewport$1(scrollElement) {\n      return scrollElement === scrollingElement(scrollElement) ? window : scrollElement;\n    }\n\n    const dirs = [\n    ['width', 'x', 'left', 'right'],\n    ['height', 'y', 'top', 'bottom']];\n\n\n    function positionAt(element, target, options) {\n      options = {\n        attach: {\n          element: ['left', 'top'],\n          target: ['left', 'top'],\n          ...options.attach },\n\n        offset: [0, 0],\n        ...options };\n\n\n      const dim = options.flip ?\n      attachToWithFlip(element, target, options) :\n      attachTo(element, target, options);\n\n      offset(element, dim);\n    }\n\n    function attachTo(element, target, options) {\n      let { attach, offset: offsetBy } = {\n        attach: {\n          element: ['left', 'top'],\n          target: ['left', 'top'],\n          ...options.attach },\n\n        offset: [0, 0],\n        ...options };\n\n\n      const position = offset(element);\n      const targetOffset = offset(target);\n      for (const [i, [prop, dir, start, end]] of Object.entries(dirs)) {\n        position[start] = position[dir] =\n        targetOffset[start] +\n        moveBy(attach.target[i], end, targetOffset[prop]) -\n        moveBy(attach.element[i], end, position[prop]) +\n        +offsetBy[i];\n        position[end] = position[start] + position[prop];\n      }\n      return position;\n    }\n\n    function attachToWithFlip(element, target, options) {\n      const position = attachTo(element, target, options);\n      const targetDim = offset(target);\n\n      let {\n        flip,\n        attach: { element: elAttach, target: targetAttach },\n        offset: elOffset,\n        boundary,\n        viewport,\n        viewportPadding } =\n      options;\n\n      let viewports = scrollParents(element);\n      if (boundary === target) {\n        viewports = viewports.filter((viewport) => viewport !== boundary);\n      }\n      const [scrollElement] = viewports;\n      viewports.push(viewport);\n\n      const offsetPosition = { ...position };\n      for (const [i, [prop, dir, start, end]] of Object.entries(dirs)) {\n        if (flip !== true && !includes(flip, dir)) {\n          continue;\n        }\n\n        const willFlip =\n        !intersectLine(position, targetDim, i) && intersectLine(position, targetDim, 1 - i);\n\n        viewport = getIntersectionArea(...viewports.filter(Boolean).map(offsetViewport));\n\n        if (viewportPadding) {\n          viewport[start] += viewportPadding;\n          viewport[end] -= viewportPadding;\n        }\n\n        if (boundary && !willFlip && position[prop] <= offset(boundary)[prop]) {\n          viewport = getIntersectionArea(viewport, offset(boundary));\n        }\n\n        const isInStartBoundary = position[start] >= viewport[start];\n        const isInEndBoundary = position[end] <= viewport[end];\n\n        if (isInStartBoundary && isInEndBoundary) {\n          continue;\n        }\n\n        let offsetBy;\n\n        // Flip\n        if (willFlip) {\n          if (\n          elAttach[i] === end && isInStartBoundary ||\n          elAttach[i] === start && isInEndBoundary)\n          {\n            continue;\n          }\n\n          offsetBy =\n          (elAttach[i] === start ?\n          -position[prop] :\n          elAttach[i] === end ?\n          position[prop] :\n          0) + (\n          targetAttach[i] === start ?\n          targetDim[prop] :\n          targetAttach[i] === end ?\n          -targetDim[prop] :\n          0) -\n          elOffset[i] * 2;\n\n          if (\n          !isInScrollArea(\n          {\n            ...position,\n            [start]: position[start] + offsetBy,\n            [end]: position[end] + offsetBy },\n\n          scrollElement,\n          i))\n\n          {\n            if (isInScrollArea(position, scrollElement, i)) {\n              continue;\n            }\n\n            if (options.recursion) {\n              return false;\n            }\n\n            const newPos = attachToWithFlip(element, target, {\n              ...options,\n              attach: {\n                element: elAttach.map(flipDir).reverse(),\n                target: targetAttach.map(flipDir).reverse() },\n\n              offset: elOffset.reverse(),\n              flip: flip === true ? flip : [...flip, dirs[1 - i][1]],\n              recursion: true });\n\n\n            if (newPos && isInScrollArea(newPos, scrollElement, 1 - i)) {\n              return newPos;\n            }\n          }\n\n          // Move\n        } else {\n          offsetBy =\n          clamp(\n          clamp(position[start], viewport[start], viewport[end] - position[prop]),\n          targetDim[start] - position[prop] + elOffset[i],\n          targetDim[end] - elOffset[i]) -\n          position[start];\n        }\n\n        offsetPosition[start] = position[dir] = position[start] + offsetBy;\n        offsetPosition[end] += offsetBy;\n      }\n\n      return offsetPosition;\n    }\n\n    function moveBy(start, end, dim) {\n      return start === 'center' ? dim / 2 : start === end ? dim : 0;\n    }\n\n    function getIntersectionArea() {\n      let area = {};for (var _len = arguments.length, rects = new Array(_len), _key = 0; _key < _len; _key++) {rects[_key] = arguments[_key];}\n      for (const rect of rects) {\n        for (const [,, start, end] of dirs) {\n          area[start] = Math.max(area[start] || 0, rect[start]);\n          area[end] = Math.min(...[area[end], rect[end]].filter(Boolean));\n        }\n      }\n      return area;\n    }\n\n    function isInScrollArea(position, scrollElement, dir) {\n      const viewport = offsetViewport(scrollElement);\n      const [prop,, start, end] = dirs[dir];\n      viewport[start] -= scrollElement[\"scroll\" + ucfirst(start)];\n      viewport[end] = viewport[start] + scrollElement[\"scroll\" + ucfirst(prop)];\n\n      return position[start] >= viewport[start] && position[end] <= viewport[end];\n    }\n\n    function intersectLine(dimA, dimB, dir) {\n      const [,, start, end] = dirs[dir];\n      return dimA[end] > dimB[start] && dimB[end] > dimA[start];\n    }\n\n    function flipDir(prop) {\n      for (let i = 0; i < dirs.length; i++) {\n        const index = dirs[i].indexOf(prop);\n        if (~index) {\n          return dirs[1 - i][index % 2 + 2];\n        }\n      }\n    }\n\n    var util = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        ajax: ajax,\n        getImage: getImage,\n        transition: transition,\n        Transition: Transition,\n        animate: animate$1,\n        Animation: Animation,\n        attr: attr,\n        hasAttr: hasAttr,\n        removeAttr: removeAttr,\n        data: data,\n        addClass: addClass,\n        removeClass: removeClass,\n        removeClasses: removeClasses,\n        replaceClass: replaceClass,\n        hasClass: hasClass,\n        toggleClass: toggleClass,\n        dimensions: dimensions$1,\n        offset: offset,\n        position: position,\n        offsetPosition: offsetPosition,\n        height: height,\n        width: width,\n        boxModelAdjust: boxModelAdjust,\n        flipPosition: flipPosition,\n        toPx: toPx,\n        ready: ready,\n        isTag: isTag,\n        empty: empty,\n        html: html,\n        replaceChildren: replaceChildren,\n        prepend: prepend,\n        append: append,\n        before: before,\n        after: after,\n        remove: remove$1,\n        wrapAll: wrapAll,\n        wrapInner: wrapInner,\n        unwrap: unwrap,\n        fragment: fragment,\n        apply: apply,\n        $: $,\n        $$: $$,\n        inBrowser: inBrowser,\n        isRtl: isRtl,\n        hasTouch: hasTouch,\n        pointerDown: pointerDown,\n        pointerMove: pointerMove,\n        pointerUp: pointerUp,\n        pointerEnter: pointerEnter,\n        pointerLeave: pointerLeave,\n        pointerCancel: pointerCancel,\n        on: on,\n        off: off,\n        once: once,\n        trigger: trigger,\n        createEvent: createEvent,\n        toEventTargets: toEventTargets,\n        isTouch: isTouch,\n        getEventPos: getEventPos,\n        fastdom: fastdom,\n        isVoidElement: isVoidElement,\n        isVisible: isVisible,\n        selInput: selInput,\n        isInput: isInput,\n        selFocusable: selFocusable,\n        isFocusable: isFocusable,\n        parent: parent,\n        filter: filter$1,\n        matches: matches,\n        closest: closest,\n        within: within,\n        parents: parents,\n        children: children,\n        index: index,\n        hasOwn: hasOwn,\n        hyphenate: hyphenate,\n        camelize: camelize,\n        ucfirst: ucfirst,\n        startsWith: startsWith,\n        endsWith: endsWith,\n        includes: includes,\n        findIndex: findIndex,\n        isArray: isArray,\n        toArray: toArray,\n        assign: assign,\n        isFunction: isFunction,\n        isObject: isObject,\n        isPlainObject: isPlainObject,\n        isWindow: isWindow,\n        isDocument: isDocument,\n        isNode: isNode,\n        isElement: isElement,\n        isBoolean: isBoolean,\n        isString: isString,\n        isNumber: isNumber,\n        isNumeric: isNumeric,\n        isEmpty: isEmpty,\n        isUndefined: isUndefined,\n        toBoolean: toBoolean,\n        toNumber: toNumber,\n        toFloat: toFloat,\n        toNode: toNode,\n        toNodes: toNodes,\n        toWindow: toWindow,\n        isEqual: isEqual,\n        swap: swap,\n        last: last,\n        each: each,\n        sortBy: sortBy$1,\n        uniqueBy: uniqueBy,\n        clamp: clamp,\n        noop: noop,\n        intersectRect: intersectRect,\n        pointInRect: pointInRect,\n        Dimensions: Dimensions,\n        getIndex: getIndex,\n        memoize: memoize,\n        Deferred: Deferred,\n        MouseTracker: MouseTracker,\n        observeIntersection: observeIntersection,\n        observeResize: observeResize,\n        observeMutation: observeMutation,\n        mergeOptions: mergeOptions,\n        parseOptions: parseOptions,\n        play: play,\n        pause: pause,\n        mute: mute,\n        isVideo: isVideo,\n        positionAt: positionAt,\n        query: query,\n        queryAll: queryAll,\n        find: find,\n        findAll: findAll,\n        escape: escape,\n        css: css,\n        getCssVar: getCssVar,\n        propName: propName,\n        isInView: isInView,\n        scrollTop: scrollTop,\n        scrollIntoView: scrollIntoView,\n        scrolledOver: scrolledOver,\n        scrollParents: scrollParents,\n        offsetViewport: offsetViewport\n    });\n\n    function globalAPI (UIkit) {\n      const DATA = UIkit.data;\n\n      UIkit.use = function (plugin) {\n        if (plugin.installed) {\n          return;\n        }\n\n        plugin.call(null, this);\n        plugin.installed = true;\n\n        return this;\n      };\n\n      UIkit.mixin = function (mixin, component) {\n        component = (isString(component) ? UIkit.component(component) : component) || this;\n        component.options = mergeOptions(component.options, mixin);\n      };\n\n      UIkit.extend = function (options) {\n        options = options || {};\n\n        const Super = this;\n        const Sub = function UIkitComponent(options) {\n          this._init(options);\n        };\n\n        Sub.prototype = Object.create(Super.prototype);\n        Sub.prototype.constructor = Sub;\n        Sub.options = mergeOptions(Super.options, options);\n\n        Sub.super = Super;\n        Sub.extend = Super.extend;\n\n        return Sub;\n      };\n\n      UIkit.update = function (element, e) {\n        element = element ? toNode(element) : document.body;\n\n        for (const parentEl of parents(element).reverse()) {\n          update(parentEl[DATA], e);\n        }\n\n        apply(element, (element) => update(element[DATA], e));\n      };\n\n      let container;\n      Object.defineProperty(UIkit, 'container', {\n        get() {\n          return container || document.body;\n        },\n\n        set(element) {\n          container = $(element);\n        } });\n\n\n      function update(data, e) {\n        if (!data) {\n          return;\n        }\n\n        for (const name in data) {\n          if (data[name]._connected) {\n            data[name]._callUpdate(e);\n          }\n        }\n      }\n    }\n\n    function hooksAPI (UIkit) {\n      UIkit.prototype._callHook = function (hook) {var _this$$options$hook;\n        (_this$$options$hook = this.$options[hook]) == null ? void 0 : _this$$options$hook.forEach((handler) => handler.call(this));\n      };\n\n      UIkit.prototype._callConnected = function () {\n        if (this._connected) {\n          return;\n        }\n\n        this._data = {};\n        this._computed = {};\n\n        this._initProps();\n\n        this._callHook('beforeConnect');\n        this._connected = true;\n\n        this._initEvents();\n        this._initObservers();\n\n        this._callHook('connected');\n        this._callUpdate();\n      };\n\n      UIkit.prototype._callDisconnected = function () {\n        if (!this._connected) {\n          return;\n        }\n\n        this._callHook('beforeDisconnect');\n        this._disconnectObservers();\n        this._unbindEvents();\n        this._callHook('disconnected');\n\n        this._connected = false;\n        delete this._watch;\n      };\n\n      UIkit.prototype._callUpdate = function (e) {if (e === void 0) {e = 'update';}\n        if (!this._connected) {\n          return;\n        }\n\n        if (e === 'update' || e === 'resize') {\n          this._callWatches();\n        }\n\n        if (!this.$options.update) {\n          return;\n        }\n\n        if (!this._updates) {\n          this._updates = new Set();\n          fastdom.read(() => {\n            if (this._connected) {\n              runUpdates.call(this, this._updates);\n            }\n            delete this._updates;\n          });\n        }\n\n        this._updates.add(e.type || e);\n      };\n\n      UIkit.prototype._callWatches = function () {\n        if (this._watch) {\n          return;\n        }\n\n        const initial = !hasOwn(this, '_watch');\n\n        this._watch = fastdom.read(() => {\n          if (this._connected) {\n            runWatches.call(this, initial);\n          }\n          this._watch = null;\n        });\n      };\n\n      function runUpdates(types) {\n        for (const { read, write, events = [] } of this.$options.update) {\n          if (!types.has('update') && !events.some((type) => types.has(type))) {\n            continue;\n          }\n\n          let result;\n          if (read) {\n            result = read.call(this, this._data, types);\n\n            if (result && isPlainObject(result)) {\n              assign(this._data, result);\n            }\n          }\n\n          if (write && result !== false) {\n            fastdom.write(() => write.call(this, this._data, types));\n          }\n        }\n      }\n\n      function runWatches(initial) {\n        const {\n          $options: { computed } } =\n        this;\n        const values = { ...this._computed };\n        this._computed = {};\n\n        for (const key in computed) {\n          const { watch, immediate } = computed[key];\n          if (\n          watch && (\n          initial && immediate ||\n          hasOwn(values, key) && !isEqual(values[key], this[key])))\n          {\n            watch.call(this, this[key], values[key]);\n          }\n        }\n      }\n    }\n\n    function stateAPI (UIkit) {\n      let uid = 0;\n\n      UIkit.prototype._init = function (options) {\n        options = options || {};\n        options.data = normalizeData(options, this.constructor.options);\n\n        this.$options = mergeOptions(this.constructor.options, options, this);\n        this.$el = null;\n        this.$props = {};\n\n        this._uid = uid++;\n        this._initData();\n        this._initMethods();\n        this._initComputeds();\n        this._callHook('created');\n\n        if (options.el) {\n          this.$mount(options.el);\n        }\n      };\n\n      UIkit.prototype._initData = function () {\n        const { data = {} } = this.$options;\n\n        for (const key in data) {\n          this.$props[key] = this[key] = data[key];\n        }\n      };\n\n      UIkit.prototype._initMethods = function () {\n        const { methods } = this.$options;\n\n        if (methods) {\n          for (const key in methods) {\n            this[key] = methods[key].bind(this);\n          }\n        }\n      };\n\n      UIkit.prototype._initComputeds = function () {\n        const { computed } = this.$options;\n\n        this._computed = {};\n\n        if (computed) {\n          for (const key in computed) {\n            registerComputed(this, key, computed[key]);\n          }\n        }\n      };\n\n      UIkit.prototype._initProps = function (props) {\n        let key;\n\n        props = props || getProps$1(this.$options, this.$name);\n\n        for (key in props) {\n          if (!isUndefined(props[key])) {\n            this.$props[key] = props[key];\n          }\n        }\n\n        const exclude = [this.$options.computed, this.$options.methods];\n        for (key in this.$props) {\n          if (key in props && notIn(exclude, key)) {\n            this[key] = this.$props[key];\n          }\n        }\n      };\n\n      UIkit.prototype._initEvents = function () {\n        this._events = [];\n        for (const event of this.$options.events || []) {\n          if (hasOwn(event, 'handler')) {\n            registerEvent(this, event);\n          } else {\n            for (const key in event) {\n              registerEvent(this, event[key], key);\n            }\n          }\n        }\n      };\n\n      UIkit.prototype._unbindEvents = function () {\n        this._events.forEach((unbind) => unbind());\n        delete this._events;\n      };\n\n      UIkit.prototype._initObservers = function () {\n        this._observers = [initPropsObserver(this)];\n\n        if (this.$options.computed) {\n          this.registerObserver(initChildListObserver(this));\n        }\n      };\n\n      UIkit.prototype.registerObserver = function (observer) {\n        this._observers.push(observer);\n      };\n\n      UIkit.prototype._disconnectObservers = function () {\n        this._observers.forEach((observer) => observer == null ? void 0 : observer.disconnect());\n      };\n    }\n\n    function getProps$1(opts, name) {\n      const data$1 = {};\n      const { args = [], props = {}, el } = opts;\n\n      if (!props) {\n        return data$1;\n      }\n\n      for (const key in props) {\n        const prop = hyphenate(key);\n        let value = data(el, prop);\n\n        if (isUndefined(value)) {\n          continue;\n        }\n\n        value = props[key] === Boolean && value === '' ? true : coerce$1(props[key], value);\n\n        if (prop === 'target' && (!value || startsWith(value, '_'))) {\n          continue;\n        }\n\n        data$1[key] = value;\n      }\n\n      const options = parseOptions(data(el, name), args);\n\n      for (const key in options) {\n        const prop = camelize(key);\n        if (props[prop] !== undefined) {\n          data$1[prop] = coerce$1(props[prop], options[key]);\n        }\n      }\n\n      return data$1;\n    }\n\n    function registerComputed(component, key, cb) {\n      Object.defineProperty(component, key, {\n        enumerable: true,\n\n        get() {\n          const { _computed, $props, $el } = component;\n\n          if (!hasOwn(_computed, key)) {\n            _computed[key] = (cb.get || cb).call(component, $props, $el);\n          }\n\n          return _computed[key];\n        },\n\n        set(value) {\n          const { _computed } = component;\n\n          _computed[key] = cb.set ? cb.set.call(component, value) : value;\n\n          if (isUndefined(_computed[key])) {\n            delete _computed[key];\n          }\n        } });\n\n    }\n\n    function registerEvent(component, event, key) {\n      if (!isPlainObject(event)) {\n        event = { name: key, handler: event };\n      }\n\n      let { name, el, handler, capture, passive, delegate, filter, self } = event;\n      el = isFunction(el) ? el.call(component) : el || component.$el;\n\n      if (isArray(el)) {\n        el.forEach((el) => registerEvent(component, { ...event, el }, key));\n        return;\n      }\n\n      if (!el || filter && !filter.call(component)) {\n        return;\n      }\n\n      component._events.push(\n      on(\n      el,\n      name,\n      delegate ? isString(delegate) ? delegate : delegate.call(component) : null,\n      isString(handler) ? component[handler] : handler.bind(component),\n      { passive, capture, self }));\n\n\n    }\n\n    function notIn(options, key) {\n      return options.every((arr) => !arr || !hasOwn(arr, key));\n    }\n\n    function coerce$1(type, value) {\n      if (type === Boolean) {\n        return toBoolean(value);\n      } else if (type === Number) {\n        return toNumber(value);\n      } else if (type === 'list') {\n        return toList(value);\n      }\n\n      return type ? type(value) : value;\n    }\n\n    function toList(value) {\n      return isArray(value) ?\n      value :\n      isString(value) ?\n      value.\n      split(/,(?![^(]*\\))/).\n      map((value) => isNumeric(value) ? toNumber(value) : toBoolean(value.trim())) :\n      [value];\n    }\n\n    function normalizeData(_ref, _ref2) {let { data = {} } = _ref;let { args = [], props = {} } = _ref2;\n      if (isArray(data)) {\n        data = data.slice(0, args.length).reduce((data, value, index) => {\n          if (isPlainObject(value)) {\n            assign(data, value);\n          } else {\n            data[args[index]] = value;\n          }\n          return data;\n        }, {});\n      }\n\n      for (const key in data) {\n        if (isUndefined(data[key])) {\n          delete data[key];\n        } else if (props[key]) {\n          data[key] = coerce$1(props[key], data[key]);\n        }\n      }\n\n      return data;\n    }\n\n    function initChildListObserver(component) {\n      const { el } = component.$options;\n\n      const observer = new MutationObserver(() => component.$emit());\n      observer.observe(el, {\n        childList: true,\n        subtree: true });\n\n\n      return observer;\n    }\n\n    function initPropsObserver(component) {\n      const { $name, $options, $props } = component;\n      const { attrs, props, el } = $options;\n\n      if (!props || attrs === false) {\n        return;\n      }\n\n      const attributes = isArray(attrs) ? attrs : Object.keys(props);\n      const filter = attributes.map((key) => hyphenate(key)).concat($name);\n\n      const observer = new MutationObserver((records) => {\n        const data = getProps$1($options, $name);\n        if (\n        records.some((_ref3) => {let { attributeName } = _ref3;\n          const prop = attributeName.replace('data-', '');\n          return (\n          prop === $name ? attributes : [camelize(prop), camelize(attributeName)]).\n          some((prop) => !isUndefined(data[prop]) && data[prop] !== $props[prop]);\n        }))\n        {\n          component.$reset();\n        }\n      });\n\n      observer.observe(el, {\n        attributes: true,\n        attributeFilter: filter.concat(filter.map((key) => \"data-\" + key)) });\n\n\n      return observer;\n    }\n\n    function instanceAPI (UIkit) {\n      const DATA = UIkit.data;\n\n      UIkit.prototype.$create = function (component, element, data) {\n        return UIkit[component](element, data);\n      };\n\n      UIkit.prototype.$mount = function (el) {\n        const { name } = this.$options;\n\n        if (!el[DATA]) {\n          el[DATA] = {};\n        }\n\n        if (el[DATA][name]) {\n          return;\n        }\n\n        el[DATA][name] = this;\n\n        this.$el = this.$options.el = this.$options.el || el;\n\n        if (within(el, document)) {\n          this._callConnected();\n        }\n      };\n\n      UIkit.prototype.$reset = function () {\n        this._callDisconnected();\n        this._callConnected();\n      };\n\n      UIkit.prototype.$destroy = function (removeEl) {if (removeEl === void 0) {removeEl = false;}\n        const { el, name } = this.$options;\n\n        if (el) {\n          this._callDisconnected();\n        }\n\n        this._callHook('destroy');\n\n        if (!(el != null && el[DATA])) {\n          return;\n        }\n\n        delete el[DATA][name];\n\n        if (!isEmpty(el[DATA])) {\n          delete el[DATA];\n        }\n\n        if (removeEl) {\n          remove$1(this.$el);\n        }\n      };\n\n      UIkit.prototype.$emit = function (e) {\n        this._callUpdate(e);\n      };\n\n      UIkit.prototype.$update = function (element, e) {if (element === void 0) {element = this.$el;}\n        UIkit.update(element, e);\n      };\n\n      UIkit.prototype.$getComponent = UIkit.getComponent;\n\n      const componentName = memoize((name) => UIkit.prefix + hyphenate(name));\n      Object.defineProperties(UIkit.prototype, {\n        $container: Object.getOwnPropertyDescriptor(UIkit, 'container'),\n\n        $name: {\n          get() {\n            return componentName(this.$options.name);\n          } } });\n\n\n    }\n\n    function componentAPI (UIkit) {\n      const DATA = UIkit.data;\n\n      const components = {};\n\n      UIkit.component = function (name, options) {\n        const id = hyphenate(name);\n\n        name = camelize(id);\n\n        if (!options) {\n          if (isPlainObject(components[name])) {\n            components[name] = UIkit.extend(components[name]);\n          }\n\n          return components[name];\n        }\n\n        UIkit[name] = function (element, data) {\n          const component = UIkit.component(name);\n\n          return component.options.functional ?\n          new component({ data: isPlainObject(element) ? element : [...arguments] }) :\n          element ?\n          $$(element).map(init)[0] :\n          init();\n\n          function init(element) {\n            const instance = UIkit.getComponent(element, name);\n\n            if (instance) {\n              if (data) {\n                instance.$destroy();\n              } else {\n                return instance;\n              }\n            }\n\n            return new component({ el: element, data });\n          }\n        };\n\n        const opt = isPlainObject(options) ? { ...options } : options.options;\n\n        opt.name = name;\n\n        opt.install == null ? void 0 : opt.install(UIkit, opt, name);\n\n        if (UIkit._initialized && !opt.functional) {\n          fastdom.read(() => UIkit[name](\"[uk-\" + id + \"],[data-uk-\" + id + \"]\"));\n        }\n\n        return components[name] = isPlainObject(options) ? opt : options;\n      };\n\n      UIkit.getComponents = (element) => (element == null ? void 0 : element[DATA]) || {};\n      UIkit.getComponent = (element, name) => UIkit.getComponents(element)[name];\n\n      UIkit.connect = (node) => {\n        if (node[DATA]) {\n          for (const name in node[DATA]) {\n            node[DATA][name]._callConnected();\n          }\n        }\n\n        for (const attribute of node.attributes) {\n          const name = getComponentName(attribute.name);\n\n          if (name && name in components) {\n            UIkit[name](node);\n          }\n        }\n      };\n\n      UIkit.disconnect = (node) => {\n        for (const name in node[DATA]) {\n          node[DATA][name]._callDisconnected();\n        }\n      };\n    }\n\n    const getComponentName = memoize((attribute) => {\n      return startsWith(attribute, 'uk-') || startsWith(attribute, 'data-uk-') ?\n      camelize(attribute.replace('data-uk-', '').replace('uk-', '')) :\n      false;\n    });\n\n    const UIkit = function (options) {\n      this._init(options);\n    };\n\n    UIkit.util = util;\n    UIkit.data = '__uikit__';\n    UIkit.prefix = 'uk-';\n    UIkit.options = {};\n    UIkit.version = '3.14.1';\n\n    globalAPI(UIkit);\n    hooksAPI(UIkit);\n    stateAPI(UIkit);\n    componentAPI(UIkit);\n    instanceAPI(UIkit);\n\n    function boot (UIkit) {\n      const { connect, disconnect } = UIkit;\n\n      if (!inBrowser || !window.MutationObserver) {\n        return;\n      }\n\n      fastdom.read(function () {\n        if (document.body) {\n          apply(document.body, connect);\n        }\n\n        new MutationObserver((records) => records.forEach(applyChildListMutation)).observe(\n        document,\n        {\n          childList: true,\n          subtree: true });\n\n\n\n        new MutationObserver((records) => records.forEach(applyAttributeMutation)).observe(\n        document,\n        {\n          attributes: true,\n          subtree: true });\n\n\n\n        UIkit._initialized = true;\n      });\n\n      function applyChildListMutation(_ref) {let { addedNodes, removedNodes } = _ref;\n        for (const node of addedNodes) {\n          apply(node, connect);\n        }\n\n        for (const node of removedNodes) {\n          apply(node, disconnect);\n        }\n      }\n\n      function applyAttributeMutation(_ref2) {var _UIkit$getComponent;let { target, attributeName } = _ref2;\n        const name = getComponentName(attributeName);\n\n        if (!name || !(name in UIkit)) {\n          return;\n        }\n\n        if (hasAttr(target, attributeName)) {\n          UIkit[name](target);\n          return;\n        }\n\n        (_UIkit$getComponent = UIkit.getComponent(target, name)) == null ? void 0 : _UIkit$getComponent.$destroy();\n      }\n    }\n\n    var Class = {\n      connected() {\n        !hasClass(this.$el, this.$name) && addClass(this.$el, this.$name);\n      } };\n\n    var Lazyload = {\n      methods: {\n        lazyload(observeTargets, targets) {if (observeTargets === void 0) {observeTargets = this.$el;}if (targets === void 0) {targets = this.$el;}\n          this.registerObserver(\n          observeIntersection(observeTargets, (entries, observer) => {\n            for (const el of toNodes(isFunction(targets) ? targets() : targets)) {\n              $$('[loading=\"lazy\"]', el).forEach((el) => removeAttr(el, 'loading'));\n            }\n            for (const el of entries.\n            filter((_ref) => {let { isIntersecting } = _ref;return isIntersecting;}).\n            map((_ref2) => {let { target } = _ref2;return target;})) {\n              observer.unobserve(el);\n            }\n          }));\n\n        } } };\n\n    var Togglable = {\n      props: {\n        cls: Boolean,\n        animation: 'list',\n        duration: Number,\n        velocity: Number,\n        origin: String,\n        transition: String },\n\n\n      data: {\n        cls: false,\n        animation: [false],\n        duration: 200,\n        velocity: 0.2,\n        origin: false,\n        transition: 'ease',\n        clsEnter: 'uk-togglabe-enter',\n        clsLeave: 'uk-togglabe-leave',\n\n        initProps: {\n          overflow: '',\n          height: '',\n          paddingTop: '',\n          paddingBottom: '',\n          marginTop: '',\n          marginBottom: '',\n          boxShadow: '' },\n\n\n        hideProps: {\n          overflow: 'hidden',\n          height: 0,\n          paddingTop: 0,\n          paddingBottom: 0,\n          marginTop: 0,\n          marginBottom: 0,\n          boxShadow: 'none' } },\n\n\n\n      computed: {\n        hasAnimation(_ref) {let { animation } = _ref;\n          return !!animation[0];\n        },\n\n        hasTransition(_ref2) {let { animation } = _ref2;\n          return this.hasAnimation && animation[0] === true;\n        } },\n\n\n      methods: {\n        toggleElement(targets, toggle, animate) {\n          return new Promise((resolve) =>\n          Promise.all(\n          toNodes(targets).map((el) => {\n            const show = isBoolean(toggle) ? toggle : !this.isToggled(el);\n\n            if (!trigger(el, \"before\" + (show ? 'show' : 'hide'), [this])) {\n              return Promise.reject();\n            }\n\n            const promise = (\n            isFunction(animate) ?\n            animate :\n            animate === false || !this.hasAnimation ?\n            this._toggle :\n            this.hasTransition ?\n            toggleHeight(this) :\n            toggleAnimation(this))(\n            el, show);\n\n            const cls = show ? this.clsEnter : this.clsLeave;\n\n            addClass(el, cls);\n\n            trigger(el, show ? 'show' : 'hide', [this]);\n\n            const done = () => {\n              removeClass(el, cls);\n              trigger(el, show ? 'shown' : 'hidden', [this]);\n              this.$update(el);\n            };\n\n            return promise ?\n            promise.then(done, () => {\n              removeClass(el, cls);\n              return Promise.reject();\n            }) :\n            done();\n          })).\n          then(resolve, noop));\n\n        },\n\n        isToggled(el) {if (el === void 0) {el = this.$el;}\n          [el] = toNodes(el);\n          return hasClass(el, this.clsEnter) ?\n          true :\n          hasClass(el, this.clsLeave) ?\n          false :\n          this.cls ?\n          hasClass(el, this.cls.split(' ')[0]) :\n          isVisible(el);\n        },\n\n        _toggle(el, toggled) {\n          if (!el) {\n            return;\n          }\n\n          toggled = Boolean(toggled);\n\n          let changed;\n          if (this.cls) {\n            changed = includes(this.cls, ' ') || toggled !== hasClass(el, this.cls);\n            changed && toggleClass(el, this.cls, includes(this.cls, ' ') ? undefined : toggled);\n          } else {\n            changed = toggled === el.hidden;\n            changed && (el.hidden = !toggled);\n          }\n\n          $$('[autofocus]', el).some((el) => isVisible(el) ? el.focus() || true : el.blur());\n\n          if (changed) {\n            trigger(el, 'toggled', [toggled, this]);\n            this.$update(el);\n          }\n        } } };\n\n\n\n    function toggleHeight(_ref3)\n\n\n\n\n\n\n\n    {let { isToggled, duration, velocity, initProps, hideProps, transition, _toggle } = _ref3;\n      return (el, show) => {\n        const inProgress = Transition.inProgress(el);\n        const inner = el.hasChildNodes() ?\n        toFloat(css(el.firstElementChild, 'marginTop')) +\n        toFloat(css(el.lastElementChild, 'marginBottom')) :\n        0;\n        const currentHeight = isVisible(el) ? height(el) + (inProgress ? 0 : inner) : 0;\n\n        Transition.cancel(el);\n\n        if (!isToggled(el)) {\n          _toggle(el, true);\n        }\n\n        height(el, '');\n\n        // Update child components first\n        fastdom.flush();\n\n        const endHeight = height(el) + (inProgress ? 0 : inner);\n        duration = velocity * el.offsetHeight + duration;\n\n        height(el, currentHeight);\n\n        return (\n        show ?\n        Transition.start(\n        el,\n        { ...initProps, overflow: 'hidden', height: endHeight },\n        Math.round(duration * (1 - currentHeight / endHeight)),\n        transition) :\n\n        Transition.start(\n        el,\n        hideProps,\n        Math.round(duration * (currentHeight / endHeight)),\n        transition).\n        then(() => _toggle(el, false))).\n        then(() => css(el, initProps));\n      };\n    }\n\n    function toggleAnimation(cmp) {\n      return (el, show) => {\n        Animation.cancel(el);\n\n        const { animation, duration, _toggle } = cmp;\n\n        if (show) {\n          _toggle(el, true);\n          return Animation.in(el, animation[0], duration, cmp.origin);\n        }\n\n        return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then(() =>\n        _toggle(el, false));\n\n      };\n    }\n\n    var Accordion = {\n      mixins: [Class, Lazyload, Togglable],\n\n      props: {\n        targets: String,\n        active: null,\n        collapsible: Boolean,\n        multiple: Boolean,\n        toggle: String,\n        content: String,\n        offset: Number },\n\n\n      data: {\n        targets: '> *',\n        active: false,\n        animation: [true],\n        collapsible: true,\n        multiple: false,\n        clsOpen: 'uk-open',\n        toggle: '> .uk-accordion-title',\n        content: '> .uk-accordion-content',\n        offset: 0 },\n\n\n      computed: {\n        items: {\n          get(_ref, $el) {let { targets } = _ref;\n            return $$(targets, $el);\n          },\n\n          watch(items, prev) {\n            if (prev || hasClass(items, this.clsOpen)) {\n              return;\n            }\n\n            const active =\n            this.active !== false && items[Number(this.active)] ||\n            !this.collapsible && items[0];\n\n            if (active) {\n              this.toggle(active, false);\n            }\n          },\n\n          immediate: true },\n\n\n        toggles(_ref2) {let { toggle } = _ref2;\n          return this.items.map((item) => $(toggle, item));\n        },\n\n        contents: {\n          get(_ref3) {let { content } = _ref3;\n            return this.items.map((item) => $(content, item));\n          },\n\n          watch(items) {\n            for (const el of items) {\n              hide(\n              el,\n              !hasClass(\n              this.items.find((item) => item.contains(el)),\n              this.clsOpen));\n\n\n            }\n          },\n\n          immediate: true } },\n\n\n\n      connected() {\n        this.lazyload();\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.targets + \" \" + this.$props.toggle;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.toggle(index(this.toggles, e.current));\n        } }],\n\n\n\n      methods: {\n        toggle(item, animate) {\n          let items = [this.items[getIndex(item, this.items)]];\n          const activeItems = filter$1(this.items, \".\" + this.clsOpen);\n\n          if (!this.multiple && !includes(activeItems, items[0])) {\n            items = items.concat(activeItems);\n          }\n\n          if (\n          !this.collapsible &&\n          activeItems.length < 2 &&\n          !filter$1(items, \":not(.\" + this.clsOpen + \")\").length)\n          {\n            return;\n          }\n\n          for (const el of items) {\n            this.toggleElement(el, !hasClass(el, this.clsOpen), async (el, show) => {\n              toggleClass(el, this.clsOpen, show);\n              attr($(this.$props.toggle, el), 'aria-expanded', show);\n\n              const content = $(\"\" + (el._wrapper ? '> * ' : '') + this.content, el);\n\n              if (animate === false || !this.hasTransition) {\n                hide(content, !show);\n                return;\n              }\n\n              if (!el._wrapper) {\n                el._wrapper = wrapAll(content, \"<div\" + (show ? ' hidden' : '') + \">\");\n              }\n\n              hide(content, false);\n              await toggleHeight(this)(el._wrapper, show);\n              hide(content, !show);\n\n              delete el._wrapper;\n              unwrap(content);\n\n              if (show) {\n                const toggle = $(this.$props.toggle, el);\n                fastdom.read(() => {\n                  if (!isInView(toggle)) {\n                    scrollIntoView(toggle, { offset: this.offset });\n                  }\n                });\n              }\n            });\n          }\n        } } };\n\n\n\n    function hide(el, hide) {\n      el && (el.hidden = hide);\n    }\n\n    var alert = {\n      mixins: [Class, Togglable],\n\n      args: 'animation',\n\n      props: {\n        close: String },\n\n\n      data: {\n        animation: [true],\n        selClose: '.uk-alert-close',\n        duration: 150,\n        hideProps: { opacity: 0, ...Togglable.data.hideProps } },\n\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.selClose;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.close();\n        } }],\n\n\n\n      methods: {\n        async close() {\n          await this.toggleElement(this.$el);\n          this.$destroy(true);\n        } } };\n\n    var Video = {\n      args: 'autoplay',\n\n      props: {\n        automute: Boolean,\n        autoplay: Boolean },\n\n\n      data: {\n        automute: false,\n        autoplay: true },\n\n\n      connected() {\n        this.inView = this.autoplay === 'inview';\n\n        if (this.inView && !hasAttr(this.$el, 'preload')) {\n          this.$el.preload = 'none';\n        }\n\n        if (this.automute) {\n          mute(this.$el);\n        }\n\n        this.registerObserver(observeIntersection(this.$el, () => this.$emit(), {}, false));\n      },\n\n      update: {\n        read() {\n          if (!isVideo(this.$el)) {\n            return false;\n          }\n\n          return {\n            visible: isVisible(this.$el) && css(this.$el, 'visibility') !== 'hidden',\n            inView: this.inView && isInView(this.$el) };\n\n        },\n\n        write(_ref) {let { visible, inView } = _ref;\n          if (!visible || this.inView && !inView) {\n            pause(this.$el);\n          } else if (this.autoplay === true || this.inView && inView) {\n            play(this.$el);\n          }\n        } } };\n\n    var Resize = {\n      connected() {var _this$$options$resize;\n        this.registerObserver(\n        observeResize(((_this$$options$resize = this.$options.resizeTargets) == null ? void 0 : _this$$options$resize.call(this)) || this.$el, () =>\n        this.$emit('resize')));\n\n\n      } };\n\n    var cover = {\n      mixins: [Resize, Video],\n\n      props: {\n        width: Number,\n        height: Number },\n\n\n      data: {\n        automute: true },\n\n\n      events: {\n        'load loadedmetadata'() {\n          this.$emit('resize');\n        } },\n\n\n      resizeTargets() {\n        return [this.$el, parent(this.$el)];\n      },\n\n      update: {\n        read() {\n          const { ratio, cover } = Dimensions;\n          const { $el, width, height } = this;\n\n          let dim = { width, height };\n\n          if (!dim.width || !dim.height) {\n            const intrinsic = {\n              width: $el.naturalWidth || $el.videoWidth || $el.clientWidth,\n              height: $el.naturalHeight || $el.videoHeight || $el.clientHeight };\n\n\n            if (dim.width) {\n              dim = ratio(intrinsic, 'width', dim.width);\n            } else if (height) {\n              dim = ratio(intrinsic, 'height', dim.height);\n            } else {\n              dim = intrinsic;\n            }\n          }\n\n          const { offsetHeight: coverHeight, offsetWidth: coverWidth } =\n          getPositionedParent($el) || parent($el);\n          const coverDim = cover(dim, {\n            width: coverWidth + (coverWidth % 2 ? 1 : 0),\n            height: coverHeight + (coverHeight % 2 ? 1 : 0) });\n\n\n          if (!coverDim.width || !coverDim.height) {\n            return false;\n          }\n\n          return coverDim;\n        },\n\n        write(_ref) {let { height, width } = _ref;\n          css(this.$el, { height, width });\n        },\n\n        events: ['resize'] } };\n\n\n\n    function getPositionedParent(el) {\n      while (el = parent(el)) {\n        if (css(el, 'position') !== 'static') {\n          return el;\n        }\n      }\n    }\n\n    var Container = {\n      props: {\n        container: Boolean },\n\n\n      data: {\n        container: true },\n\n\n      computed: {\n        container(_ref) {let { container } = _ref;\n          return container === true && this.$container || container && $(container);\n        } } };\n\n    var Position = {\n      props: {\n        pos: String,\n        offset: null,\n        flip: Boolean },\n\n\n      data: {\n        pos: \"bottom-\" + (isRtl ? 'right' : 'left'),\n        flip: true,\n        offset: false,\n        viewportPadding: 10 },\n\n\n      connected() {\n        this.pos = this.$props.pos.split('-').concat('center').slice(0, 2);\n        this.axis = includes(['top', 'bottom'], this.pos[0]) ? 'y' : 'x';\n      },\n\n      methods: {\n        positionAt(element, target, boundary) {\n          const [dir, align] = this.pos;\n\n          let { offset: offset$1 } = this;\n          if (!isNumeric(offset$1)) {\n            const node = $(offset$1);\n            offset$1 = node ?\n            offset(node)[this.axis === 'x' ? 'left' : 'top'] -\n            offset(target)[this.axis === 'x' ? 'right' : 'bottom'] :\n            0;\n          }\n          offset$1 = toPx(offset$1) + toPx(getCssVar('position-offset', element));\n          offset$1 = [includes(['left', 'top'], dir) ? -offset$1 : +offset$1, 0];\n\n          const attach = {\n            element: [flipPosition(dir), align],\n            target: [dir, align] };\n\n\n          if (this.axis === 'y') {\n            for (const prop in attach) {\n              attach[prop] = attach[prop].reverse();\n            }\n            offset$1 = offset$1.reverse();\n          }\n\n          positionAt(element, target, {\n            attach,\n            offset: offset$1,\n            boundary,\n            viewportPadding: this.boundaryAlign ? 0 : this.viewportPadding,\n            flip: this.flip });\n\n        } } };\n\n    let active$1;\n\n    var drop = {\n      mixins: [Container, Lazyload, Position, Togglable],\n\n      args: 'pos',\n\n      props: {\n        mode: 'list',\n        toggle: Boolean,\n        boundary: Boolean,\n        boundaryAlign: Boolean,\n        delayShow: Number,\n        delayHide: Number,\n        display: String,\n        clsDrop: String },\n\n\n      data: {\n        mode: ['click', 'hover'],\n        toggle: '- *',\n        boundary: true,\n        boundaryAlign: false,\n        delayShow: 0,\n        delayHide: 800,\n        display: null,\n        clsDrop: false,\n        animation: ['uk-animation-fade'],\n        cls: 'uk-open',\n        container: false },\n\n\n      created() {\n        this.tracker = new MouseTracker();\n      },\n\n      beforeConnect() {\n        this.clsDrop = this.$props.clsDrop || \"uk-\" + this.$options.name;\n      },\n\n      connected() {\n        addClass(this.$el, this.clsDrop);\n\n        if (this.toggle && !this.target) {\n          this.target = this.$create('toggle', query(this.toggle, this.$el), {\n            target: this.$el,\n            mode: this.mode }).\n          $el;\n          attr(this.target, 'aria-haspopup', true);\n          this.lazyload(this.target);\n        }\n      },\n\n      disconnected() {\n        if (this.isActive()) {\n          active$1 = null;\n        }\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return \".\" + this.clsDrop + \"-close\";\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.hide(false);\n        } },\n\n\n      {\n        name: 'click',\n\n        delegate() {\n          return 'a[href^=\"#\"]';\n        },\n\n        handler(_ref) {let { defaultPrevented, current: { hash } } = _ref;\n          if (!defaultPrevented && hash && !within(hash, this.$el)) {\n            this.hide(false);\n          }\n        } },\n\n\n      {\n        name: 'beforescroll',\n\n        handler() {\n          this.hide(false);\n        } },\n\n\n      {\n        name: 'toggle',\n\n        self: true,\n\n        handler(e, toggle) {\n          e.preventDefault();\n\n          if (this.isToggled()) {\n            this.hide(false);\n          } else {\n            this.show(toggle == null ? void 0 : toggle.$el, false);\n          }\n        } },\n\n\n      {\n        name: 'toggleshow',\n\n        self: true,\n\n        handler(e, toggle) {\n          e.preventDefault();\n          this.show(toggle == null ? void 0 : toggle.$el);\n        } },\n\n\n      {\n        name: 'togglehide',\n\n        self: true,\n\n        handler(e) {\n          e.preventDefault();\n          if (!matches(this.$el, ':focus,:hover')) {\n            this.hide();\n          }\n        } },\n\n\n      {\n        name: pointerEnter + \" focusin\",\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          if (!isTouch(e)) {\n            this.clearTimers();\n          }\n        } },\n\n\n      {\n        name: pointerLeave + \" focusout\",\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          if (!isTouch(e) && e.relatedTarget) {\n            this.hide();\n          }\n        } },\n\n\n      {\n        name: 'toggled',\n\n        self: true,\n\n        handler(e, toggled) {\n          if (!toggled) {\n            return;\n          }\n\n          this.clearTimers();\n          this.position();\n        } },\n\n\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          active$1 = this;\n\n          this.tracker.init();\n\n          for (const handler of [\n          on(\n          document,\n          pointerDown,\n          (_ref2) => {let { target } = _ref2;return (\n              !within(target, this.$el) &&\n              once(\n              document,\n              pointerUp + \" \" + pointerCancel + \" scroll\",\n              (_ref3) => {let { defaultPrevented, type, target: newTarget } = _ref3;\n                if (\n                !defaultPrevented &&\n                type === pointerUp &&\n                target === newTarget &&\n                !(this.target && within(target, this.target)))\n                {\n                  this.hide(false);\n                }\n              },\n              true));}),\n\n\n\n          on(document, 'keydown', (e) => {\n            if (e.keyCode === 27) {\n              this.hide(false);\n            }\n          }),\n\n          ...(this.display === 'static' ?\n          [] :\n          (() => {\n            const handler = () => this.$emit();\n            return [\n            on(window, 'resize', handler),\n            on(document, 'scroll', handler, true),\n            (() => {\n              const observer = observeResize(\n              scrollParents(this.$el),\n              handler);\n\n              return () => observer.disconnect();\n            })()];\n\n          })())])\n          {\n            once(this.$el, 'hide', handler, { self: true });\n          }\n        } },\n\n\n      {\n        name: 'beforehide',\n\n        self: true,\n\n        handler() {\n          this.clearTimers();\n        } },\n\n\n      {\n        name: 'hide',\n\n        handler(_ref4) {let { target } = _ref4;\n          if (this.$el !== target) {\n            active$1 =\n            active$1 === null && within(target, this.$el) && this.isToggled() ?\n            this :\n            active$1;\n            return;\n          }\n\n          active$1 = this.isActive() ? null : active$1;\n          this.tracker.cancel();\n        } }],\n\n\n\n      update: {\n        write() {\n          if (this.isToggled() && !hasClass(this.$el, this.clsEnter)) {\n            this.position();\n          }\n        } },\n\n\n      methods: {\n        show(target, delay) {if (target === void 0) {target = this.target;}if (delay === void 0) {delay = true;}\n          if (this.isToggled() && target && this.target && target !== this.target) {\n            this.hide(false);\n          }\n\n          this.target = target;\n\n          this.clearTimers();\n\n          if (this.isActive()) {\n            return;\n          }\n\n          if (active$1) {\n            if (delay && active$1.isDelaying) {\n              this.showTimer = setTimeout(() => matches(target, ':hover') && this.show(), 10);\n              return;\n            }\n\n            let prev;\n            while (active$1 && prev !== active$1 && !within(this.$el, active$1.$el)) {\n              prev = active$1;\n              active$1.hide(false);\n            }\n          }\n\n          if (this.container && parent(this.$el) !== this.container) {\n            append(this.container, this.$el);\n          }\n\n          this.showTimer = setTimeout(\n          () => this.toggleElement(this.$el, true),\n          delay && this.delayShow || 0);\n\n        },\n\n        hide(delay) {if (delay === void 0) {delay = true;}\n          const hide = () => this.toggleElement(this.$el, false, false);\n\n          this.clearTimers();\n\n          this.isDelaying = getPositionedElements(this.$el).some((el) =>\n          this.tracker.movesTo(el));\n\n\n          if (delay && this.isDelaying) {\n            this.hideTimer = setTimeout(this.hide, 50);\n          } else if (delay && this.delayHide) {\n            this.hideTimer = setTimeout(hide, this.delayHide);\n          } else {\n            hide();\n          }\n        },\n\n        clearTimers() {\n          clearTimeout(this.showTimer);\n          clearTimeout(this.hideTimer);\n          this.showTimer = null;\n          this.hideTimer = null;\n          this.isDelaying = false;\n        },\n\n        isActive() {\n          return active$1 === this;\n        },\n\n        position() {\n          removeClass(this.$el, this.clsDrop + \"-stack\");\n          toggleClass(this.$el, this.clsDrop + \"-boundary\", this.boundaryAlign);\n\n          const boundary = query(this.boundary, this.$el);\n          const [scrollParent] = scrollParents(this.$el);\n          const scrollParentOffset = offsetViewport(scrollParent);\n          const boundaryOffset = boundary ? offset(boundary) : scrollParentOffset;\n\n          css(this.$el, 'maxWidth', '');\n          const maxWidth =\n          scrollParentOffset.width - (this.boundaryAlign ? 0 : 2 * this.viewportPadding);\n\n          if (this.pos[1] === 'justify') {\n            const prop = this.axis === 'y' ? 'width' : 'height';\n            const targetOffset = offset(this.target);\n            const alignTo = this.boundaryAlign ? boundaryOffset : targetOffset;\n            css(this.$el, prop, alignTo[prop]);\n          } else if (this.$el.offsetWidth > maxWidth) {\n            addClass(this.$el, this.clsDrop + \"-stack\");\n          }\n\n          css(this.$el, 'maxWidth', maxWidth);\n\n          this.positionAt(\n          this.$el,\n          boundary && this.boundaryAlign ? boundary : this.target,\n          boundary);\n\n        } } };\n\n\n\n    function getPositionedElements(el) {\n      const result = [];\n      apply(el, (el) => css(el, 'position') !== 'static' && result.push(el));\n      return result;\n    }\n\n    var formCustom = {\n      mixins: [Class],\n\n      args: 'target',\n\n      props: {\n        target: Boolean },\n\n\n      data: {\n        target: false },\n\n\n      computed: {\n        input(_, $el) {\n          return $(selInput, $el);\n        },\n\n        state() {\n          return this.input.nextElementSibling;\n        },\n\n        target(_ref, $el) {let { target } = _ref;\n          return (\n            target && (\n            target === true && parent(this.input) === $el && this.input.nextElementSibling ||\n            $(target, $el)));\n\n        } },\n\n\n      update() {var _input$files;\n        const { target, input } = this;\n\n        if (!target) {\n          return;\n        }\n\n        let option;\n        const prop = isInput(target) ? 'value' : 'textContent';\n        const prev = target[prop];\n        const value = (_input$files = input.files) != null && _input$files[0] ?\n        input.files[0].name :\n        matches(input, 'select') && (\n        option = $$('option', input).filter((el) => el.selected)[0]) // eslint-disable-line prefer-destructuring\n        ? option.textContent :\n        input.value;\n\n        if (prev !== value) {\n          target[prop] = value;\n        }\n      },\n\n      events: [\n      {\n        name: 'change',\n\n        handler() {\n          this.$emit();\n        } },\n\n\n      {\n        name: 'reset',\n\n        el() {\n          return closest(this.$el, 'form');\n        },\n\n        handler() {\n          this.$emit();\n        } }] };\n\n    var Margin = {\n      mixins: [Resize],\n\n      props: {\n        margin: String,\n        firstColumn: Boolean },\n\n\n      data: {\n        margin: 'uk-margin-small-top',\n        firstColumn: 'uk-first-column' },\n\n\n      resizeTargets() {\n        return [this.$el, ...toArray(this.$el.children)];\n      },\n\n      connected() {\n        this.registerObserver(\n        observeMutation(this.$el, () => this.$reset(), {\n          childList: true }));\n\n\n      },\n\n      update: {\n        read() {\n          const rows = getRows(this.$el.children);\n\n          return {\n            rows,\n            columns: getColumns(rows) };\n\n        },\n\n        write(_ref) {let { columns, rows } = _ref;\n          for (const row of rows) {\n            for (const column of row) {\n              toggleClass(column, this.margin, rows[0] !== row);\n              toggleClass(column, this.firstColumn, columns[0].includes(column));\n            }\n          }\n        },\n\n        events: ['resize'] } };\n\n\n\n    function getRows(items) {\n      return sortBy(items, 'top', 'bottom');\n    }\n\n    function getColumns(rows) {\n      const columns = [];\n\n      for (const row of rows) {\n        const sorted = sortBy(row, 'left', 'right');\n        for (let j = 0; j < sorted.length; j++) {\n          columns[j] = columns[j] ? columns[j].concat(sorted[j]) : sorted[j];\n        }\n      }\n\n      return isRtl ? columns.reverse() : columns;\n    }\n\n    function sortBy(items, startProp, endProp) {\n      const sorted = [[]];\n\n      for (const el of items) {\n        if (!isVisible(el)) {\n          continue;\n        }\n\n        let dim = getOffset(el);\n\n        for (let i = sorted.length - 1; i >= 0; i--) {\n          const current = sorted[i];\n\n          if (!current[0]) {\n            current.push(el);\n            break;\n          }\n\n          let startDim;\n          if (current[0].offsetParent === el.offsetParent) {\n            startDim = getOffset(current[0]);\n          } else {\n            dim = getOffset(el, true);\n            startDim = getOffset(current[0], true);\n          }\n\n          if (dim[startProp] >= startDim[endProp] - 1 && dim[startProp] !== startDim[startProp]) {\n            sorted.push([el]);\n            break;\n          }\n\n          if (dim[endProp] - 1 > startDim[startProp] || dim[startProp] === startDim[startProp]) {\n            current.push(el);\n            break;\n          }\n\n          if (i === 0) {\n            sorted.unshift([el]);\n            break;\n          }\n        }\n      }\n\n      return sorted;\n    }\n\n    function getOffset(element, offset) {if (offset === void 0) {offset = false;}\n      let { offsetTop, offsetLeft, offsetHeight, offsetWidth } = element;\n\n      if (offset) {\n        [offsetTop, offsetLeft] = offsetPosition(element);\n      }\n\n      return {\n        top: offsetTop,\n        left: offsetLeft,\n        bottom: offsetTop + offsetHeight,\n        right: offsetLeft + offsetWidth };\n\n    }\n\n    var Scroll = {\n      connected() {\n        registerScrollListener(this._uid, () => this.$emit('scroll'));\n      },\n\n      disconnected() {\n        unregisterScrollListener(this._uid);\n      } };\n\n\n    const scrollListeners = new Map();\n    let unbindScrollListener;\n    function registerScrollListener(id, listener) {\n      unbindScrollListener =\n      unbindScrollListener ||\n      on(window, 'scroll', () => scrollListeners.forEach((listener) => listener()), {\n        passive: true,\n        capture: true });\n\n\n      scrollListeners.set(id, listener);\n    }\n\n    function unregisterScrollListener(id) {\n      scrollListeners.delete(id);\n      if (unbindScrollListener && !scrollListeners.size) {\n        unbindScrollListener();\n        unbindScrollListener = null;\n      }\n    }\n\n    var grid = {\n      extends: Margin,\n\n      mixins: [Class, Scroll],\n\n      name: 'grid',\n\n      props: {\n        masonry: Boolean,\n        parallax: Number },\n\n\n      data: {\n        margin: 'uk-grid-margin',\n        clsStack: 'uk-grid-stack',\n        masonry: false,\n        parallax: 0 },\n\n\n      connected() {\n        this.masonry && addClass(this.$el, 'uk-flex-top uk-flex-wrap-top');\n      },\n\n      update: [\n      {\n        write(_ref) {let { columns } = _ref;\n          toggleClass(this.$el, this.clsStack, columns.length < 2);\n        },\n\n        events: ['resize'] },\n\n\n      {\n        read(data) {\n          let { columns, rows } = data;\n\n          // Filter component makes elements positioned absolute\n          if (\n          !columns.length ||\n          !this.masonry && !this.parallax ||\n          positionedAbsolute(this.$el))\n          {\n            data.translates = false;\n            return false;\n          }\n\n          let translates = false;\n\n          const nodes = children(this.$el);\n          const columnHeights = getColumnHeights(columns);\n          const margin = getMarginTop(nodes, this.margin) * (rows.length - 1);\n          const elHeight = Math.max(...columnHeights) + margin;\n\n          if (this.masonry) {\n            columns = columns.map((column) => sortBy$1(column, 'offsetTop'));\n            translates = getTranslates(rows, columns);\n          }\n\n          let padding = Math.abs(this.parallax);\n          if (padding) {\n            padding = columnHeights.reduce(\n            (newPadding, hgt, i) =>\n            Math.max(\n            newPadding,\n            hgt + margin + (i % 2 ? padding : padding / 8) - elHeight),\n\n            0);\n\n          }\n\n          return { padding, columns, translates, height: translates ? elHeight : '' };\n        },\n\n        write(_ref2) {let { height, padding } = _ref2;\n          css(this.$el, 'paddingBottom', padding || '');\n          height !== false && css(this.$el, 'height', height);\n        },\n\n        events: ['resize'] },\n\n\n      {\n        read() {\n          if (this.parallax && positionedAbsolute(this.$el)) {\n            return false;\n          }\n\n          return {\n            scrolled: this.parallax ?\n            scrolledOver(this.$el) * Math.abs(this.parallax) :\n            false };\n\n        },\n\n        write(_ref3) {let { columns, scrolled, translates } = _ref3;\n          if (scrolled === false && !translates) {\n            return;\n          }\n\n          columns.forEach((column, i) =>\n          column.forEach((el, j) =>\n          css(\n          el,\n          'transform',\n          !scrolled && !translates ?\n          '' : \"translateY(\" + (\n\n          (translates && -translates[i][j]) + (\n          scrolled ? i % 2 ? scrolled : scrolled / 8 : 0)) + \"px)\")));\n\n\n\n\n        },\n\n        events: ['scroll', 'resize'] }] };\n\n\n\n\n    function positionedAbsolute(el) {\n      return children(el).some((el) => css(el, 'position') === 'absolute');\n    }\n\n    function getTranslates(rows, columns) {\n      const rowHeights = rows.map((row) => Math.max(...row.map((el) => el.offsetHeight)));\n\n      return columns.map((elements) => {\n        let prev = 0;\n        return elements.map(\n        (element, row) =>\n        prev += row ? rowHeights[row - 1] - elements[row - 1].offsetHeight : 0);\n\n      });\n    }\n\n    function getMarginTop(nodes, cls) {\n      const [node] = nodes.filter((el) => hasClass(el, cls));\n\n      return toFloat(node ? css(node, 'marginTop') : css(nodes[0], 'paddingLeft'));\n    }\n\n    function getColumnHeights(columns) {\n      return columns.map((column) => column.reduce((sum, el) => sum + el.offsetHeight, 0));\n    }\n\n    var heightMatch = {\n      mixins: [Resize],\n\n      args: 'target',\n\n      props: {\n        target: String,\n        row: Boolean },\n\n\n      data: {\n        target: '> *',\n        row: true },\n\n\n      computed: {\n        elements: {\n          get(_ref, $el) {let { target } = _ref;\n            return $$(target, $el);\n          },\n\n          watch() {\n            this.$reset();\n          } } },\n\n\n\n      resizeTargets() {\n        return [this.$el, ...this.elements];\n      },\n\n      update: {\n        read() {\n          return {\n            rows: (this.row ? getRows(this.elements) : [this.elements]).map(match$1) };\n\n        },\n\n        write(_ref2) {let { rows } = _ref2;\n          for (const { heights, elements } of rows) {\n            elements.forEach((el, i) => css(el, 'minHeight', heights[i]));\n          }\n        },\n\n        events: ['resize'] } };\n\n\n\n    function match$1(elements) {\n      if (elements.length < 2) {\n        return { heights: [''], elements };\n      }\n\n      css(elements, 'minHeight', '');\n      let heights = elements.map(getHeight);\n      const max = Math.max(...heights);\n\n      return {\n        heights: elements.map((el, i) => heights[i].toFixed(2) === max.toFixed(2) ? '' : max),\n        elements };\n\n    }\n\n    function getHeight(element) {\n      let style = false;\n      if (!isVisible(element)) {\n        style = element.style.display;\n        css(element, 'display', 'block', 'important');\n      }\n\n      const height = dimensions$1(element).height - boxModelAdjust(element, 'height', 'content-box');\n\n      if (style !== false) {\n        css(element, 'display', style);\n      }\n\n      return height;\n    }\n\n    var heightViewport = {\n      mixins: [Class, Resize],\n\n      props: {\n        expand: Boolean,\n        offsetTop: Boolean,\n        offsetBottom: Boolean,\n        minHeight: Number },\n\n\n      data: {\n        expand: false,\n        offsetTop: false,\n        offsetBottom: false,\n        minHeight: 0 },\n\n\n      resizeTargets() {\n        // check for offsetTop change\n        return [this.$el, document.documentElement];\n      },\n\n      update: {\n        read(_ref) {let { minHeight: prev } = _ref;\n          if (!isVisible(this.$el)) {\n            return false;\n          }\n\n          let minHeight = '';\n          const box = boxModelAdjust(this.$el, 'height', 'content-box');\n\n          if (this.expand) {\n            minHeight = Math.max(\n            height(window) - (\n            dimensions$1(document.documentElement).height -\n            dimensions$1(this.$el).height) -\n            box,\n            0);\n\n          } else {\n            // on mobile devices (iOS and Android) window.innerHeight !== 100vh\n            minHeight = 'calc(100vh';\n\n            if (this.offsetTop) {\n              const { top } = offset(this.$el);\n              minHeight += top > 0 && top < height(window) / 2 ? \" - \" + top + \"px\" : '';\n            }\n\n            if (this.offsetBottom === true) {\n              minHeight += \" - \" + dimensions$1(this.$el.nextElementSibling).height + \"px\";\n            } else if (isNumeric(this.offsetBottom)) {\n              minHeight += \" - \" + this.offsetBottom + \"vh\";\n            } else if (this.offsetBottom && endsWith(this.offsetBottom, 'px')) {\n              minHeight += \" - \" + toFloat(this.offsetBottom) + \"px\";\n            } else if (isString(this.offsetBottom)) {\n              minHeight += \" - \" + dimensions$1(query(this.offsetBottom, this.$el)).height + \"px\";\n            }\n\n            minHeight += (box ? \" - \" + box + \"px\" : '') + \")\";\n          }\n\n          return { minHeight, prev };\n        },\n\n        write(_ref2) {let { minHeight } = _ref2;\n          css(this.$el, { minHeight });\n\n          if (this.minHeight && toFloat(css(this.$el, 'minHeight')) < this.minHeight) {\n            css(this.$el, 'minHeight', this.minHeight);\n          }\n        },\n\n        events: ['resize'] } };\n\n    var SVG = {\n      args: 'src',\n\n      props: {\n        id: Boolean,\n        icon: String,\n        src: String,\n        style: String,\n        width: Number,\n        height: Number,\n        ratio: Number,\n        class: String,\n        strokeAnimation: Boolean,\n        focusable: Boolean, // IE 11\n        attributes: 'list' },\n\n\n      data: {\n        ratio: 1,\n        include: ['style', 'class', 'focusable'],\n        class: '',\n        strokeAnimation: false },\n\n\n      beforeConnect() {\n        this.class += ' uk-svg';\n      },\n\n      connected() {\n        if (!this.icon && includes(this.src, '#')) {\n          [this.src, this.icon] = this.src.split('#');\n        }\n\n        this.svg = this.getSvg().then((el) => {\n          if (this._connected) {\n            const svg = insertSVG(el, this.$el);\n\n            if (this.svgEl && svg !== this.svgEl) {\n              remove$1(this.svgEl);\n            }\n\n            this.applyAttributes(svg, el);\n\n            return this.svgEl = svg;\n          }\n        }, noop);\n\n        if (this.strokeAnimation) {\n          this.svg.then((el) => {\n            if (this._connected) {\n              applyAnimation(el);\n              this.registerObserver(\n              observeIntersection(el, (records, observer) => {\n                applyAnimation(el);\n                observer.disconnect();\n              }));\n\n            }\n          });\n        }\n      },\n\n      disconnected() {\n        this.svg.then((svg) => {\n          if (this._connected) {\n            return;\n          }\n\n          if (isVoidElement(this.$el)) {\n            this.$el.hidden = false;\n          }\n\n          remove$1(svg);\n          this.svgEl = null;\n        });\n\n        this.svg = null;\n      },\n\n      methods: {\n        async getSvg() {\n          if (isTag(this.$el, 'img') && !this.$el.complete && this.$el.loading === 'lazy') {\n            return new Promise((resolve) =>\n            once(this.$el, 'load', () => resolve(this.getSvg())));\n\n          }\n\n          return parseSVG(await loadSVG(this.src), this.icon) || Promise.reject('SVG not found.');\n        },\n\n        applyAttributes(el, ref) {\n          for (const prop in this.$options.props) {\n            if (includes(this.include, prop) && prop in this) {\n              attr(el, prop, this[prop]);\n            }\n          }\n\n          for (const attribute in this.attributes) {\n            const [prop, value] = this.attributes[attribute].split(':', 2);\n            attr(el, prop, value);\n          }\n\n          if (!this.id) {\n            removeAttr(el, 'id');\n          }\n\n          const props = ['width', 'height'];\n          let dimensions = props.map((prop) => this[prop]);\n\n          if (!dimensions.some((val) => val)) {\n            dimensions = props.map((prop) => attr(ref, prop));\n          }\n\n          const viewBox = attr(ref, 'viewBox');\n          if (viewBox && !dimensions.some((val) => val)) {\n            dimensions = viewBox.split(' ').slice(2);\n          }\n\n          dimensions.forEach((val, i) => attr(el, props[i], toFloat(val) * this.ratio || null));\n        } } };\n\n\n\n    const loadSVG = memoize(async (src) => {\n      if (src) {\n        if (startsWith(src, 'data:')) {\n          return decodeURIComponent(src.split(',')[1]);\n        } else {\n          return (await fetch(src)).text();\n        }\n      } else {\n        return Promise.reject();\n      }\n    });\n\n    function parseSVG(svg, icon) {var _svg;\n      if (icon && includes(svg, '<symbol')) {\n        svg = parseSymbols(svg, icon) || svg;\n      }\n\n      svg = $(svg.substr(svg.indexOf('<svg')));\n      return ((_svg = svg) == null ? void 0 : _svg.hasChildNodes()) && svg;\n    }\n\n    const symbolRe = /<symbol([^]*?id=(['\"])(.+?)\\2[^]*?<\\/)symbol>/g;\n    const symbols = {};\n\n    function parseSymbols(svg, icon) {\n      if (!symbols[svg]) {\n        symbols[svg] = {};\n\n        symbolRe.lastIndex = 0;\n\n        let match;\n        while (match = symbolRe.exec(svg)) {\n          symbols[svg][match[3]] = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\" + match[1] + \"svg>\";\n        }\n      }\n\n      return symbols[svg][icon];\n    }\n\n    function applyAnimation(el) {\n      const length = getMaxPathLength(el);\n\n      if (length) {\n        el.style.setProperty('--uk-animation-stroke', length);\n      }\n    }\n\n    function getMaxPathLength(el) {\n      return Math.ceil(\n      Math.max(\n      0,\n      ...$$('[stroke]', el).map((stroke) => {\n        try {\n          return stroke.getTotalLength();\n        } catch (e) {\n          return 0;\n        }\n      })));\n\n\n    }\n\n    function insertSVG(el, root) {\n      if (isVoidElement(root) || isTag(root, 'canvas')) {\n        root.hidden = true;\n\n        const next = root.nextElementSibling;\n        return equals(el, next) ? next : after(root, el);\n      }\n\n      const last = root.lastElementChild;\n      return equals(el, last) ? last : append(root, el);\n    }\n\n    function equals(el, other) {\n      return isTag(el, 'svg') && isTag(other, 'svg') && innerHTML(el) === innerHTML(other);\n    }\n\n    function innerHTML(el) {\n      return (\n      el.innerHTML ||\n      new XMLSerializer().serializeToString(el).replace(/<svg.*?>(.*?)<\\/svg>/g, '$1')).\n      replace(/\\s/g, '');\n    }\n\n    var closeIcon = \"<svg width=\\\"14\\\" height=\\\"14\\\" viewBox=\\\"0 0 14 14\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"1\\\" y1=\\\"1\\\" x2=\\\"13\\\" y2=\\\"13\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"13\\\" y1=\\\"1\\\" x2=\\\"1\\\" y2=\\\"13\\\"/></svg>\";\n\n    var closeLarge = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" x1=\\\"1\\\" y1=\\\"1\\\" x2=\\\"19\\\" y2=\\\"19\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" x1=\\\"19\\\" y1=\\\"1\\\" x2=\\\"1\\\" y2=\\\"19\\\"/></svg>\";\n\n    var marker = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"9\\\" y=\\\"4\\\" width=\\\"1\\\" height=\\\"11\\\"/><rect x=\\\"4\\\" y=\\\"9\\\" width=\\\"11\\\" height=\\\"1\\\"/></svg>\";\n\n    var navbarToggleIcon = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect y=\\\"9\\\" width=\\\"20\\\" height=\\\"2\\\"/><rect y=\\\"3\\\" width=\\\"20\\\" height=\\\"2\\\"/><rect y=\\\"15\\\" width=\\\"20\\\" height=\\\"2\\\"/></svg>\";\n\n    var overlayIcon = \"<svg width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect x=\\\"19\\\" y=\\\"0\\\" width=\\\"1\\\" height=\\\"40\\\"/><rect x=\\\"0\\\" y=\\\"19\\\" width=\\\"40\\\" height=\\\"1\\\"/></svg>\";\n\n    var paginationNext = \"<svg width=\\\"7\\\" height=\\\"12\\\" viewBox=\\\"0 0 7 12\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"1 1 6 6 1 11\\\"/></svg>\";\n\n    var paginationPrevious = \"<svg width=\\\"7\\\" height=\\\"12\\\" viewBox=\\\"0 0 7 12\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"6 1 1 6 6 11\\\"/></svg>\";\n\n    var searchIcon = \"<svg width=\\\"20\\\" height=\\\"20\\\" viewBox=\\\"0 0 20 20\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"9\\\" cy=\\\"9\\\" r=\\\"7\\\"/><path fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" d=\\\"M14,14 L18,18 L14,14 Z\\\"/></svg>\";\n\n    var searchLarge = \"<svg width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"0 0 40 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.8\\\" cx=\\\"17.5\\\" cy=\\\"17.5\\\" r=\\\"16.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.8\\\" x1=\\\"38\\\" y1=\\\"39\\\" x2=\\\"29\\\" y2=\\\"30\\\"/></svg>\";\n\n    var searchNavbar = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" cx=\\\"10.5\\\" cy=\\\"10.5\\\" r=\\\"9.5\\\"/><line fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.1\\\" x1=\\\"23\\\" y1=\\\"23\\\" x2=\\\"17\\\" y2=\\\"17\\\"/></svg>\";\n\n    var slidenavNext = \"<svg width=\\\"14\\\" height=\\\"24\\\" viewBox=\\\"0 0 14 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" points=\\\"1.225,23 12.775,12 1.225,1 \\\"/></svg>\";\n\n    var slidenavNextLarge = \"<svg width=\\\"25\\\" height=\\\"40\\\" viewBox=\\\"0 0 25 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" points=\\\"4.002,38.547 22.527,20.024 4,1.5 \\\"/></svg>\";\n\n    var slidenavPrevious = \"<svg width=\\\"14\\\" height=\\\"24\\\" viewBox=\\\"0 0 14 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.4\\\" points=\\\"12.775,1 1.225,12 12.775,23 \\\"/></svg>\";\n\n    var slidenavPreviousLarge = \"<svg width=\\\"25\\\" height=\\\"40\\\" viewBox=\\\"0 0 25 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"2\\\" points=\\\"20.527,1.5 2,20.024 20.525,38.547 \\\"/></svg>\";\n\n    var spinner = \"<svg width=\\\"30\\\" height=\\\"30\\\" viewBox=\\\"0 0 30 30\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><circle fill=\\\"none\\\" stroke=\\\"#000\\\" cx=\\\"15\\\" cy=\\\"15\\\" r=\\\"14\\\"/></svg>\";\n\n    var totop = \"<svg width=\\\"18\\\" height=\\\"10\\\" viewBox=\\\"0 0 18 10\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><polyline fill=\\\"none\\\" stroke=\\\"#000\\\" stroke-width=\\\"1.2\\\" points=\\\"1 9 9 1 17 9 \\\"/></svg>\";\n\n    const icons = {\n      spinner,\n      totop,\n      marker,\n      'close-icon': closeIcon,\n      'close-large': closeLarge,\n      'navbar-toggle-icon': navbarToggleIcon,\n      'overlay-icon': overlayIcon,\n      'pagination-next': paginationNext,\n      'pagination-previous': paginationPrevious,\n      'search-icon': searchIcon,\n      'search-large': searchLarge,\n      'search-navbar': searchNavbar,\n      'slidenav-next': slidenavNext,\n      'slidenav-next-large': slidenavNextLarge,\n      'slidenav-previous': slidenavPrevious,\n      'slidenav-previous-large': slidenavPreviousLarge };\n\n\n    const Icon = {\n      install: install$3,\n\n      extends: SVG,\n\n      args: 'icon',\n\n      props: ['icon'],\n\n      data: {\n        include: ['focusable'] },\n\n\n      isIcon: true,\n\n      beforeConnect() {\n        addClass(this.$el, 'uk-icon');\n      },\n\n      methods: {\n        async getSvg() {\n          const icon = getIcon(this.icon);\n\n          if (!icon) {\n            throw 'Icon not found.';\n          }\n\n          return icon;\n        } } };\n\n    const IconComponent = {\n      args: false,\n\n      extends: Icon,\n\n      data: (vm) => ({\n        icon: hyphenate(vm.constructor.options.name) }),\n\n\n      beforeConnect() {\n        addClass(this.$el, this.$name);\n      } };\n\n\n    const Slidenav = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        addClass(this.$el, 'uk-slidenav');\n        const icon = this.$props.icon;\n        this.icon = hasClass(this.$el, 'uk-slidenav-large') ? icon + \"-large\" : icon;\n      } };\n\n\n    const Search = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        this.icon =\n        hasClass(this.$el, 'uk-search-icon') && parents(this.$el, '.uk-search-large').length ?\n        'search-large' :\n        parents(this.$el, '.uk-search-navbar').length ?\n        'search-navbar' :\n        this.$props.icon;\n      } };\n\n\n    const Close = {\n      extends: IconComponent,\n\n      beforeConnect() {\n        this.icon = \"close-\" + (hasClass(this.$el, 'uk-close-large') ? 'large' : 'icon');\n      } };\n\n\n    const Spinner = {\n      extends: IconComponent,\n\n      methods: {\n        async getSvg() {\n          const icon = await Icon.methods.getSvg.call(this);\n\n          if (this.ratio !== 1) {\n            css($('circle', icon), 'strokeWidth', 1 / this.ratio);\n          }\n\n          return icon;\n        } } };\n\n\n\n    const parsed = {};\n    function install$3(UIkit) {\n      UIkit.icon.add = (name, svg) => {\n        const added = isString(name) ? { [name]: svg } : name;\n        each(added, (svg, name) => {\n          icons[name] = svg;\n          delete parsed[name];\n        });\n\n        if (UIkit._initialized) {\n          apply(document.body, (el) =>\n          each(UIkit.getComponents(el), (cmp) => {\n            cmp.$options.isIcon && cmp.icon in added && cmp.$reset();\n          }));\n\n        }\n      };\n    }\n\n    function getIcon(icon) {\n      if (!icons[icon]) {\n        return null;\n      }\n\n      if (!parsed[icon]) {\n        parsed[icon] = $((icons[applyRtl(icon)] || icons[icon]).trim());\n      }\n\n      return parsed[icon].cloneNode(true);\n    }\n\n    function applyRtl(icon) {\n      return isRtl ? swap(swap(icon, 'left', 'right'), 'previous', 'next') : icon;\n    }\n\n    const nativeLazyLoad = inBrowser && 'loading' in HTMLImageElement.prototype;\n\n    var img = {\n      args: 'dataSrc',\n\n      props: {\n        dataSrc: String,\n        sources: String,\n        offsetTop: String,\n        offsetLeft: String,\n        target: String,\n        loading: String },\n\n\n      data: {\n        dataSrc: '',\n        sources: false,\n        offsetTop: '50vh',\n        offsetLeft: '50vw',\n        target: false,\n        loading: 'lazy' },\n\n\n      connected() {\n        if (this.loading !== 'lazy') {\n          this.load();\n          return;\n        }\n\n        const target = [this.$el, ...queryAll(this.$props.target, this.$el)];\n\n        if (nativeLazyLoad && isImg(this.$el)) {\n          this.$el.loading = 'lazy';\n          setSrcAttrs(this.$el);\n\n          if (target.length === 1) {\n            return;\n          }\n        }\n\n        ensureSrcAttribute(this.$el);\n\n        this.registerObserver(\n        observeIntersection(\n        target,\n        (entries, observer) => {\n          this.load();\n          observer.disconnect();\n        },\n        {\n          rootMargin: toPx(this.offsetTop, 'height') + \"px \" + toPx(\n          this.offsetLeft,\n          'width') + \"px\" }));\n\n\n\n\n      },\n\n      disconnected() {\n        if (this._data.image) {\n          this._data.image.onload = '';\n        }\n      },\n\n      methods: {\n        load() {\n          if (this._data.image) {\n            return this._data.image;\n          }\n\n          const image = isImg(this.$el) ?\n          this.$el :\n          getImageFromElement(this.$el, this.dataSrc, this.sources);\n\n          removeAttr(image, 'loading');\n          setSrcAttrs(this.$el, image.currentSrc);\n          return this._data.image = image;\n        } } };\n\n\n\n    function setSrcAttrs(el, src) {\n      if (isImg(el)) {\n        const parentNode = parent(el);\n        const elements = isPicture(parentNode) ? children(parentNode) : [el];\n        elements.forEach((el) => setSourceProps(el, el));\n      } else if (src) {\n        const change = !includes(el.style.backgroundImage, src);\n        if (change) {\n          css(el, 'backgroundImage', \"url(\" + escape(src) + \")\");\n          trigger(el, createEvent('load', false));\n        }\n      }\n    }\n\n    const srcProps = ['data-src', 'data-srcset', 'sizes'];\n    function setSourceProps(sourceEl, targetEl) {\n      srcProps.forEach((prop) => {\n        const value = data(sourceEl, prop);\n        if (value) {\n          attr(targetEl, prop.replace(/^(data-)+/, ''), value);\n        }\n      });\n    }\n\n    function getImageFromElement(el, src, sources) {\n      const img = new Image();\n\n      wrapInPicture(img, sources);\n      setSourceProps(el, img);\n      img.onload = () => {\n        setSrcAttrs(el, img.currentSrc);\n      };\n      attr(img, 'src', src);\n      return img;\n    }\n\n    function wrapInPicture(img, sources) {\n      sources = parseSources(sources);\n\n      if (sources.length) {\n        const picture = fragment('<picture>');\n        for (const attrs of sources) {\n          const source = fragment('<source>');\n          attr(source, attrs);\n          append(picture, source);\n        }\n        append(picture, img);\n      }\n    }\n\n    function parseSources(sources) {\n      if (!sources) {\n        return [];\n      }\n\n      if (startsWith(sources, '[')) {\n        try {\n          sources = JSON.parse(sources);\n        } catch (e) {\n          sources = [];\n        }\n      } else {\n        sources = parseOptions(sources);\n      }\n\n      if (!isArray(sources)) {\n        sources = [sources];\n      }\n\n      return sources.filter((source) => !isEmpty(source));\n    }\n\n    function ensureSrcAttribute(el) {\n      if (isImg(el) && !hasAttr(el, 'src')) {\n        attr(el, 'src', 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>');\n      }\n    }\n\n    function isPicture(el) {\n      return isTag(el, 'picture');\n    }\n\n    function isImg(el) {\n      return isTag(el, 'img');\n    }\n\n    var Media = {\n      props: {\n        media: Boolean },\n\n\n      data: {\n        media: false },\n\n\n      connected() {\n        const media = toMedia(this.media);\n        this.matchMedia = true;\n        if (media) {\n          this.mediaObj = window.matchMedia(media);\n          const handler = () => {\n            this.matchMedia = this.mediaObj.matches;\n            trigger(this.$el, createEvent('mediachange', false, true, [this.mediaObj]));\n          };\n          this.offMediaObj = on(this.mediaObj, 'change', () => {\n            handler();\n            this.$emit('resize');\n          });\n          handler();\n        }\n      },\n\n      disconnected() {var _this$offMediaObj;\n        (_this$offMediaObj = this.offMediaObj) == null ? void 0 : _this$offMediaObj.call(this);\n      } };\n\n\n    function toMedia(value) {\n      if (isString(value)) {\n        if (startsWith(value, '@')) {\n          const name = \"breakpoint-\" + value.substr(1);\n          value = toFloat(getCssVar(name));\n        } else if (isNaN(value)) {\n          return value;\n        }\n      }\n\n      return value && isNumeric(value) ? \"(min-width: \" + value + \"px)\" : '';\n    }\n\n    var leader = {\n      mixins: [Class, Media, Resize],\n\n      props: {\n        fill: String },\n\n\n      data: {\n        fill: '',\n        clsWrapper: 'uk-leader-fill',\n        clsHide: 'uk-leader-hide',\n        attrFill: 'data-fill' },\n\n\n      computed: {\n        fill(_ref) {let { fill } = _ref;\n          return fill || getCssVar('leader-fill-content');\n        } },\n\n\n      connected() {\n        [this.wrapper] = wrapInner(this.$el, \"<span class=\\\"\" + this.clsWrapper + \"\\\">\");\n      },\n\n      disconnected() {\n        unwrap(this.wrapper.childNodes);\n      },\n\n      update: {\n        read() {\n          const width = Math.trunc(this.$el.offsetWidth / 2);\n\n          return {\n            width,\n            fill: this.fill,\n            hide: !this.matchMedia };\n\n        },\n\n        write(_ref2) {let { width, fill, hide } = _ref2;\n          toggleClass(this.wrapper, this.clsHide, hide);\n          attr(this.wrapper, this.attrFill, new Array(width).join(fill));\n        },\n\n        events: ['resize'] } };\n\n    const active = [];\n\n    var Modal = {\n      mixins: [Class, Container, Togglable],\n\n      props: {\n        selPanel: String,\n        selClose: String,\n        escClose: Boolean,\n        bgClose: Boolean,\n        stack: Boolean },\n\n\n      data: {\n        cls: 'uk-open',\n        escClose: true,\n        bgClose: true,\n        overlay: true,\n        stack: false },\n\n\n      computed: {\n        panel(_ref, $el) {let { selPanel } = _ref;\n          return $(selPanel, $el);\n        },\n\n        transitionElement() {\n          return this.panel;\n        },\n\n        bgClose(_ref2) {let { bgClose } = _ref2;\n          return bgClose && this.panel;\n        } },\n\n\n      beforeDisconnect() {\n        if (includes(active, this)) {\n          this.toggleElement(this.$el, false, false);\n        }\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.selClose;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.hide();\n        } },\n\n\n      {\n        name: 'toggle',\n\n        self: true,\n\n        handler(e) {\n          if (e.defaultPrevented) {\n            return;\n          }\n\n          e.preventDefault();\n\n          if (this.isToggled() === includes(active, this)) {\n            this.toggle();\n          }\n        } },\n\n\n      {\n        name: 'beforeshow',\n\n        self: true,\n\n        handler(e) {\n          if (includes(active, this)) {\n            return false;\n          }\n\n          if (!this.stack && active.length) {\n            Promise.all(active.map((modal) => modal.hide())).then(this.show);\n            e.preventDefault();\n          } else {\n            active.push(this);\n          }\n        } },\n\n\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          const docEl = document.documentElement;\n\n          if (width(window) > docEl.clientWidth && this.overlay) {\n            css(document.body, 'overflowY', 'scroll');\n          }\n\n          if (this.stack) {\n            css(this.$el, 'zIndex', toFloat(css(this.$el, 'zIndex')) + active.length);\n          }\n\n          addClass(docEl, this.clsPage);\n\n          if (this.bgClose) {\n            once(\n            this.$el,\n            'hide',\n            on(document, pointerDown, (_ref3) => {let { target } = _ref3;\n              if (\n              last(active) !== this ||\n              this.overlay && !within(target, this.$el) ||\n              within(target, this.panel))\n              {\n                return;\n              }\n\n              once(\n              document,\n              pointerUp + \" \" + pointerCancel + \" scroll\",\n              (_ref4) => {let { defaultPrevented, type, target: newTarget } = _ref4;\n                if (\n                !defaultPrevented &&\n                type === pointerUp &&\n                target === newTarget)\n                {\n                  this.hide();\n                }\n              },\n              true);\n\n            }),\n            { self: true });\n\n          }\n\n          if (this.escClose) {\n            once(\n            this.$el,\n            'hide',\n            on(document, 'keydown', (e) => {\n              if (e.keyCode === 27 && last(active) === this) {\n                this.hide();\n              }\n            }),\n            { self: true });\n\n          }\n        } },\n\n\n      {\n        name: 'shown',\n\n        self: true,\n\n        handler() {\n          if (!isFocusable(this.$el)) {\n            attr(this.$el, 'tabindex', '-1');\n          }\n\n          if (!$(':focus', this.$el)) {\n            this.$el.focus();\n          }\n        } },\n\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          if (includes(active, this)) {\n            active.splice(active.indexOf(this), 1);\n          }\n\n          if (!active.length) {\n            css(document.body, 'overflowY', '');\n          }\n\n          css(this.$el, 'zIndex', '');\n\n          if (!active.some((modal) => modal.clsPage === this.clsPage)) {\n            removeClass(document.documentElement, this.clsPage);\n          }\n        } }],\n\n\n\n      methods: {\n        toggle() {\n          return this.isToggled() ? this.hide() : this.show();\n        },\n\n        show() {\n          if (this.container && parent(this.$el) !== this.container) {\n            append(this.container, this.$el);\n            return new Promise((resolve) =>\n            requestAnimationFrame(() => this.show().then(resolve)));\n\n          }\n\n          return this.toggleElement(this.$el, true, animate(this));\n        },\n\n        hide() {\n          return this.toggleElement(this.$el, false, animate(this));\n        } } };\n\n\n\n    function animate(_ref5) {let { transitionElement, _toggle } = _ref5;\n      return (el, show) =>\n      new Promise((resolve, reject) =>\n      once(el, 'show hide', () => {\n        el._reject == null ? void 0 : el._reject();\n        el._reject = reject;\n\n        _toggle(el, show);\n\n        const off = once(\n        transitionElement,\n        'transitionstart',\n        () => {\n          once(transitionElement, 'transitionend transitioncancel', resolve, {\n            self: true });\n\n          clearTimeout(timer);\n        },\n        { self: true });\n\n\n        const timer = setTimeout(() => {\n          off();\n          resolve();\n        }, toMs(css(transitionElement, 'transitionDuration')));\n      })).\n      then(() => delete el._reject);\n    }\n\n    function toMs(time) {\n      return time ? endsWith(time, 'ms') ? toFloat(time) : toFloat(time) * 1000 : 0;\n    }\n\n    var modal = {\n      install: install$2,\n\n      mixins: [Modal],\n\n      data: {\n        clsPage: 'uk-modal-page',\n        selPanel: '.uk-modal-dialog',\n        selClose:\n        '.uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full' },\n\n\n      events: [\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          if (hasClass(this.panel, 'uk-margin-auto-vertical')) {\n            addClass(this.$el, 'uk-flex');\n          } else {\n            css(this.$el, 'display', 'block');\n          }\n\n          height(this.$el); // force reflow\n        } },\n\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          css(this.$el, 'display', '');\n          removeClass(this.$el, 'uk-flex');\n        } }] };\n\n\n\n\n    function install$2(_ref) {let { modal } = _ref;\n      modal.dialog = function (content, options) {\n        const dialog = modal(\"<div class=\\\"uk-modal\\\"> <div class=\\\"uk-modal-dialog\\\">\" +\n\n        content + \"</div> </div>\",\n\n        options);\n\n\n        dialog.show();\n\n        on(\n        dialog.$el,\n        'hidden',\n        async () => {\n          await Promise.resolve();\n          dialog.$destroy(true);\n        },\n        { self: true });\n\n\n        return dialog;\n      };\n\n      modal.alert = function (message, options) {\n        return openDialog(\n        (_ref2) => {let { labels } = _ref2;return \"<div class=\\\"uk-modal-body\\\">\" + (\n          isString(message) ? message : html(message)) + \"</div> <div class=\\\"uk-modal-footer uk-text-right\\\"> <button class=\\\"uk-button uk-button-primary uk-modal-close\\\" autofocus>\" +\n\n\n\n          labels.ok + \"</button> </div>\";},\n\n\n        options,\n        (deferred) => deferred.resolve());\n\n      };\n\n      modal.confirm = function (message, options) {\n        return openDialog(\n        (_ref3) => {let { labels } = _ref3;return \"<form> <div class=\\\"uk-modal-body\\\">\" + (\n          isString(message) ? message : html(message)) + \"</div> <div class=\\\"uk-modal-footer uk-text-right\\\"> <button class=\\\"uk-button uk-button-default uk-modal-close\\\" type=\\\"button\\\">\" +\n\n\n          labels.cancel + \"</button> <button class=\\\"uk-button uk-button-primary\\\" autofocus>\" +\n\n          labels.ok + \"</button> </div> </form>\";},\n\n\n        options,\n        (deferred) => deferred.reject());\n\n      };\n\n      modal.prompt = function (message, value, options) {\n        return openDialog(\n        (_ref4) => {let { labels } = _ref4;return \"<form class=\\\"uk-form-stacked\\\"> <div class=\\\"uk-modal-body\\\"> <label>\" + (\n\n          isString(message) ? message : html(message)) + \"</label> <input class=\\\"uk-input\\\" value=\\\"\" + (\n          value || '') + \"\\\" autofocus> </div> <div class=\\\"uk-modal-footer uk-text-right\\\"> <button class=\\\"uk-button uk-button-default uk-modal-close\\\" type=\\\"button\\\">\" +\n\n\n\n          labels.cancel + \"</button> <button class=\\\"uk-button uk-button-primary\\\">\" +\n\n          labels.ok + \"</button> </div> </form>\";},\n\n\n        options,\n        (deferred) => deferred.resolve(null),\n        (dialog) => $('input', dialog.$el).value);\n\n      };\n\n      modal.labels = {\n        ok: 'Ok',\n        cancel: 'Cancel' };\n\n\n      function openDialog(tmpl, options, hideFn, submitFn) {\n        options = { bgClose: false, escClose: true, labels: modal.labels, ...options };\n\n        const dialog = modal.dialog(tmpl(options), options);\n        const deferred = new Deferred();\n\n        let resolved = false;\n\n        on(dialog.$el, 'submit', 'form', (e) => {\n          e.preventDefault();\n          deferred.resolve(submitFn == null ? void 0 : submitFn(dialog));\n          resolved = true;\n          dialog.hide();\n        });\n\n        on(dialog.$el, 'hide', () => !resolved && hideFn(deferred));\n\n        deferred.promise.dialog = dialog;\n\n        return deferred.promise;\n      }\n    }\n\n    var nav = {\n      extends: Accordion,\n\n      data: {\n        targets: '> .uk-parent',\n        toggle: '> a',\n        content: '> ul' } };\n\n    var navbar = {\n      mixins: [Class, Container],\n\n      props: {\n        dropdown: String,\n        mode: 'list',\n        align: String,\n        offset: Number,\n        boundary: Boolean,\n        boundaryAlign: Boolean,\n        clsDrop: String,\n        delayShow: Number,\n        delayHide: Number,\n        dropbar: Boolean,\n        dropbarAnchor: Boolean,\n        duration: Number },\n\n\n      data: {\n        dropdown: '.uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle',\n        align: isRtl ? 'right' : 'left',\n        clsDrop: 'uk-navbar-dropdown',\n        mode: undefined,\n        offset: undefined,\n        delayShow: undefined,\n        delayHide: undefined,\n        boundaryAlign: undefined,\n        flip: 'x',\n        boundary: true,\n        dropbar: false,\n        dropbarAnchor: false,\n        duration: 200,\n        container: false },\n\n\n      computed: {\n        boundary(_ref, $el) {let { boundary } = _ref;\n          return boundary === true ? $el : boundary;\n        },\n\n        dropbarAnchor(_ref2, $el) {let { dropbarAnchor } = _ref2;\n          return query(dropbarAnchor, $el);\n        },\n\n        pos(_ref3) {let { align } = _ref3;\n          return \"bottom-\" + align;\n        },\n\n        dropbar: {\n          get(_ref4) {let { dropbar } = _ref4;\n            if (!dropbar) {\n              return null;\n            }\n\n            dropbar =\n            this._dropbar ||\n            query(dropbar, this.$el) ||\n            $('+ .uk-navbar-dropbar', this.$el);\n\n            return dropbar ? dropbar : this._dropbar = $('<div></div>');\n          },\n\n          watch(dropbar) {\n            addClass(dropbar, 'uk-navbar-dropbar');\n          },\n\n          immediate: true },\n\n\n        dropContainer(_, $el) {\n          return this.container || $el;\n        },\n\n        dropdowns: {\n          get(_ref5, $el) {let { clsDrop } = _ref5;\n            const dropdowns = $$(\".\" + clsDrop, $el);\n\n            if (this.dropContainer !== $el) {\n              for (const el of $$(\".\" + clsDrop, this.dropContainer)) {var _this$getDropdown;\n                const target = (_this$getDropdown = this.getDropdown(el)) == null ? void 0 : _this$getDropdown.target;\n                if (!includes(dropdowns, el) && target && within(target, this.$el)) {\n                  dropdowns.push(el);\n                }\n              }\n            }\n\n            return dropdowns;\n          },\n\n          watch(dropdowns) {\n            this.$create(\n            'drop',\n            dropdowns.filter((el) => !this.getDropdown(el)),\n            {\n              ...this.$props,\n              boundary: this.boundary,\n              pos: this.pos,\n              offset: this.dropbar || this.offset });\n\n\n          },\n\n          immediate: true },\n\n\n        toggles: {\n          get(_ref6, $el) {let { dropdown } = _ref6;\n            return $$(dropdown, $el);\n          },\n\n          watch() {\n            const justify = hasClass(this.$el, 'uk-navbar-justify');\n            for (const container of $$(\n            '.uk-navbar-nav, .uk-navbar-left, .uk-navbar-right',\n            this.$el))\n            {\n              css(container, 'flexGrow', justify ? $$(this.dropdown, container).length : '');\n            }\n          },\n\n          immediate: true } },\n\n\n\n      disconnected() {\n        this.dropbar && remove$1(this.dropbar);\n        delete this._dropbar;\n      },\n\n      events: [\n      {\n        name: 'mouseover focusin',\n\n        delegate() {\n          return this.dropdown;\n        },\n\n        handler(_ref7) {let { current } = _ref7;\n          const active = this.getActive();\n          if (\n          active &&\n          includes(active.mode, 'hover') &&\n          active.target &&\n          !within(active.target, current) &&\n          !active.isDelaying)\n          {\n            active.hide(false);\n          }\n        } },\n\n\n      {\n        name: 'keydown',\n\n        delegate() {\n          return this.dropdown;\n        },\n\n        handler(e) {\n          const { current, keyCode } = e;\n          const active = this.getActive();\n\n          if (keyCode === keyMap.DOWN && hasAttr(current, 'aria-expanded')) {\n            e.preventDefault();\n\n            if (!active || active.target !== current) {\n              current.click();\n              once(this.dropContainer, 'show', (_ref8) => {let { target } = _ref8;return (\n                  focusFirstFocusableElement(target));});\n\n            } else {\n              focusFirstFocusableElement(active.$el);\n            }\n          }\n\n          handleNavItemNavigation(e, this.toggles, active);\n        } },\n\n\n      {\n        name: 'keydown',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        delegate() {\n          return \".\" + this.clsDrop;\n        },\n\n        handler(e) {\n          const { current, keyCode } = e;\n\n          if (!includes(this.dropdowns, current)) {\n            return;\n          }\n\n          const active = this.getActive();\n          const elements = $$(selFocusable, current);\n          const i = findIndex(elements, (el) => matches(el, ':focus'));\n\n          if (keyCode === keyMap.UP) {\n            e.preventDefault();\n            if (i > 0) {\n              elements[i - 1].focus();\n            }\n          }\n\n          if (keyCode === keyMap.DOWN) {\n            e.preventDefault();\n            if (i < elements.length - 1) {\n              elements[i + 1].focus();\n            }\n          }\n\n          if (keyCode === keyMap.ESC) {var _active$target;\n            active == null ? void 0 : (_active$target = active.target) == null ? void 0 : _active$target.focus();\n          }\n\n          handleNavItemNavigation(e, this.toggles, active);\n        } },\n\n\n      {\n        name: 'mouseleave',\n\n        el() {\n          return this.dropbar;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler() {\n          const active = this.getActive();\n\n          if (\n          active &&\n          includes(active.mode, 'hover') &&\n          !this.dropdowns.some((el) => matches(el, ':hover')))\n          {\n            active.hide();\n          }\n        } },\n\n\n      {\n        name: 'beforeshow',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler(_, _ref9) {let { $el } = _ref9;\n          if (!hasClass($el, this.clsDrop)) {\n            return;\n          }\n\n          if (!parent(this.dropbar)) {\n            after(this.dropbarAnchor || this.$el, this.dropbar);\n          }\n\n          addClass($el, this.clsDrop + \"-dropbar\");\n        } },\n\n\n      {\n        name: 'show',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler(_, _ref10) {let { $el, pos: [dir] = [] } = _ref10;\n          if (!hasClass($el, this.clsDrop)) {\n            return;\n          }\n\n          if (dir === 'bottom') {\n            this.transitionTo(\n            offset($el).bottom -\n            offset(this.dropbar).top +\n            toFloat(css($el, 'marginBottom')),\n            $el);\n\n          }\n        } },\n\n\n      {\n        name: 'beforehide',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler(e, _ref11) {let { $el } = _ref11;\n          const active = this.getActive();\n\n          if (\n          matches(this.dropbar, ':hover') &&\n          (active == null ? void 0 : active.$el) === $el &&\n          !this.toggles.some((el) => active.target !== el && matches(el, ':focus')))\n          {\n            e.preventDefault();\n          }\n        } },\n\n\n      {\n        name: 'hide',\n\n        el() {\n          return this.dropContainer;\n        },\n\n        filter() {\n          return this.dropbar;\n        },\n\n        handler(_, _ref12) {let { $el } = _ref12;\n          if (!hasClass($el, this.clsDrop)) {\n            return;\n          }\n\n          const active = this.getActive();\n\n          if (!active || (active == null ? void 0 : active.$el) === $el) {\n            this.transitionTo(0);\n          }\n        } }],\n\n\n\n      methods: {\n        getActive() {\n          return active$1 && within(active$1.target, this.$el) && active$1;\n        },\n\n        transitionTo(newHeight, el) {\n          const { dropbar } = this;\n          const oldHeight = isVisible(dropbar) ? height(dropbar) : 0;\n\n          el = oldHeight < newHeight && el;\n\n          css(el, 'clip', \"rect(0,\" + el.offsetWidth + \"px,\" + oldHeight + \"px,0)\");\n\n          height(dropbar, oldHeight);\n\n          Transition.cancel([el, dropbar]);\n          return Promise.all([\n          Transition.start(dropbar, { height: newHeight }, this.duration),\n          Transition.start(\n          el,\n          { clip: \"rect(0,\" + el.offsetWidth + \"px,\" + newHeight + \"px,0)\" },\n          this.duration)]).\n\n\n          catch(noop).\n          then(() => {\n            css(el, { clip: '' });\n            this.$update(dropbar);\n          });\n        },\n\n        getDropdown(el) {\n          return this.$getComponent(el, 'drop') || this.$getComponent(el, 'dropdown');\n        } } };\n\n\n\n    function handleNavItemNavigation(e, toggles, active) {\n      const { current, keyCode } = e;\n      const target = (active == null ? void 0 : active.target) || current;\n      const i = toggles.indexOf(target);\n\n      // Left\n      if (keyCode === keyMap.LEFT && i > 0) {\n        active == null ? void 0 : active.hide(false);\n        toggles[i - 1].focus();\n      }\n\n      // Right\n      if (keyCode === keyMap.RIGHT && i < toggles.length - 1) {\n        active == null ? void 0 : active.hide(false);\n        toggles[i + 1].focus();\n      }\n\n      if (keyCode === keyMap.TAB) {\n        target.focus();\n        active == null ? void 0 : active.hide(false);\n      }\n    }\n\n    function focusFirstFocusableElement(el) {\n      if (!$(':focus', el)) {var _$;\n        (_$ = $(selFocusable, el)) == null ? void 0 : _$.focus();\n      }\n    }\n\n    const keyMap = {\n      TAB: 9,\n      ESC: 27,\n      LEFT: 37,\n      UP: 38,\n      RIGHT: 39,\n      DOWN: 40 };\n\n    var Swipe = {\n      props: {\n        swiping: Boolean },\n\n\n      data: {\n        swiping: true },\n\n\n      computed: {\n        swipeTarget(props, $el) {\n          return $el;\n        } },\n\n\n      connected() {\n        if (!this.swiping) {\n          return;\n        }\n\n        registerEvent(this, {\n          el: this.swipeTarget,\n          name: pointerDown,\n          passive: true,\n          handler(e) {\n            if (!isTouch(e)) {\n              return;\n            }\n\n            // Handle Swipe Gesture\n            const pos = getEventPos(e);\n            const target = 'tagName' in e.target ? e.target : parent(e.target);\n            once(document, pointerUp + \" \" + pointerCancel + \" scroll\", (e) => {\n              const { x, y } = getEventPos(e);\n\n              // swipe\n              if (\n              e.type !== 'scroll' && target && x && Math.abs(pos.x - x) > 100 ||\n              y && Math.abs(pos.y - y) > 100)\n              {\n                setTimeout(() => {\n                  trigger(target, 'swipe');\n                  trigger(target, \"swipe\" + swipeDirection(pos.x, pos.y, x, y));\n                });\n              }\n            });\n          } });\n\n      } };\n\n\n    function swipeDirection(x1, y1, x2, y2) {\n      return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ?\n      x1 - x2 > 0 ?\n      'Left' :\n      'Right' :\n      y1 - y2 > 0 ?\n      'Up' :\n      'Down';\n    }\n\n    var offcanvas = {\n      mixins: [Modal, Swipe],\n\n      args: 'mode',\n\n      props: {\n        mode: String,\n        flip: Boolean,\n        overlay: Boolean },\n\n\n      data: {\n        mode: 'slide',\n        flip: false,\n        overlay: false,\n        clsPage: 'uk-offcanvas-page',\n        clsContainer: 'uk-offcanvas-container',\n        selPanel: '.uk-offcanvas-bar',\n        clsFlip: 'uk-offcanvas-flip',\n        clsContainerAnimation: 'uk-offcanvas-container-animation',\n        clsSidebarAnimation: 'uk-offcanvas-bar-animation',\n        clsMode: 'uk-offcanvas',\n        clsOverlay: 'uk-offcanvas-overlay',\n        selClose: '.uk-offcanvas-close',\n        container: false },\n\n\n      computed: {\n        clsFlip(_ref) {let { flip, clsFlip } = _ref;\n          return flip ? clsFlip : '';\n        },\n\n        clsOverlay(_ref2) {let { overlay, clsOverlay } = _ref2;\n          return overlay ? clsOverlay : '';\n        },\n\n        clsMode(_ref3) {let { mode, clsMode } = _ref3;\n          return clsMode + \"-\" + mode;\n        },\n\n        clsSidebarAnimation(_ref4) {let { mode, clsSidebarAnimation } = _ref4;\n          return mode === 'none' || mode === 'reveal' ? '' : clsSidebarAnimation;\n        },\n\n        clsContainerAnimation(_ref5) {let { mode, clsContainerAnimation } = _ref5;\n          return mode !== 'push' && mode !== 'reveal' ? '' : clsContainerAnimation;\n        },\n\n        transitionElement(_ref6) {let { mode } = _ref6;\n          return mode === 'reveal' ? parent(this.panel) : this.panel;\n        } },\n\n\n      update: {\n        read() {\n          if (this.isToggled() && !isVisible(this.$el)) {\n            this.hide();\n          }\n        },\n\n        events: ['resize'] },\n\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return 'a[href^=\"#\"]';\n        },\n\n        handler(_ref7) {let { current: { hash }, defaultPrevented } = _ref7;\n          if (!defaultPrevented && hash && $(hash, document.body)) {\n            this.hide();\n          }\n        } },\n\n\n      {\n        name: 'touchstart',\n\n        passive: true,\n\n        el() {\n          return this.panel;\n        },\n\n        handler(_ref8) {let { targetTouches } = _ref8;\n          if (targetTouches.length === 1) {\n            this.clientY = targetTouches[0].clientY;\n          }\n        } },\n\n\n      {\n        name: 'touchmove',\n\n        self: true,\n        passive: false,\n\n        filter() {\n          return this.overlay;\n        },\n\n        handler(e) {\n          e.cancelable && e.preventDefault();\n        } },\n\n\n      {\n        name: 'touchmove',\n\n        passive: false,\n\n        el() {\n          return this.panel;\n        },\n\n        handler(e) {\n          if (e.targetTouches.length !== 1) {\n            return;\n          }\n\n          const clientY = e.targetTouches[0].clientY - this.clientY;\n          const { scrollTop, scrollHeight, clientHeight } = this.panel;\n\n          if (\n          clientHeight >= scrollHeight ||\n          scrollTop === 0 && clientY > 0 ||\n          scrollHeight - scrollTop <= clientHeight && clientY < 0)\n          {\n            e.cancelable && e.preventDefault();\n          }\n        } },\n\n\n      {\n        name: 'show',\n\n        self: true,\n\n        handler() {\n          if (this.mode === 'reveal' && !hasClass(parent(this.panel), this.clsMode)) {\n            wrapAll(this.panel, '<div>');\n            addClass(parent(this.panel), this.clsMode);\n          }\n\n          css(document.documentElement, 'overflowY', this.overlay ? 'hidden' : '');\n          addClass(document.body, this.clsContainer, this.clsFlip);\n          css(document.body, 'touch-action', 'pan-y pinch-zoom');\n          css(this.$el, 'display', 'block');\n          addClass(this.$el, this.clsOverlay);\n          addClass(\n          this.panel,\n          this.clsSidebarAnimation,\n          this.mode !== 'reveal' ? this.clsMode : '');\n\n\n          height(document.body); // force reflow\n          addClass(document.body, this.clsContainerAnimation);\n\n          this.clsContainerAnimation && suppressUserScale();\n        } },\n\n\n      {\n        name: 'hide',\n\n        self: true,\n\n        handler() {\n          removeClass(document.body, this.clsContainerAnimation);\n          css(document.body, 'touch-action', '');\n        } },\n\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          this.clsContainerAnimation && resumeUserScale();\n\n          if (this.mode === 'reveal') {\n            unwrap(this.panel);\n          }\n\n          removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);\n          removeClass(this.$el, this.clsOverlay);\n          css(this.$el, 'display', '');\n          removeClass(document.body, this.clsContainer, this.clsFlip);\n\n          css(document.documentElement, 'overflowY', '');\n        } },\n\n\n      {\n        name: 'swipeLeft swipeRight',\n\n        handler(e) {\n          if (this.isToggled() && endsWith(e.type, 'Left') ^ this.flip) {\n            this.hide();\n          }\n        } }] };\n\n\n\n\n    // Chrome in responsive mode zooms page upon opening offcanvas\n    function suppressUserScale() {\n      getViewport().content += ',user-scalable=0';\n    }\n\n    function resumeUserScale() {\n      const viewport = getViewport();\n      viewport.content = viewport.content.replace(/,user-scalable=0$/, '');\n    }\n\n    function getViewport() {\n      return (\n        $('meta[name=\"viewport\"]', document.head) || append(document.head, '<meta name=\"viewport\">'));\n\n    }\n\n    var overflowAuto = {\n      mixins: [Class, Resize],\n\n      props: {\n        selContainer: String,\n        selContent: String,\n        minHeight: Number },\n\n\n      data: {\n        selContainer: '.uk-modal',\n        selContent: '.uk-modal-dialog',\n        minHeight: 150 },\n\n\n      computed: {\n        container(_ref, $el) {let { selContainer } = _ref;\n          return closest($el, selContainer);\n        },\n\n        content(_ref2, $el) {let { selContent } = _ref2;\n          return closest($el, selContent);\n        } },\n\n\n      resizeTargets() {\n        return [this.container, this.content];\n      },\n\n      update: {\n        read() {\n          if (!this.content || !this.container || !isVisible(this.$el)) {\n            return false;\n          }\n\n          return {\n            max: Math.max(\n            this.minHeight,\n            height(this.container) - (dimensions$1(this.content).height - height(this.$el))) };\n\n\n        },\n\n        write(_ref3) {let { max } = _ref3;\n          css(this.$el, { minHeight: this.minHeight, maxHeight: max });\n        },\n\n        events: ['resize'] } };\n\n    var responsive = {\n      mixins: [Resize],\n\n      props: ['width', 'height'],\n\n      resizeTargets() {\n        return [this.$el, parent(this.$el)];\n      },\n\n      connected() {\n        addClass(this.$el, 'uk-responsive-width');\n      },\n\n      update: {\n        read() {\n          return isVisible(this.$el) && this.width && this.height ?\n          { width: width(parent(this.$el)), height: this.height } :\n          false;\n        },\n\n        write(dim) {\n          height(\n          this.$el,\n          Dimensions.contain(\n          {\n            height: this.height,\n            width: this.width },\n\n          dim).\n          height);\n\n        },\n\n        events: ['resize'] } };\n\n    var scroll = {\n      props: {\n        offset: Number },\n\n\n      data: {\n        offset: 0 },\n\n\n      methods: {\n        async scrollTo(el) {\n          el = el && $(el) || document.body;\n\n          if (trigger(this.$el, 'beforescroll', [this, el])) {\n            await scrollIntoView(el, { offset: this.offset });\n            trigger(this.$el, 'scrolled', [this, el]);\n          }\n        } },\n\n\n      events: {\n        click(e) {\n          if (e.defaultPrevented) {\n            return;\n          }\n\n          e.preventDefault();\n          this.scrollTo(getTargetElement(this.$el));\n        } } };\n\n\n\n    function getTargetElement(el) {\n      return document.getElementById(decodeURIComponent(el.hash).substring(1));\n    }\n\n    var scrollspy = {\n      mixins: [Scroll],\n\n      args: 'cls',\n\n      props: {\n        cls: String,\n        target: String,\n        hidden: Boolean,\n        offsetTop: Number,\n        offsetLeft: Number,\n        repeat: Boolean,\n        delay: Number },\n\n\n      data: () => ({\n        cls: '',\n        target: false,\n        hidden: true,\n        offsetTop: 0,\n        offsetLeft: 0,\n        repeat: false,\n        delay: 0,\n        inViewClass: 'uk-scrollspy-inview' }),\n\n\n      computed: {\n        elements: {\n          get(_ref, $el) {let { target } = _ref;\n            return target ? $$(target, $el) : [$el];\n          },\n\n          watch(elements, prev) {\n            if (this.hidden) {\n              css(filter$1(elements, \":not(.\" + this.inViewClass + \")\"), 'visibility', 'hidden');\n            }\n\n            if (!isEqual(elements, prev)) {\n              this.$reset();\n            }\n          },\n\n          immediate: true } },\n\n\n\n      connected() {\n        this._data.elements = new Map();\n        this.registerObserver(\n        observeIntersection(\n        this.elements,\n        (records) => {\n          const elements = this._data.elements;\n          for (const { target: el, isIntersecting } of records) {\n            if (!elements.has(el)) {\n              elements.set(el, {\n                cls: data(el, 'uk-scrollspy-class') || this.cls });\n\n            }\n\n            const state = elements.get(el);\n            if (!this.repeat && state.show) {\n              continue;\n            }\n\n            state.show = isIntersecting;\n          }\n\n          this.$emit();\n        },\n        {\n          rootMargin: toPx(this.offsetTop, 'height') - 1 + \"px \" + (\n          toPx(this.offsetLeft, 'width') - 1) + \"px\" },\n\n\n        false));\n\n\n      },\n\n      disconnected() {\n        for (const [el, state] of this._data.elements.entries()) {\n          removeClass(el, this.inViewClass, (state == null ? void 0 : state.cls) || '');\n        }\n      },\n\n      update: [\n      {\n        write(data) {\n          for (const [el, state] of data.elements.entries()) {\n            if (state.show && !state.inview && !state.queued) {\n              state.queued = true;\n\n              data.promise = (data.promise || Promise.resolve()).\n              then(() => new Promise((resolve) => setTimeout(resolve, this.delay))).\n              then(() => {\n                this.toggle(el, true);\n                setTimeout(() => {\n                  state.queued = false;\n                  this.$emit();\n                }, 300);\n              });\n            } else if (!state.show && state.inview && !state.queued && this.repeat) {\n              this.toggle(el, false);\n            }\n          }\n        } }],\n\n\n\n      methods: {\n        toggle(el, inview) {\n          const state = this._data.elements.get(el);\n\n          state.off == null ? void 0 : state.off();\n\n          css(el, 'visibility', !inview && this.hidden ? 'hidden' : '');\n\n          toggleClass(el, this.inViewClass, inview);\n          toggleClass(el, state.cls);\n\n          if (/\\buk-animation-/.test(state.cls)) {\n            const removeAnimationClasses = () => removeClasses(el, 'uk-animation-[\\\\w-]+');\n            if (inview) {\n              state.off = once(el, 'animationcancel animationend', removeAnimationClasses);\n            } else {\n              removeAnimationClasses();\n            }\n          }\n\n          trigger(el, inview ? 'inview' : 'outview');\n\n          state.inview = inview;\n\n          this.$update(el);\n        } } };\n\n    var scrollspyNav = {\n      mixins: [Scroll],\n\n      props: {\n        cls: String,\n        closest: String,\n        scroll: Boolean,\n        overflow: Boolean,\n        offset: Number },\n\n\n      data: {\n        cls: 'uk-active',\n        closest: false,\n        scroll: false,\n        overflow: true,\n        offset: 0 },\n\n\n      computed: {\n        links: {\n          get(_, $el) {\n            return $$('a[href^=\"#\"]', $el).filter((el) => el.hash);\n          },\n\n          watch(links) {\n            if (this.scroll) {\n              this.$create('scroll', links, { offset: this.offset || 0 });\n            }\n          },\n\n          immediate: true },\n\n\n        elements(_ref) {let { closest: selector } = _ref;\n          return closest(this.links, selector || '*');\n        } },\n\n\n      update: [\n      {\n        read() {\n          const targets = this.links.map(getTargetElement).filter(Boolean);\n\n          const { length } = targets;\n\n          if (!length || !isVisible(this.$el)) {\n            return false;\n          }\n\n          const [scrollElement] = scrollParents(targets, /auto|scroll/, true);\n          const { scrollTop, scrollHeight } = scrollElement;\n          const viewport = offsetViewport(scrollElement);\n          const max = scrollHeight - viewport.height;\n          let active = false;\n\n          if (scrollTop === max) {\n            active = length - 1;\n          } else {\n            for (let i = 0; i < targets.length; i++) {\n              if (offset(targets[i]).top - viewport.top - this.offset > 0) {\n                break;\n              }\n              active = +i;\n            }\n\n            if (active === false && this.overflow) {\n              active = 0;\n            }\n          }\n\n          return { active };\n        },\n\n        write(_ref2) {let { active } = _ref2;\n          const changed = active !== false && !hasClass(this.elements[active], this.cls);\n\n          this.links.forEach((el) => el.blur());\n          for (let i = 0; i < this.elements.length; i++) {\n            toggleClass(this.elements[i], this.cls, +i === active);\n          }\n\n          if (changed) {\n            trigger(this.$el, 'active', [active, this.elements[active]]);\n          }\n        },\n\n        events: ['scroll', 'resize'] }] };\n\n    var sticky = {\n      mixins: [Class, Media, Resize, Scroll],\n\n      props: {\n        position: String,\n        top: null,\n        bottom: null,\n        start: null,\n        end: null,\n        offset: String,\n        overflowFlip: Boolean,\n        animation: String,\n        clsActive: String,\n        clsInactive: String,\n        clsFixed: String,\n        clsBelow: String,\n        selTarget: String,\n        showOnUp: Boolean,\n        targetOffset: Number },\n\n\n      data: {\n        position: 'top',\n        top: false,\n        bottom: false,\n        start: false,\n        end: false,\n        offset: 0,\n        overflowFlip: false,\n        animation: '',\n        clsActive: 'uk-active',\n        clsInactive: '',\n        clsFixed: 'uk-sticky-fixed',\n        clsBelow: 'uk-sticky-below',\n        selTarget: '',\n        showOnUp: false,\n        targetOffset: false },\n\n\n      computed: {\n        selTarget(_ref, $el) {let { selTarget } = _ref;\n          return selTarget && $(selTarget, $el) || $el;\n        } },\n\n\n      resizeTargets() {\n        return document.documentElement;\n      },\n\n      connected() {\n        this.start = coerce(this.start || this.top);\n        this.end = coerce(this.end || this.bottom);\n\n        this.placeholder =\n        $('+ .uk-sticky-placeholder', this.$el) ||\n        $('<div class=\"uk-sticky-placeholder\"></div>');\n        this.isFixed = false;\n        this.setActive(false);\n      },\n\n      disconnected() {\n        if (this.isFixed) {\n          this.hide();\n          removeClass(this.selTarget, this.clsInactive);\n        }\n\n        remove$1(this.placeholder);\n        this.placeholder = null;\n      },\n\n      events: [\n      {\n        name: 'resize',\n\n        el() {\n          return window;\n        },\n\n        handler() {\n          this.$emit('resize');\n        } },\n\n      {\n        name: 'load hashchange popstate',\n\n        el() {\n          return window;\n        },\n\n        filter() {\n          return this.targetOffset !== false;\n        },\n\n        handler() {\n          if (!location.hash || scrollTop(window) === 0) {\n            return;\n          }\n\n          setTimeout(() => {\n            const targetOffset = offset($(location.hash));\n            const elOffset = offset(this.$el);\n\n            if (this.isFixed && intersectRect(targetOffset, elOffset)) {\n              scrollTop(\n              window,\n              targetOffset.top -\n              elOffset.height -\n              toPx(this.targetOffset, 'height', this.placeholder) -\n              toPx(this.offset, 'height', this.placeholder));\n\n            }\n          });\n        } }],\n\n\n\n      update: [\n      {\n        read(_ref2, types) {let { height: height$1, margin } = _ref2;\n          this.inactive = !this.matchMedia || !isVisible(this.$el);\n\n          if (this.inactive) {\n            return false;\n          }\n\n          const hide = this.active && types.has('resize');\n          if (hide) {\n            css(this.selTarget, 'transition', '0s');\n            this.hide();\n          }\n\n          if (!this.active) {\n            height$1 = offset(this.$el).height;\n            margin = css(this.$el, 'margin');\n          }\n\n          if (hide) {\n            this.show();\n            requestAnimationFrame(() => css(this.selTarget, 'transition', ''));\n          }\n\n          const referenceElement = this.isFixed ? this.placeholder : this.$el;\n          const windowHeight = height(window);\n\n          let position = this.position;\n          if (this.overflowFlip && height$1 > windowHeight) {\n            position = position === 'top' ? 'bottom' : 'top';\n          }\n\n          let offset$1 = toPx(this.offset, 'height', referenceElement);\n          if (position === 'bottom' && (height$1 < windowHeight || this.overflowFlip)) {\n            offset$1 += windowHeight - height$1;\n          }\n\n          const overflow = this.overflowFlip ?\n          0 :\n          Math.max(0, height$1 + offset$1 - windowHeight);\n          const topOffset = offset(referenceElement).top;\n\n          const start =\n          (this.start === false ?\n          topOffset :\n          parseProp(this.start, this.$el, topOffset)) - offset$1;\n          const end =\n          this.end === false ?\n          document.scrollingElement.scrollHeight - windowHeight :\n          parseProp(this.end, this.$el, topOffset + height$1, true) -\n          offset(this.$el).height +\n          overflow -\n          offset$1;\n\n          return {\n            start,\n            end,\n            offset: offset$1,\n            overflow,\n            topOffset,\n            height: height$1,\n            margin,\n            width: dimensions$1(referenceElement).width,\n            top: offsetPosition(referenceElement)[0] };\n\n        },\n\n        write(_ref3) {let { height, margin } = _ref3;\n          const { placeholder } = this;\n\n          css(placeholder, { height, margin });\n\n          if (!within(placeholder, document)) {\n            after(this.$el, placeholder);\n            placeholder.hidden = true;\n          }\n        },\n\n        events: ['resize'] },\n\n\n      {\n        read(_ref4)\n\n\n\n\n\n\n        {let { scroll: prevScroll = 0, dir: prevDir = 'down', overflow, overflowScroll = 0, start, end } = _ref4;\n          const scroll = scrollTop(window);\n          const dir = prevScroll <= scroll ? 'down' : 'up';\n\n          return {\n            dir,\n            prevDir,\n            scroll,\n            prevScroll,\n            offsetParentTop: offset(\n            (this.isFixed ? this.placeholder : this.$el).offsetParent).\n            top,\n            overflowScroll: clamp(\n            overflowScroll + clamp(scroll, start, end) - clamp(prevScroll, start, end),\n            0,\n            overflow) };\n\n\n        },\n\n        write(data, types) {\n          const isScrollUpdate = types.has('scroll');\n          const {\n            initTimestamp = 0,\n            dir,\n            prevDir,\n            scroll,\n            prevScroll = 0,\n            top,\n            start,\n            topOffset,\n            height } =\n          data;\n\n          if (\n          scroll < 0 ||\n          scroll === prevScroll && isScrollUpdate ||\n          this.showOnUp && !isScrollUpdate && !this.isFixed)\n          {\n            return;\n          }\n\n          const now = Date.now();\n          if (now - initTimestamp > 300 || dir !== prevDir) {\n            data.initScroll = scroll;\n            data.initTimestamp = now;\n          }\n\n          if (\n          this.showOnUp &&\n          !this.isFixed &&\n          Math.abs(data.initScroll - scroll) <= 30 &&\n          Math.abs(prevScroll - scroll) <= 10)\n          {\n            return;\n          }\n\n          if (\n          this.inactive ||\n          scroll < start ||\n          this.showOnUp && (\n          scroll <= start ||\n          dir === 'down' && isScrollUpdate ||\n          dir === 'up' && !this.isFixed && scroll <= topOffset + height))\n          {\n            if (!this.isFixed) {\n              if (Animation.inProgress(this.$el) && top > scroll) {\n                Animation.cancel(this.$el);\n                this.hide();\n              }\n\n              return;\n            }\n\n            this.isFixed = false;\n\n            if (this.animation && scroll > topOffset) {\n              Animation.cancel(this.$el);\n              Animation.out(this.$el, this.animation).then(() => this.hide(), noop);\n            } else {\n              this.hide();\n            }\n          } else if (this.isFixed) {\n            this.update();\n          } else if (this.animation && scroll > topOffset) {\n            Animation.cancel(this.$el);\n            this.show();\n            Animation.in(this.$el, this.animation).catch(noop);\n          } else {\n            this.show();\n          }\n        },\n\n        events: ['resize', 'scroll'] }],\n\n\n\n      methods: {\n        show() {\n          this.isFixed = true;\n          this.update();\n          this.placeholder.hidden = false;\n        },\n\n        hide() {\n          this.setActive(false);\n          removeClass(this.$el, this.clsFixed, this.clsBelow);\n          css(this.$el, { position: '', top: '', width: '' });\n          this.placeholder.hidden = true;\n        },\n\n        update() {\n          let {\n            width,\n            scroll = 0,\n            overflow,\n            overflowScroll = 0,\n            start,\n            end,\n            offset,\n            topOffset,\n            height,\n            offsetParentTop } =\n          this._data;\n          const active = start !== 0 || scroll > start;\n          let position = 'fixed';\n\n          if (scroll > end) {\n            offset += end - offsetParentTop;\n            position = 'absolute';\n          }\n\n          if (overflow) {\n            offset -= overflowScroll;\n          }\n\n          css(this.$el, {\n            position,\n            top: offset + \"px\",\n            width });\n\n\n          this.setActive(active);\n          toggleClass(this.$el, this.clsBelow, scroll > topOffset + height);\n          addClass(this.$el, this.clsFixed);\n        },\n\n        setActive(active) {\n          const prev = this.active;\n          this.active = active;\n          if (active) {\n            replaceClass(this.selTarget, this.clsInactive, this.clsActive);\n            prev !== active && trigger(this.$el, 'active');\n          } else {\n            replaceClass(this.selTarget, this.clsActive, this.clsInactive);\n            prev !== active && trigger(this.$el, 'inactive');\n          }\n        } } };\n\n\n\n    function parseProp(value, el, propOffset, padding) {\n      if (!value) {\n        return 0;\n      }\n\n      if (isNumeric(value) || isString(value) && value.match(/^-?\\d/)) {\n        return propOffset + toPx(value, 'height', el, true);\n      } else {\n        const refElement = value === true ? parent(el) : query(value, el);\n        return (\n          offset(refElement).bottom - (\n          padding && refElement && within(el, refElement) ?\n          toFloat(css(refElement, 'paddingBottom')) :\n          0));\n\n      }\n    }\n\n    function coerce(value) {\n      if (value === 'true') {\n        return true;\n      } else if (value === 'false') {\n        return false;\n      }\n      return value;\n    }\n\n    var Switcher = {\n      mixins: [Lazyload, Swipe, Togglable],\n\n      args: 'connect',\n\n      props: {\n        connect: String,\n        toggle: String,\n        itemNav: String,\n        active: Number },\n\n\n      data: {\n        connect: '~.uk-switcher',\n        toggle: '> * > :first-child',\n        itemNav: false,\n        active: 0,\n        cls: 'uk-active',\n        attrItem: 'uk-switcher-item' },\n\n\n      computed: {\n        connects: {\n          get(_ref, $el) {let { connect } = _ref;\n            return queryAll(connect, $el);\n          },\n\n          watch(connects) {\n            if (this.swiping) {\n              css(connects, 'touch-action', 'pan-y pinch-zoom');\n            }\n\n            const index = this.index();\n            this.connects.forEach((el) =>\n            children(el).forEach((child, i) => toggleClass(child, this.cls, i === index)));\n\n          },\n\n          immediate: true },\n\n\n        toggles: {\n          get(_ref2, $el) {let { toggle } = _ref2;\n            return $$(toggle, $el).filter(\n            (el) => !matches(el, '.uk-disabled *, .uk-disabled, [disabled]'));\n\n          },\n\n          watch(toggles) {\n            const active = this.index();\n            this.show(~active ? active : toggles[this.active] || toggles[0]);\n          },\n\n          immediate: true },\n\n\n        children() {\n          return children(this.$el).filter((child) =>\n          this.toggles.some((toggle) => within(toggle, child)));\n\n        },\n\n        swipeTarget() {\n          return this.connects;\n        } },\n\n\n      connected() {\n        this.lazyload(this.$el, this.connects);\n\n        // check for connects\n        ready(() => this.$emit());\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.toggle;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(e.current);\n        } },\n\n\n      {\n        name: 'click',\n\n        el() {\n          return this.connects.concat(this.itemNav ? queryAll(this.itemNav, this.$el) : []);\n        },\n\n        delegate() {\n          return \"[\" + this.attrItem + \"],[data-\" + this.attrItem + \"]\";\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(data(e.current, this.attrItem));\n        } },\n\n\n      {\n        name: 'swipeRight swipeLeft',\n\n        filter() {\n          return this.swiping;\n        },\n\n        el() {\n          return this.connects;\n        },\n\n        handler(_ref3) {let { type } = _ref3;\n          this.show(endsWith(type, 'Left') ? 'next' : 'previous');\n        } }],\n\n\n\n      methods: {\n        index() {\n          return findIndex(this.children, (el) => hasClass(el, this.cls));\n        },\n\n        show(item) {\n          const prev = this.index();\n          const next = getIndex(item, this.toggles, prev);\n          const active = getIndex(this.children[next], children(this.$el));\n          children(this.$el).forEach((child, i) => {\n            toggleClass(child, this.cls, active === i);\n            attr(this.toggles[i], 'aria-expanded', active === i);\n          });\n\n          const animate = prev >= 0 && prev !== next;\n          this.connects.forEach(async (_ref4) => {let { children } = _ref4;\n            await this.toggleElement(\n            toNodes(children).filter((child) => hasClass(child, this.cls)),\n            false,\n            animate);\n\n            await this.toggleElement(children[active], true, animate);\n          });\n        } } };\n\n    var tab = {\n      mixins: [Class],\n\n      extends: Switcher,\n\n      props: {\n        media: Boolean },\n\n\n      data: {\n        media: 960,\n        attrItem: 'uk-tab-item' },\n\n\n      connected() {\n        const cls = hasClass(this.$el, 'uk-tab-left') ?\n        'uk-tab-left' :\n        hasClass(this.$el, 'uk-tab-right') ?\n        'uk-tab-right' :\n        false;\n\n        if (cls) {\n          this.$create('toggle', this.$el, { cls, mode: 'media', media: this.media });\n        }\n      } };\n\n    const KEY_SPACE = 32;\n\n    var toggle = {\n      mixins: [Lazyload, Media, Togglable],\n\n      args: 'target',\n\n      props: {\n        href: String,\n        target: null,\n        mode: 'list',\n        queued: Boolean },\n\n\n      data: {\n        href: false,\n        target: false,\n        mode: 'click',\n        queued: true },\n\n\n      computed: {\n        target: {\n          get(_ref, $el) {let { href, target } = _ref;\n            target = queryAll(target || href, $el);\n            return target.length && target || [$el];\n          },\n\n          watch() {\n            this.updateAria();\n          },\n\n          immediate: true } },\n\n\n\n      connected() {\n        if (!includes(this.mode, 'media') && !isFocusable(this.$el)) {\n          attr(this.$el, 'tabindex', '0');\n        }\n\n        this.lazyload(this.$el, this.target);\n\n        // check for target\n        ready(() => this.$emit());\n      },\n\n      events: [\n      {\n        name: pointerDown,\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          if (!isTouch(e) || this._showState) {\n            return;\n          }\n\n          // Clicking a button does not give it focus on all browsers and platforms\n          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus\n          trigger(this.$el, 'focus');\n          once(\n          document,\n          pointerDown,\n          () => trigger(this.$el, 'blur'),\n          true,\n          (e) => !within(e.target, this.$el));\n\n\n          // Prevent initial click to prevent double toggle through focus + click\n          if (includes(this.mode, 'click')) {\n            this._preventClick = true;\n          }\n        } },\n\n\n      {\n        name: pointerEnter + \" \" + pointerLeave + \" focus blur\",\n\n        filter() {\n          return includes(this.mode, 'hover');\n        },\n\n        handler(e) {\n          if (isTouch(e)) {\n            return;\n          }\n\n          const show = includes([pointerEnter, 'focus'], e.type);\n          const expanded = attr(this.$el, 'aria-expanded');\n\n          // Skip hide if still hovered or focused\n          if (\n          !show && (\n          e.type === pointerLeave && matches(this.$el, ':focus') ||\n          e.type === 'blur' && matches(this.$el, ':hover')))\n          {\n            return;\n          }\n\n          // Skip if state does not change e.g. hover + focus received\n          if (this._showState && show && expanded !== this._showState) {\n            // Ensure reset if state has changed through click\n            if (!show) {\n              this._showState = null;\n            }\n            return;\n          }\n\n          this._showState = show ? expanded : null;\n\n          this.toggle(\"toggle\" + (show ? 'show' : 'hide'));\n        } },\n\n\n      {\n        name: 'keydown',\n\n        filter() {\n          return includes(this.mode, 'click') && !isTag(this.$el, 'input');\n        },\n\n        handler(e) {\n          if (e.keyCode === KEY_SPACE) {\n            e.preventDefault();\n            this.$el.click();\n          }\n        } },\n\n\n      {\n        name: 'click',\n\n        handler(e) {\n          let link;\n          if (\n          closest(e.target, 'a[href=\"#\"], a[href=\"\"]') ||\n          (link = closest(e.target, 'a[href]')) && (\n          attr(this.$el, 'aria-expanded') !== 'true' ||\n          link.hash && matches(this.target, link.hash)))\n          {\n            e.preventDefault();\n          }\n\n          if (this._preventClick) {\n            return this._preventClick = null;\n          }\n\n          if (!includes(this.mode, 'click')) {\n            return;\n          }\n\n          this.toggle();\n        } },\n\n\n      {\n        name: 'toggled',\n\n        self: true,\n\n        el() {\n          return this.target;\n        },\n\n        handler(e, toggled) {\n          if (e.target === this.target[0]) {\n            this.updateAria(toggled);\n          }\n        } },\n\n\n      {\n        name: 'mediachange',\n\n        filter() {\n          return includes(this.mode, 'media');\n        },\n\n        el() {\n          return this.target;\n        },\n\n        handler(e, mediaObj) {\n          if (mediaObj.matches ^ this.isToggled(this.target)) {\n            this.toggle();\n          }\n        } }],\n\n\n\n      methods: {\n        async toggle(type) {\n          if (!trigger(this.target, type || 'toggle', [this])) {\n            return;\n          }\n\n          if (!this.queued) {\n            return this.toggleElement(this.target);\n          }\n\n          const leaving = this.target.filter((el) => hasClass(el, this.clsLeave));\n\n          if (leaving.length) {\n            for (const el of this.target) {\n              const isLeaving = includes(leaving, el);\n              this.toggleElement(el, isLeaving, isLeaving);\n            }\n            return;\n          }\n\n          const toggled = this.target.filter(this.isToggled);\n          await this.toggleElement(toggled, false);\n          await this.toggleElement(\n          this.target.filter((el) => !includes(toggled, el)),\n          true);\n\n        },\n\n        updateAria(toggled) {\n          if (includes(this.mode, 'media')) {\n            return;\n          }\n\n          attr(\n          this.$el,\n          'aria-expanded',\n          isBoolean(toggled) ? toggled : this.isToggled(this.target));\n\n        } } };\n\n    var components$1 = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        Accordion: Accordion,\n        Alert: alert,\n        Cover: cover,\n        Drop: drop,\n        Dropdown: drop,\n        FormCustom: formCustom,\n        Grid: grid,\n        HeightMatch: heightMatch,\n        HeightViewport: heightViewport,\n        Icon: Icon,\n        Img: img,\n        Leader: leader,\n        Margin: Margin,\n        Modal: modal,\n        Nav: nav,\n        Navbar: navbar,\n        Offcanvas: offcanvas,\n        OverflowAuto: overflowAuto,\n        Responsive: responsive,\n        Scroll: scroll,\n        Scrollspy: scrollspy,\n        ScrollspyNav: scrollspyNav,\n        Sticky: sticky,\n        Svg: SVG,\n        Switcher: Switcher,\n        Tab: tab,\n        Toggle: toggle,\n        Video: Video,\n        Close: Close,\n        Spinner: Spinner,\n        SlidenavNext: Slidenav,\n        SlidenavPrevious: Slidenav,\n        SearchIcon: Search,\n        Marker: IconComponent,\n        NavbarToggleIcon: IconComponent,\n        OverlayIcon: IconComponent,\n        PaginationNext: IconComponent,\n        PaginationPrevious: IconComponent,\n        Totop: IconComponent\n    });\n\n    // register components\n    each(components$1, (component, name) => UIkit.component(name, component));\n\n    boot(UIkit);\n\n    const units = ['days', 'hours', 'minutes', 'seconds'];\n\n    var countdown = {\n      mixins: [Class],\n\n      props: {\n        date: String,\n        clsWrapper: String },\n\n\n      data: {\n        date: '',\n        clsWrapper: '.uk-countdown-%unit%' },\n\n\n      connected() {\n        this.date = Date.parse(this.$props.date);\n        this.start();\n      },\n\n      disconnected() {\n        this.stop();\n      },\n\n      events: [\n      {\n        name: 'visibilitychange',\n\n        el() {\n          return document;\n        },\n\n        handler() {\n          if (document.hidden) {\n            this.stop();\n          } else {\n            this.start();\n          }\n        } }],\n\n\n\n      methods: {\n        start() {\n          this.stop();\n          this.update();\n          this.timer = setInterval(this.update, 1000);\n        },\n\n        stop() {\n          clearInterval(this.timer);\n        },\n\n        update() {\n          const timespan = getTimeSpan(this.date);\n\n          if (!this.date || timespan.total <= 0) {\n            this.stop();\n\n            timespan.days = timespan.hours = timespan.minutes = timespan.seconds = 0;\n          }\n\n          for (const unit of units) {\n            const el = $(this.clsWrapper.replace('%unit%', unit), this.$el);\n\n            if (!el) {\n              continue;\n            }\n\n            let digits = String(Math.trunc(timespan[unit]));\n\n            digits = digits.length < 2 ? \"0\" + digits : digits;\n\n            if (el.textContent !== digits) {\n              digits = digits.split('');\n\n              if (digits.length !== el.children.length) {\n                html(el, digits.map(() => '<span></span>').join(''));\n              }\n\n              digits.forEach((digit, i) => el.children[i].textContent = digit);\n            }\n          }\n        } } };\n\n\n\n    function getTimeSpan(date) {\n      const total = date - Date.now();\n\n      return {\n        total,\n        seconds: total / 1000 % 60,\n        minutes: total / 1000 / 60 % 60,\n        hours: total / 1000 / 60 / 60 % 24,\n        days: total / 1000 / 60 / 60 / 24 };\n\n    }\n\n    const clsLeave = 'uk-transition-leave';\n    const clsEnter = 'uk-transition-enter';\n\n    function fade(action, target, duration, stagger) {if (stagger === void 0) {stagger = 0;}\n      const index = transitionIndex(target, true);\n      const propsIn = { opacity: 1 };\n      const propsOut = { opacity: 0 };\n\n      const wrapIndexFn = (fn) => () => index === transitionIndex(target) ? fn() : Promise.reject();\n\n      const leaveFn = wrapIndexFn(() => {\n        addClass(target, clsLeave);\n\n        return Promise.all(\n        getTransitionNodes(target).map(\n        (child, i) =>\n        new Promise((resolve) =>\n        setTimeout(\n        () =>\n        Transition.start(child, propsOut, duration / 2, 'ease').then(\n        resolve),\n\n        i * stagger)))).\n\n\n\n        then(() => removeClass(target, clsLeave));\n      });\n\n      const enterFn = wrapIndexFn(() => {\n        const oldHeight = height(target);\n\n        addClass(target, clsEnter);\n        action();\n\n        css(children(target), { opacity: 0 });\n\n        // Ensure UIkit updates have propagated\n        return new Promise((resolve) =>\n        requestAnimationFrame(() => {\n          const nodes = children(target);\n          const newHeight = height(target);\n\n          // Ensure Grid cells do not stretch when height is applied\n          css(target, 'alignContent', 'flex-start');\n          height(target, oldHeight);\n\n          const transitionNodes = getTransitionNodes(target);\n          css(nodes, propsOut);\n\n          const transitions = transitionNodes.map(\n          (child, i) =>\n          new Promise((resolve) =>\n          setTimeout(\n          () =>\n          Transition.start(child, propsIn, duration / 2, 'ease').then(\n          resolve),\n\n          i * stagger)));\n\n\n\n\n          if (oldHeight !== newHeight) {\n            transitions.push(\n            Transition.start(\n            target,\n            { height: newHeight },\n            duration / 2 + transitionNodes.length * stagger,\n            'ease'));\n\n\n          }\n\n          Promise.all(transitions).then(() => {\n            removeClass(target, clsEnter);\n            if (index === transitionIndex(target)) {\n              css(target, { height: '', alignContent: '' });\n              css(nodes, { opacity: '' });\n              delete target.dataset.transition;\n            }\n            resolve();\n          });\n        }));\n\n      });\n\n      return hasClass(target, clsLeave) ?\n      waitTransitionend(target).then(enterFn) :\n      hasClass(target, clsEnter) ?\n      waitTransitionend(target).then(leaveFn).then(enterFn) :\n      leaveFn().then(enterFn);\n    }\n\n    function transitionIndex(target, next) {\n      if (next) {\n        target.dataset.transition = 1 + transitionIndex(target);\n      }\n\n      return toNumber(target.dataset.transition) || 0;\n    }\n\n    function waitTransitionend(target) {\n      return Promise.all(\n      children(target).\n      filter(Transition.inProgress).\n      map(\n      (el) =>\n      new Promise((resolve) => once(el, 'transitionend transitioncanceled', resolve))));\n\n\n    }\n\n    function getTransitionNodes(target) {\n      return getRows(children(target)).reduce(\n      (nodes, row) =>\n      nodes.concat(\n      sortBy$1(\n      row.filter((el) => isInView(el)),\n      'offsetLeft')),\n\n\n      []);\n\n    }\n\n    function slide (action, target, duration) {\n      return new Promise((resolve) =>\n      requestAnimationFrame(() => {\n        let nodes = children(target);\n\n        // Get current state\n        const currentProps = nodes.map((el) => getProps(el, true));\n        const targetProps = css(target, ['height', 'padding']);\n\n        // Cancel previous animations\n        Transition.cancel(target);\n        nodes.forEach(Transition.cancel);\n        reset(target);\n\n        // Adding, sorting, removing nodes\n        action();\n\n        // Find new nodes\n        nodes = nodes.concat(children(target).filter((el) => !includes(nodes, el)));\n\n        // Wait for update to propagate\n        Promise.resolve().then(() => {\n          // Force update\n          fastdom.flush();\n\n          // Get new state\n          const targetPropsTo = css(target, ['height', 'padding']);\n          const [propsTo, propsFrom] = getTransitionProps(target, nodes, currentProps);\n\n          // Reset to previous state\n          nodes.forEach((el, i) => propsFrom[i] && css(el, propsFrom[i]));\n          css(target, { display: 'block', ...targetProps });\n\n          // Start transitions on next frame\n          requestAnimationFrame(() => {\n            const transitions = nodes.\n            map(\n            (el, i) =>\n            parent(el) === target &&\n            Transition.start(el, propsTo[i], duration, 'ease')).\n\n            concat(Transition.start(target, targetPropsTo, duration, 'ease'));\n\n            Promise.all(transitions).\n            then(() => {\n              nodes.forEach(\n              (el, i) =>\n              parent(el) === target &&\n              css(el, 'display', propsTo[i].opacity === 0 ? 'none' : ''));\n\n              reset(target);\n            }, noop).\n            then(resolve);\n          });\n        });\n      }));\n\n    }\n\n    function getProps(el, opacity) {\n      const zIndex = css(el, 'zIndex');\n\n      return isVisible(el) ?\n      {\n        display: '',\n        opacity: opacity ? css(el, 'opacity') : '0',\n        pointerEvents: 'none',\n        position: 'absolute',\n        zIndex: zIndex === 'auto' ? index(el) : zIndex,\n        ...getPositionWithMargin(el) } :\n\n      false;\n    }\n\n    function getTransitionProps(target, nodes, currentProps) {\n      const propsTo = nodes.map((el, i) =>\n      parent(el) && i in currentProps ?\n      currentProps[i] ?\n      isVisible(el) ?\n      getPositionWithMargin(el) :\n      { opacity: 0 } :\n      { opacity: isVisible(el) ? 1 : 0 } :\n      false);\n\n\n      const propsFrom = propsTo.map((props, i) => {\n        const from = parent(nodes[i]) === target && (currentProps[i] || getProps(nodes[i]));\n\n        if (!from) {\n          return false;\n        }\n\n        if (!props) {\n          delete from.opacity;\n        } else if (!('opacity' in props)) {\n          const { opacity } = from;\n\n          if (opacity % 1) {\n            props.opacity = 1;\n          } else {\n            delete from.opacity;\n          }\n        }\n\n        return from;\n      });\n\n      return [propsTo, propsFrom];\n    }\n\n    function reset(el) {\n      css(el.children, {\n        height: '',\n        left: '',\n        opacity: '',\n        pointerEvents: '',\n        position: '',\n        top: '',\n        marginTop: '',\n        marginLeft: '',\n        transform: '',\n        width: '',\n        zIndex: '' });\n\n      css(el, { height: '', display: '', padding: '' });\n    }\n\n    function getPositionWithMargin(el) {\n      const { height, width } = offset(el);\n      const { top, left } = position(el);\n      const { marginLeft, marginTop } = css(el, ['marginTop', 'marginLeft']);\n\n      return { top, left, height, width, marginLeft, marginTop, transform: '' };\n    }\n\n    var Animate = {\n      props: {\n        duration: Number,\n        animation: Boolean },\n\n\n      data: {\n        duration: 150,\n        animation: 'slide' },\n\n\n      methods: {\n        animate(action, target) {if (target === void 0) {target = this.$el;}\n          const name = this.animation;\n          const animationFn =\n          name === 'fade' ?\n          fade :\n          name === 'delayed-fade' ?\n          function () {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}return fade(...args, 40);} :\n          name ?\n          slide :\n          () => {\n            action();\n            return Promise.resolve();\n          };\n\n          return animationFn(action, target, this.duration).then(\n          () => this.$update(target, 'resize'),\n          noop);\n\n        } } };\n\n    var filter = {\n      mixins: [Animate],\n\n      args: 'target',\n\n      props: {\n        target: Boolean,\n        selActive: Boolean },\n\n\n      data: {\n        target: null,\n        selActive: false,\n        attrItem: 'uk-filter-control',\n        cls: 'uk-active',\n        duration: 250 },\n\n\n      computed: {\n        toggles: {\n          get(_ref, $el) {let { attrItem } = _ref;\n            return $$(\"[\" + attrItem + \"],[data-\" + attrItem + \"]\", $el);\n          },\n\n          watch() {\n            this.updateState();\n\n            if (this.selActive !== false) {\n              const actives = $$(this.selActive, this.$el);\n              this.toggles.forEach((el) => toggleClass(el, this.cls, includes(actives, el)));\n            }\n          },\n\n          immediate: true },\n\n\n        children: {\n          get(_ref2, $el) {let { target } = _ref2;\n            return $$(target + \" > *\", $el);\n          },\n\n          watch(list, old) {\n            if (old && !isEqualList(list, old)) {\n              this.updateState();\n            }\n          },\n\n          immediate: true } },\n\n\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return \"[\" + this.attrItem + \"],[data-\" + this.attrItem + \"]\";\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.apply(e.current);\n        } }],\n\n\n\n      methods: {\n        apply(el) {\n          const prevState = this.getState();\n          const newState = mergeState(el, this.attrItem, this.getState());\n\n          if (!isEqualState(prevState, newState)) {\n            this.setState(newState);\n          }\n        },\n\n        getState() {\n          return this.toggles.\n          filter((item) => hasClass(item, this.cls)).\n          reduce((state, el) => mergeState(el, this.attrItem, state), {\n            filter: { '': '' },\n            sort: [] });\n\n        },\n\n        setState(state, animate) {if (animate === void 0) {animate = true;}\n          state = { filter: { '': '' }, sort: [], ...state };\n\n          trigger(this.$el, 'beforeFilter', [this, state]);\n\n          this.toggles.forEach((el) =>\n          toggleClass(el, this.cls, !!matchFilter(el, this.attrItem, state)));\n\n\n          Promise.all(\n          $$(this.target, this.$el).map((target) => {\n            const filterFn = () => {\n              applyState(state, target, children(target));\n              this.$update(this.$el);\n            };\n            return animate ? this.animate(filterFn, target) : filterFn();\n          })).\n          then(() => trigger(this.$el, 'afterFilter', [this]));\n        },\n\n        updateState() {\n          fastdom.write(() => this.setState(this.getState(), false));\n        } } };\n\n\n\n    function getFilter(el, attr) {\n      return parseOptions(data(el, attr), ['filter']);\n    }\n\n    function isEqualState(stateA, stateB) {\n      return ['filter', 'sort'].every((prop) => isEqual(stateA[prop], stateB[prop]));\n    }\n\n    function applyState(state, target, children) {\n      const selector = getSelector(state);\n\n      children.forEach((el) => css(el, 'display', selector && !matches(el, selector) ? 'none' : ''));\n\n      const [sort, order] = state.sort;\n\n      if (sort) {\n        const sorted = sortItems(children, sort, order);\n        if (!isEqual(sorted, children)) {\n          append(target, sorted);\n        }\n      }\n    }\n\n    function mergeState(el, attr, state) {\n      const filterBy = getFilter(el, attr);\n      const { filter, group, sort, order = 'asc' } = filterBy;\n\n      if (filter || isUndefined(sort)) {\n        if (group) {\n          if (filter) {\n            delete state.filter[''];\n            state.filter[group] = filter;\n          } else {\n            delete state.filter[group];\n\n            if (isEmpty(state.filter) || '' in state.filter) {\n              state.filter = { '': filter || '' };\n            }\n          }\n        } else {\n          state.filter = { '': filter || '' };\n        }\n      }\n\n      if (!isUndefined(sort)) {\n        state.sort = [sort, order];\n      }\n\n      return state;\n    }\n\n    function matchFilter(\n    el,\n    attr, _ref3)\n\n    {let { filter: stateFilter = { '': '' }, sort: [stateSort, stateOrder] } = _ref3;\n      const { filter = '', group = '', sort, order = 'asc' } = getFilter(el, attr);\n\n      return isUndefined(sort) ?\n      group in stateFilter && filter === stateFilter[group] ||\n      !filter && group && !(group in stateFilter) && !stateFilter[''] :\n      stateSort === sort && stateOrder === order;\n    }\n\n    function isEqualList(listA, listB) {\n      return listA.length === listB.length && listA.every((el) => listB.includes(el));\n    }\n\n    function getSelector(_ref4) {let { filter } = _ref4;\n      let selector = '';\n      each(filter, (value) => selector += value || '');\n      return selector;\n    }\n\n    function sortItems(nodes, sort, order) {\n      return [...nodes].sort(\n      (a, b) =>\n      data(a, sort).localeCompare(data(b, sort), undefined, { numeric: true }) * (\n      order === 'asc' || -1));\n\n    }\n\n    var Animations$2 = {\n      slide: {\n        show(dir) {\n          return [{ transform: translate(dir * -100) }, { transform: translate() }];\n        },\n\n        percent(current) {\n          return translated(current);\n        },\n\n        translate(percent, dir) {\n          return [\n          { transform: translate(dir * -100 * percent) },\n          { transform: translate(dir * 100 * (1 - percent)) }];\n\n        } } };\n\n\n\n    function translated(el) {\n      return Math.abs(css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;\n    }\n\n    function translate(value, unit) {if (value === void 0) {value = 0;}if (unit === void 0) {unit = '%';}\n      value += value ? unit : '';\n      return \"translate3d(\" + value + \", 0, 0)\";\n    }\n\n    function scale3d(value) {\n      return \"scale3d(\" + value + \", \" + value + \", 1)\";\n    }\n\n    var Animations$1 = {\n      ...Animations$2,\n      fade: {\n        show() {\n          return [{ opacity: 0 }, { opacity: 1 }];\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [{ opacity: 1 - percent }, { opacity: percent }];\n        } },\n\n\n      scale: {\n        show() {\n          return [\n          { opacity: 0, transform: scale3d(1 - 0.2) },\n          { opacity: 1, transform: scale3d(1) }];\n\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [\n          { opacity: 1 - percent, transform: scale3d(1 - 0.2 * percent) },\n          { opacity: percent, transform: scale3d(1 - 0.2 + 0.2 * percent) }];\n\n        } } };\n\n    function Transitioner$1(prev, next, dir, _ref) {let { animation, easing } = _ref;\n      const { percent, translate, show = noop } = animation;\n      const props = show(dir);\n      const deferred = new Deferred();\n\n      return {\n        dir,\n\n        show(duration, percent, linear) {if (percent === void 0) {percent = 0;}\n          const timing = linear ? 'linear' : easing;\n          duration -= Math.round(duration * clamp(percent, -1, 1));\n\n          this.translate(percent);\n\n          triggerUpdate$1(next, 'itemin', { percent, duration, timing, dir });\n          triggerUpdate$1(prev, 'itemout', { percent: 1 - percent, duration, timing, dir });\n\n          Promise.all([\n          Transition.start(next, props[1], duration, timing),\n          Transition.start(prev, props[0], duration, timing)]).\n          then(() => {\n            this.reset();\n            deferred.resolve();\n          }, noop);\n\n          return deferred.promise;\n        },\n\n        cancel() {\n          Transition.cancel([next, prev]);\n        },\n\n        reset() {\n          for (const prop in props[0]) {\n            css([next, prev], prop, '');\n          }\n        },\n\n        forward(duration, percent) {if (percent === void 0) {percent = this.percent();}\n          Transition.cancel([next, prev]);\n          return this.show(duration, percent, true);\n        },\n\n        translate(percent) {\n          this.reset();\n\n          const props = translate(percent, dir);\n          css(next, props[1]);\n          css(prev, props[0]);\n          triggerUpdate$1(next, 'itemtranslatein', { percent, dir });\n          triggerUpdate$1(prev, 'itemtranslateout', { percent: 1 - percent, dir });\n        },\n\n        percent() {\n          return percent(prev || next, next, dir);\n        },\n\n        getDistance() {\n          return prev == null ? void 0 : prev.offsetWidth;\n        } };\n\n    }\n\n    function triggerUpdate$1(el, type, data) {\n      trigger(el, createEvent(type, false, false, data));\n    }\n\n    var SliderAutoplay = {\n      props: {\n        autoplay: Boolean,\n        autoplayInterval: Number,\n        pauseOnHover: Boolean },\n\n\n      data: {\n        autoplay: false,\n        autoplayInterval: 7000,\n        pauseOnHover: true },\n\n\n      connected() {\n        this.autoplay && this.startAutoplay();\n      },\n\n      disconnected() {\n        this.stopAutoplay();\n      },\n\n      update() {\n        attr(this.slides, 'tabindex', '-1');\n      },\n\n      events: [\n      {\n        name: 'visibilitychange',\n\n        el() {\n          return document;\n        },\n\n        filter() {\n          return this.autoplay;\n        },\n\n        handler() {\n          if (document.hidden) {\n            this.stopAutoplay();\n          } else {\n            this.startAutoplay();\n          }\n        } }],\n\n\n\n      methods: {\n        startAutoplay() {\n          this.stopAutoplay();\n\n          this.interval = setInterval(\n          () =>\n          (!this.draggable || !$(':focus', this.$el)) && (\n          !this.pauseOnHover || !matches(this.$el, ':hover')) &&\n          !this.stack.length &&\n          this.show('next'),\n          this.autoplayInterval);\n\n        },\n\n        stopAutoplay() {\n          this.interval && clearInterval(this.interval);\n        } } };\n\n    var SliderDrag = {\n      props: {\n        draggable: Boolean },\n\n\n      data: {\n        draggable: true,\n        threshold: 10 },\n\n\n      created() {\n        for (const key of ['start', 'move', 'end']) {\n          const fn = this[key];\n          this[key] = (e) => {\n            const pos = getEventPos(e).x * (isRtl ? -1 : 1);\n\n            this.prevPos = pos === this.pos ? this.prevPos : this.pos;\n            this.pos = pos;\n\n            fn(e);\n          };\n        }\n      },\n\n      events: [\n      {\n        name: pointerDown,\n\n        delegate() {\n          return this.selSlides;\n        },\n\n        handler(e) {\n          if (\n          !this.draggable ||\n          !isTouch(e) && hasTextNodesOnly(e.target) ||\n          closest(e.target, selInput) ||\n          e.button > 0 ||\n          this.length < 2)\n          {\n            return;\n          }\n\n          this.start(e);\n        } },\n\n\n      {\n        name: 'dragstart',\n\n        handler(e) {\n          e.preventDefault();\n        } }],\n\n\n\n      methods: {\n        start() {\n          this.drag = this.pos;\n\n          if (this._transitioner) {\n            this.percent = this._transitioner.percent();\n            this.drag += this._transitioner.getDistance() * this.percent * this.dir;\n\n            this._transitioner.cancel();\n            this._transitioner.translate(this.percent);\n\n            this.dragging = true;\n\n            this.stack = [];\n          } else {\n            this.prevIndex = this.index;\n          }\n\n          on(document, pointerMove, this.move, { passive: false });\n\n          // 'input' event is triggered by video controls\n          on(document, pointerUp + \" \" + pointerCancel + \" input\", this.end, true);\n\n          css(this.list, 'userSelect', 'none');\n        },\n\n        move(e) {\n          const distance = this.pos - this.drag;\n\n          if (\n          distance === 0 ||\n          this.prevPos === this.pos ||\n          !this.dragging && Math.abs(distance) < this.threshold)\n          {\n            return;\n          }\n\n          // prevent click event\n          css(this.list, 'pointerEvents', 'none');\n\n          e.cancelable && e.preventDefault();\n\n          this.dragging = true;\n          this.dir = distance < 0 ? 1 : -1;\n\n          const { slides } = this;\n          let { prevIndex } = this;\n          let dis = Math.abs(distance);\n          let nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n          let width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n\n          while (nextIndex !== prevIndex && dis > width) {\n            this.drag -= width * this.dir;\n\n            prevIndex = nextIndex;\n            dis -= width;\n            nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n            width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n          }\n\n          this.percent = dis / width;\n\n          const prev = slides[prevIndex];\n          const next = slides[nextIndex];\n          const changed = this.index !== nextIndex;\n          const edge = prevIndex === nextIndex;\n\n          let itemShown;\n\n          [this.index, this.prevIndex].\n          filter((i) => !includes([nextIndex, prevIndex], i)).\n          forEach((i) => {\n            trigger(slides[i], 'itemhidden', [this]);\n\n            if (edge) {\n              itemShown = true;\n              this.prevIndex = prevIndex;\n            }\n          });\n\n          if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {\n            trigger(slides[this.index], 'itemshown', [this]);\n          }\n\n          if (changed) {\n            this.prevIndex = prevIndex;\n            this.index = nextIndex;\n\n            !edge && trigger(prev, 'beforeitemhide', [this]);\n            trigger(next, 'beforeitemshow', [this]);\n          }\n\n          this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);\n\n          if (changed) {\n            !edge && trigger(prev, 'itemhide', [this]);\n            trigger(next, 'itemshow', [this]);\n          }\n        },\n\n        end() {\n          off(document, pointerMove, this.move, { passive: false });\n          off(document, pointerUp + \" \" + pointerCancel + \" input\", this.end, true);\n\n          if (this.dragging) {\n            this.dragging = null;\n\n            if (this.index === this.prevIndex) {\n              this.percent = 1 - this.percent;\n              this.dir *= -1;\n              this._show(false, this.index, true);\n              this._transitioner = null;\n            } else {\n              const dirChange =\n              (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 ===\n              this.prevPos > this.pos;\n              this.index = dirChange ? this.index : this.prevIndex;\n\n              if (dirChange) {\n                this.percent = 1 - this.percent;\n              }\n\n              this.show(\n              this.dir > 0 && !dirChange || this.dir < 0 && dirChange ?\n              'next' :\n              'previous',\n              true);\n\n            }\n          }\n\n          css(this.list, { userSelect: '', pointerEvents: '' });\n\n          this.drag = this.percent = null;\n        } } };\n\n\n\n    function hasTextNodesOnly(el) {\n      return !el.children.length && el.childNodes.length;\n    }\n\n    var SliderNav = {\n      data: {\n        selNav: false },\n\n\n      computed: {\n        nav(_ref, $el) {let { selNav } = _ref;\n          return $(selNav, $el);\n        },\n\n        selNavItem(_ref2) {let { attrItem } = _ref2;\n          return \"[\" + attrItem + \"],[data-\" + attrItem + \"]\";\n        },\n\n        navItems(_, $el) {\n          return $$(this.selNavItem, $el);\n        } },\n\n\n      update: {\n        write() {\n          if (this.nav && this.length !== this.nav.children.length) {\n            html(\n            this.nav,\n            this.slides.\n            map((_, i) => \"<li \" + this.attrItem + \"=\\\"\" + i + \"\\\"><a href></a></li>\").\n            join(''));\n\n          }\n\n          this.navItems.concat(this.nav).forEach((el) => el && (el.hidden = !this.maxIndex));\n\n          this.updateNav();\n        },\n\n        events: ['resize'] },\n\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.selNavItem;\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(data(e.current, this.attrItem));\n        } },\n\n\n      {\n        name: 'itemshow',\n        handler: 'updateNav' }],\n\n\n\n      methods: {\n        updateNav() {\n          const i = this.getValidIndex();\n          for (const el of this.navItems) {\n            const cmd = data(el, this.attrItem);\n\n            toggleClass(el, this.clsActive, toNumber(cmd) === i);\n            toggleClass(\n            el,\n            'uk-invisible',\n            this.finite && (\n            cmd === 'previous' && i === 0 || cmd === 'next' && i >= this.maxIndex));\n\n          }\n        } } };\n\n    var Slider = {\n      mixins: [SliderAutoplay, SliderDrag, SliderNav, Resize],\n\n      props: {\n        clsActivated: Boolean,\n        easing: String,\n        index: Number,\n        finite: Boolean,\n        velocity: Number,\n        selSlides: String },\n\n\n      data: () => ({\n        easing: 'ease',\n        finite: false,\n        velocity: 1,\n        index: 0,\n        prevIndex: -1,\n        stack: [],\n        percent: 0,\n        clsActive: 'uk-active',\n        clsActivated: false,\n        Transitioner: false,\n        transitionOptions: {} }),\n\n\n      connected() {\n        this.prevIndex = -1;\n        this.index = this.getValidIndex(this.$props.index);\n        this.stack = [];\n      },\n\n      disconnected() {\n        removeClass(this.slides, this.clsActive);\n      },\n\n      computed: {\n        duration(_ref, $el) {let { velocity } = _ref;\n          return speedUp($el.offsetWidth / velocity);\n        },\n\n        list(_ref2, $el) {let { selList } = _ref2;\n          return $(selList, $el);\n        },\n\n        maxIndex() {\n          return this.length - 1;\n        },\n\n        selSlides(_ref3) {let { selList, selSlides } = _ref3;\n          return selList + \" \" + (selSlides || '> *');\n        },\n\n        slides: {\n          get() {\n            return $$(this.selSlides, this.$el);\n          },\n\n          watch() {\n            this.$reset();\n          } },\n\n\n        length() {\n          return this.slides.length;\n        } },\n\n\n      methods: {\n        show(index, force) {if (force === void 0) {force = false;}\n          if (this.dragging || !this.length) {\n            return;\n          }\n\n          const { stack } = this;\n          const queueIndex = force ? 0 : stack.length;\n          const reset = () => {\n            stack.splice(queueIndex, 1);\n\n            if (stack.length) {\n              this.show(stack.shift(), true);\n            }\n          };\n\n          stack[force ? 'unshift' : 'push'](index);\n\n          if (!force && stack.length > 1) {\n            if (stack.length === 2) {\n              this._transitioner.forward(Math.min(this.duration, 200));\n            }\n\n            return;\n          }\n\n          const prevIndex = this.getIndex(this.index);\n          const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];\n          const nextIndex = this.getIndex(index, this.index);\n          const next = this.slides[nextIndex];\n\n          if (prev === next) {\n            reset();\n            return;\n          }\n\n          this.dir = getDirection(index, prevIndex);\n          this.prevIndex = prevIndex;\n          this.index = nextIndex;\n\n          if (\n          prev && !trigger(prev, 'beforeitemhide', [this]) ||\n          !trigger(next, 'beforeitemshow', [this, prev]))\n          {\n            this.index = this.prevIndex;\n            reset();\n            return;\n          }\n\n          const promise = this._show(prev, next, force).then(() => {\n            prev && trigger(prev, 'itemhidden', [this]);\n            trigger(next, 'itemshown', [this]);\n\n            return new Promise((resolve) => {\n              fastdom.write(() => {\n                stack.shift();\n                if (stack.length) {\n                  this.show(stack.shift(), true);\n                } else {\n                  this._transitioner = null;\n                }\n                resolve();\n              });\n            });\n          });\n\n          prev && trigger(prev, 'itemhide', [this]);\n          trigger(next, 'itemshow', [this]);\n\n          return promise;\n        },\n\n        getIndex(index, prev) {if (index === void 0) {index = this.index;}if (prev === void 0) {prev = this.index;}\n          return clamp(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);\n        },\n\n        getValidIndex(index, prevIndex) {if (index === void 0) {index = this.index;}if (prevIndex === void 0) {prevIndex = this.prevIndex;}\n          return this.getIndex(index, prevIndex);\n        },\n\n        _show(prev, next, force) {\n          this._transitioner = this._getTransitioner(prev, next, this.dir, {\n            easing: force ?\n            next.offsetWidth < 600 ?\n            'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */ :\n            'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */ :\n            this.easing,\n            ...this.transitionOptions });\n\n\n          if (!force && !prev) {\n            this._translate(1);\n            return Promise.resolve();\n          }\n\n          const { length } = this.stack;\n          return this._transitioner[length > 1 ? 'forward' : 'show'](\n          length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration,\n          this.percent);\n\n        },\n\n        _getDistance(prev, next) {\n          return this._getTransitioner(prev, prev !== next && next).getDistance();\n        },\n\n        _translate(percent, prev, next) {if (prev === void 0) {prev = this.prevIndex;}if (next === void 0) {next = this.index;}\n          const transitioner = this._getTransitioner(prev !== next ? prev : false, next);\n          transitioner.translate(percent);\n          return transitioner;\n        },\n\n        _getTransitioner(\n        prev,\n        next,\n        dir,\n        options)\n        {if (prev === void 0) {prev = this.prevIndex;}if (next === void 0) {next = this.index;}if (dir === void 0) {dir = this.dir || 1;}if (options === void 0) {options = this.transitionOptions;}\n          return new this.Transitioner(\n          isNumber(prev) ? this.slides[prev] : prev,\n          isNumber(next) ? this.slides[next] : next,\n          dir * (isRtl ? -1 : 1),\n          options);\n\n        } } };\n\n\n\n    function getDirection(index, prevIndex) {\n      return index === 'next' ? 1 : index === 'previous' ? -1 : index < prevIndex ? -1 : 1;\n    }\n\n    function speedUp(x) {\n      return 0.5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)\n    }\n\n    var Slideshow = {\n      mixins: [Slider],\n\n      props: {\n        animation: String },\n\n\n      data: {\n        animation: 'slide',\n        clsActivated: 'uk-transition-active',\n        Animations: Animations$2,\n        Transitioner: Transitioner$1 },\n\n\n      computed: {\n        animation(_ref) {let { animation, Animations } = _ref;\n          return { ...(Animations[animation] || Animations.slide), name: animation };\n        },\n\n        transitionOptions() {\n          return { animation: this.animation };\n        } },\n\n\n      events: {\n        beforeitemshow(_ref2) {let { target } = _ref2;\n          addClass(target, this.clsActive);\n        },\n\n        itemshown(_ref3) {let { target } = _ref3;\n          addClass(target, this.clsActivated);\n        },\n\n        itemhidden(_ref4) {let { target } = _ref4;\n          removeClass(target, this.clsActive, this.clsActivated);\n        } } };\n\n    var LightboxPanel = {\n      mixins: [Container, Modal, Togglable, Slideshow],\n\n      functional: true,\n\n      props: {\n        delayControls: Number,\n        preload: Number,\n        videoAutoplay: Boolean,\n        template: String },\n\n\n      data: () => ({\n        preload: 1,\n        videoAutoplay: false,\n        delayControls: 3000,\n        items: [],\n        cls: 'uk-open',\n        clsPage: 'uk-lightbox-page',\n        selList: '.uk-lightbox-items',\n        attrItem: 'uk-lightbox-item',\n        selClose: '.uk-close-large',\n        selCaption: '.uk-lightbox-caption',\n        pauseOnHover: false,\n        velocity: 2,\n        Animations: Animations$1,\n        template: \"<div class=\\\"uk-lightbox uk-overflow-hidden\\\"> <ul class=\\\"uk-lightbox-items\\\"></ul> <div class=\\\"uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque\\\"> <button class=\\\"uk-lightbox-toolbar-icon uk-close-large\\\" type=\\\"button\\\" uk-close></button> </div> <a class=\\\"uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade\\\" href uk-slidenav-previous uk-lightbox-item=\\\"previous\\\"></a> <a class=\\\"uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade\\\" href uk-slidenav-next uk-lightbox-item=\\\"next\\\"></a> <div class=\\\"uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque\\\"></div> </div>\" }),\n\n\n\n\n\n\n\n\n\n\n      created() {\n        const $el = $(this.template);\n        const list = $(this.selList, $el);\n        this.items.forEach(() => append(list, '<li>'));\n\n        this.$mount(append(this.container, $el));\n      },\n\n      computed: {\n        caption(_ref, $el) {let { selCaption } = _ref;\n          return $(selCaption, $el);\n        } },\n\n\n      events: [\n      {\n        name: pointerMove + \" \" + pointerDown + \" keydown\",\n\n        handler: 'showControls' },\n\n\n      {\n        name: 'click',\n\n        self: true,\n\n        delegate() {\n          return this.selSlides;\n        },\n\n        handler(e) {\n          if (e.defaultPrevented) {\n            return;\n          }\n\n          this.hide();\n        } },\n\n\n      {\n        name: 'shown',\n\n        self: true,\n\n        handler() {\n          this.showControls();\n        } },\n\n\n      {\n        name: 'hide',\n\n        self: true,\n\n        handler() {\n          this.hideControls();\n\n          removeClass(this.slides, this.clsActive);\n          Transition.stop(this.slides);\n        } },\n\n\n      {\n        name: 'hidden',\n\n        self: true,\n\n        handler() {\n          this.$destroy(true);\n        } },\n\n\n      {\n        name: 'keyup',\n\n        el() {\n          return document;\n        },\n\n        handler(e) {\n          if (!this.isToggled(this.$el) || !this.draggable) {\n            return;\n          }\n\n          switch (e.keyCode) {\n            case 37:\n              this.show('previous');\n              break;\n            case 39:\n              this.show('next');\n              break;}\n\n        } },\n\n\n      {\n        name: 'beforeitemshow',\n\n        handler(e) {\n          if (this.isToggled()) {\n            return;\n          }\n\n          this.draggable = false;\n\n          e.preventDefault();\n\n          this.toggleElement(this.$el, true, false);\n\n          this.animation = Animations$1['scale'];\n          removeClass(e.target, this.clsActive);\n          this.stack.splice(1, 0, this.index);\n        } },\n\n\n      {\n        name: 'itemshow',\n\n        handler() {\n          html(this.caption, this.getItem().caption || '');\n\n          for (let j = -this.preload; j <= this.preload; j++) {\n            this.loadItem(this.index + j);\n          }\n        } },\n\n\n      {\n        name: 'itemshown',\n\n        handler() {\n          this.draggable = this.$props.draggable;\n        } },\n\n\n      {\n        name: 'itemload',\n\n        async handler(_, item) {\n          const { source: src, type, alt = '', poster, attrs = {} } = item;\n\n          this.setItem(item, '<span uk-spinner></span>');\n\n          if (!src) {\n            return;\n          }\n\n          let matches;\n          const iframeAttrs = {\n            frameborder: '0',\n            allow: 'autoplay',\n            allowfullscreen: '',\n            style: 'max-width: 100%; box-sizing: border-box;',\n            'uk-responsive': '',\n            'uk-video': \"\" + this.videoAutoplay };\n\n\n          // Image\n          if (\n          type === 'image' ||\n          src.match(/\\.(avif|jpe?g|jfif|a?png|gif|svg|webp)($|\\?)/i))\n          {\n            try {\n              const { width, height } = await getImage(src, attrs.srcset, attrs.size);\n              this.setItem(item, createEl('img', { src, width, height, alt, ...attrs }));\n            } catch (e) {\n              this.setError(item);\n            }\n\n            // Video\n          } else if (type === 'video' || src.match(/\\.(mp4|webm|ogv)($|\\?)/i)) {\n            const video = createEl('video', {\n              src,\n              poster,\n              controls: '',\n              playsinline: '',\n              'uk-video': \"\" + this.videoAutoplay,\n              ...attrs });\n\n\n            on(video, 'loadedmetadata', () => {\n              attr(video, { width: video.videoWidth, height: video.videoHeight });\n              this.setItem(item, video);\n            });\n            on(video, 'error', () => this.setError(item));\n\n            // Iframe\n          } else if (type === 'iframe' || src.match(/\\.(html|php)($|\\?)/i)) {\n            this.setItem(\n            item,\n            createEl('iframe', {\n              src,\n              frameborder: '0',\n              allowfullscreen: '',\n              class: 'uk-lightbox-iframe',\n              ...attrs }));\n\n\n\n            // YouTube\n          } else if (\n          matches = src.match(\n          /\\/\\/(?:.*?youtube(-nocookie)?\\..*?[?&]v=|youtu\\.be\\/)([\\w-]{11})[&?]?(.*)?/))\n\n          {\n            this.setItem(\n            item,\n            createEl('iframe', {\n              src: \"https://www.youtube\" + (matches[1] || '') + \".com/embed/\" + matches[2] + (\n              matches[3] ? \"?\" + matches[3] : ''),\n\n              width: 1920,\n              height: 1080,\n              ...iframeAttrs,\n              ...attrs }));\n\n\n\n            // Vimeo\n          } else if (matches = src.match(/\\/\\/.*?vimeo\\.[a-z]+\\/(\\d+)[&?]?(.*)?/)) {\n            try {\n              const { height, width } = await (\n              await fetch(\"https://vimeo.com/api/oembed.json?maxwidth=1920&url=\" +\n              encodeURI(\n              src),\n\n              {\n                credentials: 'omit' })).\n\n\n              json();\n\n              this.setItem(\n              item,\n              createEl('iframe', {\n                src: \"https://player.vimeo.com/video/\" + matches[1] + (\n                matches[2] ? \"?\" + matches[2] : ''),\n\n                width,\n                height,\n                ...iframeAttrs,\n                ...attrs }));\n\n\n            } catch (e) {\n              this.setError(item);\n            }\n          }\n        } }],\n\n\n\n      methods: {\n        loadItem(index) {if (index === void 0) {index = this.index;}\n          const item = this.getItem(index);\n\n          if (!this.getSlide(item).childElementCount) {\n            trigger(this.$el, 'itemload', [item]);\n          }\n        },\n\n        getItem(index) {if (index === void 0) {index = this.index;}\n          return this.items[getIndex(index, this.slides)];\n        },\n\n        setItem(item, content) {\n          trigger(this.$el, 'itemloaded', [this, html(this.getSlide(item), content)]);\n        },\n\n        getSlide(item) {\n          return this.slides[this.items.indexOf(item)];\n        },\n\n        setError(item) {\n          this.setItem(item, '<span uk-icon=\"icon: bolt; ratio: 2\"></span>');\n        },\n\n        showControls() {\n          clearTimeout(this.controlsTimer);\n          this.controlsTimer = setTimeout(this.hideControls, this.delayControls);\n\n          addClass(this.$el, 'uk-active', 'uk-transition-active');\n        },\n\n        hideControls() {\n          removeClass(this.$el, 'uk-active', 'uk-transition-active');\n        } } };\n\n\n\n    function createEl(tag, attrs) {\n      const el = fragment(\"<\" + tag + \">\");\n      attr(el, attrs);\n      return el;\n    }\n\n    var lightbox = {\n      install: install$1,\n\n      props: { toggle: String },\n\n      data: { toggle: 'a' },\n\n      computed: {\n        toggles: {\n          get(_ref, $el) {let { toggle } = _ref;\n            return $$(toggle, $el);\n          },\n\n          watch() {\n            this.hide();\n          } } },\n\n\n\n      disconnected() {\n        this.hide();\n      },\n\n      events: [\n      {\n        name: 'click',\n\n        delegate() {\n          return this.toggle + \":not(.uk-disabled)\";\n        },\n\n        handler(e) {\n          e.preventDefault();\n          this.show(e.current);\n        } }],\n\n\n\n      methods: {\n        show(index) {\n          const items = uniqueBy(this.toggles.map(toItem), 'source');\n\n          if (isElement(index)) {\n            const { source } = toItem(index);\n            index = findIndex(items, (_ref2) => {let { source: src } = _ref2;return source === src;});\n          }\n\n          this.panel = this.panel || this.$create('lightboxPanel', { ...this.$props, items });\n\n          on(this.panel.$el, 'hidden', () => this.panel = false);\n\n          return this.panel.show(index);\n        },\n\n        hide() {var _this$panel;\n          return (_this$panel = this.panel) == null ? void 0 : _this$panel.hide();\n        } } };\n\n\n\n    function install$1(UIkit, Lightbox) {\n      if (!UIkit.lightboxPanel) {\n        UIkit.component('lightboxPanel', LightboxPanel);\n      }\n\n      assign(Lightbox.props, UIkit.component('lightboxPanel').options.props);\n    }\n\n    function toItem(el) {\n      const item = {};\n\n      for (const attr of ['href', 'caption', 'type', 'poster', 'alt', 'attrs']) {\n        item[attr === 'href' ? 'source' : attr] = data(el, attr);\n      }\n\n      item.attrs = parseOptions(item.attrs);\n\n      return item;\n    }\n\n    var notification = {\n      mixins: [Container],\n\n      functional: true,\n\n      args: ['message', 'status'],\n\n      data: {\n        message: '',\n        status: '',\n        timeout: 5000,\n        group: null,\n        pos: 'top-center',\n        clsContainer: 'uk-notification',\n        clsClose: 'uk-notification-close',\n        clsMsg: 'uk-notification-message' },\n\n\n      install,\n\n      computed: {\n        marginProp(_ref) {let { pos } = _ref;\n          return \"margin\" + (startsWith(pos, 'top') ? 'Top' : 'Bottom');\n        },\n\n        startProps() {\n          return { opacity: 0, [this.marginProp]: -this.$el.offsetHeight };\n        } },\n\n\n      created() {\n        const container =\n        $(\".\" + this.clsContainer + \"-\" + this.pos, this.container) ||\n        append(\n        this.container, \"<div class=\\\"\" +\n        this.clsContainer + \" \" + this.clsContainer + \"-\" + this.pos + \"\\\" style=\\\"display: block\\\"></div>\");\n\n\n        this.$mount(\n        append(\n        container, \"<div class=\\\"\" +\n        this.clsMsg + (this.status ? \" \" + this.clsMsg + \"-\" + this.status : '') + \"\\\"> <a href class=\\\"\" +\n        this.clsClose + \"\\\" data-uk-close></a> <div>\" +\n        this.message + \"</div> </div>\"));\n\n\n\n      },\n\n      async connected() {\n        const margin = toFloat(css(this.$el, this.marginProp));\n        await Transition.start(css(this.$el, this.startProps), {\n          opacity: 1,\n          [this.marginProp]: margin });\n\n\n        if (this.timeout) {\n          this.timer = setTimeout(this.close, this.timeout);\n        }\n      },\n\n      events: {\n        click(e) {\n          if (closest(e.target, 'a[href=\"#\"],a[href=\"\"]')) {\n            e.preventDefault();\n          }\n          this.close();\n        },\n\n        [pointerEnter]() {\n          if (this.timer) {\n            clearTimeout(this.timer);\n          }\n        },\n\n        [pointerLeave]() {\n          if (this.timeout) {\n            this.timer = setTimeout(this.close, this.timeout);\n          }\n        } },\n\n\n      methods: {\n        async close(immediate) {\n          const removeFn = (el) => {\n            const container = parent(el);\n\n            trigger(el, 'close', [this]);\n            remove$1(el);\n\n            if (!(container != null && container.hasChildNodes())) {\n              remove$1(container);\n            }\n          };\n\n          if (this.timer) {\n            clearTimeout(this.timer);\n          }\n\n          if (!immediate) {\n            await Transition.start(this.$el, this.startProps);\n          }\n\n          removeFn(this.$el);\n        } } };\n\n\n\n    function install(UIkit) {\n      UIkit.notification.closeAll = function (group, immediate) {\n        apply(document.body, (el) => {\n          const notification = UIkit.getComponent(el, 'notification');\n          if (notification && (!group || group === notification.group)) {\n            notification.close(immediate);\n          }\n        });\n      };\n    }\n\n    const props = {\n      x: transformFn,\n      y: transformFn,\n      rotate: transformFn,\n      scale: transformFn,\n      color: colorFn,\n      backgroundColor: colorFn,\n      borderColor: colorFn,\n      blur: filterFn,\n      hue: filterFn,\n      fopacity: filterFn,\n      grayscale: filterFn,\n      invert: filterFn,\n      saturate: filterFn,\n      sepia: filterFn,\n      opacity: cssPropFn,\n      stroke: strokeFn,\n      bgx: backgroundFn,\n      bgy: backgroundFn };\n\n\n    const { keys } = Object;\n\n    var Parallax = {\n      mixins: [Media],\n\n      props: fillObject(keys(props), 'list'),\n\n      data: fillObject(keys(props), undefined),\n\n      computed: {\n        props(properties, $el) {\n          return keys(props).reduce((result, prop) => {\n            if (!isUndefined(properties[prop])) {\n              result[prop] = props[prop](prop, $el, properties[prop].slice());\n            }\n            return result;\n          }, {});\n        } },\n\n\n      events: {\n        load() {\n          this.$emit();\n        } },\n\n\n      methods: {\n        reset() {\n          for (const prop in this.getCss(0)) {\n            css(this.$el, prop, '');\n          }\n        },\n\n        getCss(percent) {\n          const css = { transform: '', filter: '' };\n          for (const prop in this.props) {\n            this.props[prop](css, percent);\n          }\n          return css;\n        } } };\n\n\n\n    function transformFn(prop, el, stops) {\n      let unit = getUnit(stops) || { x: 'px', y: 'px', rotate: 'deg' }[prop] || '';\n      let transformFn;\n\n      if (prop === 'x' || prop === 'y') {\n        prop = \"translate\" + ucfirst(prop);\n        transformFn = (stop) => toFloat(toFloat(stop).toFixed(unit === 'px' ? 0 : 6));\n      } else if (prop === 'scale') {\n        unit = '';\n        transformFn = (stop) =>\n        getUnit([stop]) ? toPx(stop, 'width', el, true) / el.offsetWidth : stop;\n      }\n\n      if (stops.length === 1) {\n        stops.unshift(prop === 'scale' ? 1 : 0);\n      }\n\n      stops = parseStops(stops, transformFn);\n\n      return (css, percent) => {\n        css.transform += \" \" + prop + \"(\" + getValue(stops, percent) + unit + \")\";\n      };\n    }\n\n    function colorFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(getCssValue(el, prop, ''));\n      }\n\n      stops = parseStops(stops, (stop) => parseColor(el, stop));\n\n      return (css, percent) => {\n        const [start, end, p] = getStop(stops, percent);\n        const value = start.\n        map((value, i) => {\n          value += p * (end[i] - value);\n          return i === 3 ? toFloat(value) : parseInt(value, 10);\n        }).\n        join(',');\n        css[prop] = \"rgba(\" + value + \")\";\n      };\n    }\n\n    function parseColor(el, color) {\n      return getCssValue(el, 'color', color).\n      split(/[(),]/g).\n      slice(1, -1).\n      concat(1).\n      slice(0, 4).\n      map(toFloat);\n    }\n\n    function filterFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(0);\n      }\n\n      const unit = getUnit(stops) || { blur: 'px', hue: 'deg' }[prop] || '%';\n      prop = { fopacity: 'opacity', hue: 'hue-rotate' }[prop] || prop;\n      stops = parseStops(stops);\n\n      return (css, percent) => {\n        const value = getValue(stops, percent);\n        css.filter += \" \" + prop + \"(\" + (value + unit) + \")\";\n      };\n    }\n\n    function cssPropFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(getCssValue(el, prop, ''));\n      }\n\n      stops = parseStops(stops);\n\n      return (css, percent) => {\n        css[prop] = getValue(stops, percent);\n      };\n    }\n\n    function strokeFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(0);\n      }\n\n      const unit = getUnit(stops);\n      const length = getMaxPathLength(el);\n      stops = parseStops(stops.reverse(), (stop) => {\n        stop = toFloat(stop);\n        return unit === '%' ? stop * length / 100 : stop;\n      });\n\n      if (!stops.some((_ref) => {let [value] = _ref;return value;})) {\n        return noop;\n      }\n\n      css(el, 'strokeDasharray', length);\n\n      return (css, percent) => {\n        css.strokeDashoffset = getValue(stops, percent);\n      };\n    }\n\n    function backgroundFn(prop, el, stops) {\n      if (stops.length === 1) {\n        stops.unshift(0);\n      }\n\n      prop = prop.substr(-1);\n      const attr = prop === 'y' ? 'height' : 'width';\n      stops = parseStops(stops, (stop) => toPx(stop, attr, el));\n\n      const bgPos = getCssValue(el, \"background-position-\" + prop, '');\n\n      return getCssValue(el, 'backgroundSize', '') === 'cover' ?\n      backgroundCoverFn(prop, el, stops, bgPos, attr) :\n      setBackgroundPosFn(prop, stops, bgPos);\n    }\n\n    function backgroundCoverFn(prop, el, stops, bgPos, attr) {\n      const dimImage = getBackgroundImageDimensions(el);\n\n      if (!dimImage.width) {\n        return noop;\n      }\n\n      const values = stops.map((_ref2) => {let [value] = _ref2;return value;});\n      const min = Math.min(...values);\n      const max = Math.max(...values);\n      const down = values.indexOf(min) < values.indexOf(max);\n\n      const diff = max - min;\n      let pos = (down ? -diff : 0) - (down ? min : max);\n\n      const dimEl = {\n        width: el.offsetWidth,\n        height: el.offsetHeight };\n\n\n      const baseDim = Dimensions.cover(dimImage, dimEl);\n      const span = baseDim[attr] - dimEl[attr];\n\n      if (span < diff) {\n        dimEl[attr] = baseDim[attr] + diff - span;\n      } else if (span > diff) {\n        const posPercentage = dimEl[attr] / toPx(bgPos, attr, el, true);\n\n        if (posPercentage) {\n          pos -= (span - diff) / posPercentage;\n        }\n      }\n\n      const dim = Dimensions.cover(dimImage, dimEl);\n\n      const fn = setBackgroundPosFn(prop, stops, pos + \"px\");\n      return (css, percent) => {\n        fn(css, percent);\n        css.backgroundSize = dim.width + \"px \" + dim.height + \"px\";\n        css.backgroundRepeat = 'no-repeat';\n      };\n    }\n\n    function setBackgroundPosFn(prop, stops, pos) {\n      return function (css, percent) {\n        css[\"background-position-\" + prop] = \"calc(\" + pos + \" + \" + getValue(stops, percent) + \"px)\";\n      };\n    }\n\n    const dimensions = {};\n    function getBackgroundImageDimensions(el) {\n      const src = css(el, 'backgroundImage').replace(/^none|url\\([\"']?(.+?)[\"']?\\)$/, '$1');\n\n      if (dimensions[src]) {\n        return dimensions[src];\n      }\n\n      const image = new Image();\n      if (src) {\n        image.src = src;\n\n        if (!image.naturalWidth) {\n          image.onload = () => {\n            dimensions[src] = toDimensions(image);\n            trigger(el, createEvent('load', false));\n          };\n          return toDimensions(image);\n        }\n      }\n\n      return dimensions[src] = toDimensions(image);\n    }\n\n    function toDimensions(image) {\n      return {\n        width: image.naturalWidth,\n        height: image.naturalHeight };\n\n    }\n\n    function parseStops(stops, fn) {if (fn === void 0) {fn = toFloat;}\n      const result = [];\n      const { length } = stops;\n      let nullIndex = 0;\n      for (let i = 0; i < length; i++) {\n        let [value, percent] = isString(stops[i]) ? stops[i].trim().split(' ') : [stops[i]];\n        value = fn(value);\n        percent = percent ? toFloat(percent) / 100 : null;\n\n        if (i === 0) {\n          if (percent === null) {\n            percent = 0;\n          } else if (percent) {\n            result.push([value, 0]);\n          }\n        } else if (i === length - 1) {\n          if (percent === null) {\n            percent = 1;\n          } else if (percent !== 1) {\n            result.push([value, percent]);\n            percent = 1;\n          }\n        }\n\n        result.push([value, percent]);\n\n        if (percent === null) {\n          nullIndex++;\n        } else if (nullIndex) {\n          const leftPercent = result[i - nullIndex - 1][1];\n          const p = (percent - leftPercent) / (nullIndex + 1);\n          for (let j = nullIndex; j > 0; j--) {\n            result[i - j][1] = leftPercent + p * (nullIndex - j + 1);\n          }\n\n          nullIndex = 0;\n        }\n      }\n\n      return result;\n    }\n\n    function getStop(stops, percent) {\n      const index = findIndex(stops.slice(1), (_ref3) => {let [, targetPercent] = _ref3;return percent <= targetPercent;}) + 1;\n      return [\n      stops[index - 1][0],\n      stops[index][0],\n      (percent - stops[index - 1][1]) / (stops[index][1] - stops[index - 1][1])];\n\n    }\n\n    function getValue(stops, percent) {\n      const [start, end, p] = getStop(stops, percent);\n      return isNumber(start) ? start + Math.abs(start - end) * p * (start < end ? 1 : -1) : +end;\n    }\n\n    const unitRe = /^-?\\d+(\\S*)/;\n    function getUnit(stops, defaultUnit) {\n      for (const stop of stops) {\n        const match = stop.match == null ? void 0 : stop.match(unitRe);\n        if (match) {\n          return match[1];\n        }\n      }\n      return defaultUnit;\n    }\n\n    function getCssValue(el, prop, value) {\n      const prev = el.style[prop];\n      const val = css(css(el, prop, value), prop);\n      el.style[prop] = prev;\n      return val;\n    }\n\n    function fillObject(keys, value) {\n      return keys.reduce((data, prop) => {\n        data[prop] = value;\n        return data;\n      }, {});\n    }\n\n    var parallax = {\n      mixins: [Parallax, Resize, Scroll],\n\n      props: {\n        target: String,\n        viewport: Number, // Deprecated\n        easing: Number,\n        start: String,\n        end: String },\n\n\n      data: {\n        target: false,\n        viewport: 1,\n        easing: 1,\n        start: 0,\n        end: 0 },\n\n\n      computed: {\n        target(_ref, $el) {let { target } = _ref;\n          return getOffsetElement(target && query(target, $el) || $el);\n        },\n\n        start(_ref2) {let { start } = _ref2;\n          return toPx(start, 'height', this.target, true);\n        },\n\n        end(_ref3) {let { end, viewport } = _ref3;\n          return toPx(\n          end || (viewport = (1 - viewport) * 100) && viewport + \"vh+\" + viewport + \"%\",\n          'height',\n          this.target,\n          true);\n\n        } },\n\n\n      update: {\n        read(_ref4, types) {let { percent } = _ref4;\n          if (!types.has('scroll')) {\n            percent = false;\n          }\n\n          if (!this.matchMedia) {\n            return;\n          }\n\n          const prev = percent;\n          percent = ease(scrolledOver(this.target, this.start, this.end), this.easing);\n\n          return {\n            percent,\n            style: prev === percent ? false : this.getCss(percent) };\n\n        },\n\n        write(_ref5) {let { style } = _ref5;\n          if (!this.matchMedia) {\n            this.reset();\n            return;\n          }\n\n          style && css(this.$el, style);\n        },\n\n        events: ['scroll', 'resize'] } };\n\n\n\n    function ease(percent, easing) {\n      return easing >= 0 ? Math.pow(percent, easing + 1) : 1 - Math.pow(1 - percent, -easing + 1);\n    }\n\n    // SVG elements do not inherit from HTMLElement\n    function getOffsetElement(el) {\n      return el ? 'offsetTop' in el ? el : getOffsetElement(parent(el)) : document.documentElement;\n    }\n\n    var SliderReactive = {\n      update: {\n        write() {\n          if (this.stack.length || this.dragging) {\n            return;\n          }\n\n          const index = this.getValidIndex(this.index);\n\n          if (!~this.prevIndex || this.index !== index) {\n            this.show(index);\n          }\n        },\n\n        events: ['resize'] } };\n\n    var SliderPreload = {\n      mixins: [Lazyload],\n\n      connected() {\n        this.lazyload(this.slides, this.getAdjacentSlides);\n      } };\n\n    function Transitioner (prev, next, dir, _ref) {let { center, easing, list } = _ref;\n      const deferred = new Deferred();\n\n      const from = prev ?\n      getLeft(prev, list, center) :\n      getLeft(next, list, center) + dimensions$1(next).width * dir;\n      const to = next ?\n      getLeft(next, list, center) :\n      from + dimensions$1(prev).width * dir * (isRtl ? -1 : 1);\n\n      return {\n        dir,\n\n        show(duration, percent, linear) {if (percent === void 0) {percent = 0;}\n          const timing = linear ? 'linear' : easing;\n          duration -= Math.round(duration * clamp(percent, -1, 1));\n\n          this.translate(percent);\n\n          percent = prev ? percent : clamp(percent, 0, 1);\n          triggerUpdate(this.getItemIn(), 'itemin', { percent, duration, timing, dir });\n          prev &&\n          triggerUpdate(this.getItemIn(true), 'itemout', {\n            percent: 1 - percent,\n            duration,\n            timing,\n            dir });\n\n\n          Transition.start(\n          list,\n          { transform: translate(-to * (isRtl ? -1 : 1), 'px') },\n          duration,\n          timing).\n          then(deferred.resolve, noop);\n\n          return deferred.promise;\n        },\n\n        cancel() {\n          Transition.cancel(list);\n        },\n\n        reset() {\n          css(list, 'transform', '');\n        },\n\n        forward(duration, percent) {if (percent === void 0) {percent = this.percent();}\n          Transition.cancel(list);\n          return this.show(duration, percent, true);\n        },\n\n        translate(percent) {\n          const distance = this.getDistance() * dir * (isRtl ? -1 : 1);\n\n          css(\n          list,\n          'transform',\n          translate(\n          clamp(\n          -to + (distance - distance * percent),\n          -getWidth(list),\n          dimensions$1(list).width) * (\n          isRtl ? -1 : 1),\n          'px'));\n\n\n\n          const actives = this.getActives();\n          const itemIn = this.getItemIn();\n          const itemOut = this.getItemIn(true);\n\n          percent = prev ? clamp(percent, -1, 1) : 0;\n\n          for (const slide of children(list)) {\n            const isActive = includes(actives, slide);\n            const isIn = slide === itemIn;\n            const isOut = slide === itemOut;\n            const translateIn =\n            isIn ||\n            !isOut && (\n            isActive ||\n            dir * (isRtl ? -1 : 1) === -1 ^\n            getElLeft(slide, list) > getElLeft(prev || next));\n\n            triggerUpdate(slide, \"itemtranslate\" + (translateIn ? 'in' : 'out'), {\n              dir,\n              percent: isOut ? 1 - percent : isIn ? percent : isActive ? 1 : 0 });\n\n          }\n        },\n\n        percent() {\n          return Math.abs(\n          (css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));\n\n        },\n\n        getDistance() {\n          return Math.abs(to - from);\n        },\n\n        getItemIn(out) {if (out === void 0) {out = false;}\n          let actives = this.getActives();\n          let nextActives = inView(list, getLeft(next || prev, list, center));\n\n          if (out) {\n            const temp = actives;\n            actives = nextActives;\n            nextActives = temp;\n          }\n\n          return nextActives[findIndex(nextActives, (el) => !includes(actives, el))];\n        },\n\n        getActives() {\n          return inView(list, getLeft(prev || next, list, center));\n        } };\n\n    }\n\n    function getLeft(el, list, center) {\n      const left = getElLeft(el, list);\n\n      return center ? left - centerEl(el, list) : Math.min(left, getMax(list));\n    }\n\n    function getMax(list) {\n      return Math.max(0, getWidth(list) - dimensions$1(list).width);\n    }\n\n    function getWidth(list) {\n      return children(list).reduce((right, el) => dimensions$1(el).width + right, 0);\n    }\n\n    function centerEl(el, list) {\n      return dimensions$1(list).width / 2 - dimensions$1(el).width / 2;\n    }\n\n    function getElLeft(el, list) {\n      return (\n        el &&\n        (position(el).left + (isRtl ? dimensions$1(el).width - dimensions$1(list).width : 0)) * (\n        isRtl ? -1 : 1) ||\n        0);\n\n    }\n\n    function inView(list, listLeft) {\n      listLeft -= 1;\n      const listWidth = dimensions$1(list).width;\n      const listRight = listLeft + listWidth + 2;\n\n      return children(list).filter((slide) => {\n        const slideLeft = getElLeft(slide, list);\n        const slideRight = slideLeft + Math.min(dimensions$1(slide).width, listWidth);\n\n        return slideLeft >= listLeft && slideRight <= listRight;\n      });\n    }\n\n    function triggerUpdate(el, type, data) {\n      trigger(el, createEvent(type, false, false, data));\n    }\n\n    var slider = {\n      mixins: [Class, Slider, SliderReactive, SliderPreload],\n\n      props: {\n        center: Boolean,\n        sets: Boolean },\n\n\n      data: {\n        center: false,\n        sets: false,\n        attrItem: 'uk-slider-item',\n        selList: '.uk-slider-items',\n        selNav: '.uk-slider-nav',\n        clsContainer: 'uk-slider-container',\n        Transitioner },\n\n\n      computed: {\n        avgWidth() {\n          return getWidth(this.list) / this.length;\n        },\n\n        finite(_ref) {let { finite } = _ref;\n          return (\n            finite ||\n            Math.ceil(getWidth(this.list)) <\n            Math.trunc(dimensions$1(this.list).width + getMaxElWidth(this.list) + this.center));\n\n        },\n\n        maxIndex() {\n          if (!this.finite || this.center && !this.sets) {\n            return this.length - 1;\n          }\n\n          if (this.center) {\n            return last(this.sets);\n          }\n\n          let lft = 0;\n          const max = getMax(this.list);\n          const index = findIndex(this.slides, (el) => {\n            if (lft >= max) {\n              return true;\n            }\n\n            lft += dimensions$1(el).width;\n          });\n\n          return ~index ? index : this.length - 1;\n        },\n\n        sets(_ref2) {let { sets: enabled } = _ref2;\n          if (!enabled) {\n            return;\n          }\n\n          let left = 0;\n          const sets = [];\n          const width = dimensions$1(this.list).width;\n          for (let i = 0; i < this.slides.length; i++) {\n            const slideWidth = dimensions$1(this.slides[i]).width;\n\n            if (left + slideWidth > width) {\n              left = 0;\n            }\n\n            if (this.center) {\n              if (\n              left < width / 2 &&\n              left + slideWidth + dimensions$1(this.slides[+i + 1]).width / 2 > width / 2)\n              {\n                sets.push(+i);\n                left = width / 2 - slideWidth / 2;\n              }\n            } else if (left === 0) {\n              sets.push(Math.min(+i, this.maxIndex));\n            }\n\n            left += slideWidth;\n          }\n\n          if (sets.length) {\n            return sets;\n          }\n        },\n\n        transitionOptions() {\n          return {\n            center: this.center,\n            list: this.list };\n\n        } },\n\n\n      connected() {\n        toggleClass(this.$el, this.clsContainer, !$(\".\" + this.clsContainer, this.$el));\n      },\n\n      update: {\n        write() {\n          for (const el of this.navItems) {\n            const index = toNumber(data(el, this.attrItem));\n            if (index !== false) {\n              el.hidden =\n              !this.maxIndex ||\n              index > this.maxIndex ||\n              this.sets && !includes(this.sets, index);\n            }\n          }\n\n          if (this.length && !this.dragging && !this.stack.length) {\n            this.reorder();\n            this._translate(1);\n          }\n\n          this.updateActiveClasses();\n        },\n\n        events: ['resize'] },\n\n\n      events: {\n        beforeitemshow(e) {\n          if (\n          !this.dragging &&\n          this.sets &&\n          this.stack.length < 2 &&\n          !includes(this.sets, this.index))\n          {\n            this.index = this.getValidIndex();\n          }\n\n          const diff = Math.abs(\n          this.index -\n          this.prevIndex + (\n          this.dir > 0 && this.index < this.prevIndex ||\n          this.dir < 0 && this.index > this.prevIndex ?\n          (this.maxIndex + 1) * this.dir :\n          0));\n\n\n          if (!this.dragging && diff > 1) {\n            for (let i = 0; i < diff; i++) {\n              this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');\n            }\n\n            e.preventDefault();\n            return;\n          }\n\n          const index =\n          this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex;\n          this.duration =\n          speedUp(this.avgWidth / this.velocity) * (\n          dimensions$1(this.slides[index]).width / this.avgWidth);\n\n          this.reorder();\n        },\n\n        itemshow() {\n          if (~this.prevIndex) {\n            addClass(this._getTransitioner().getItemIn(), this.clsActive);\n          }\n        },\n\n        itemshown() {\n          this.updateActiveClasses();\n        } },\n\n\n      methods: {\n        reorder() {\n          if (this.finite) {\n            css(this.slides, 'order', '');\n            return;\n          }\n\n          const index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;\n\n          this.slides.forEach((slide, i) =>\n          css(\n          slide,\n          'order',\n          this.dir > 0 && i < index ? 1 : this.dir < 0 && i >= this.index ? -1 : ''));\n\n\n\n          if (!this.center) {\n            return;\n          }\n\n          const next = this.slides[index];\n          let width = dimensions$1(this.list).width / 2 - dimensions$1(next).width / 2;\n          let j = 0;\n\n          while (width > 0) {\n            const slideIndex = this.getIndex(--j + index, index);\n            const slide = this.slides[slideIndex];\n\n            css(slide, 'order', slideIndex > index ? -2 : -1);\n            width -= dimensions$1(slide).width;\n          }\n        },\n\n        updateActiveClasses() {\n          const actives = this._getTransitioner(this.index).getActives();\n          const activeClasses = [\n          this.clsActive,\n          (!this.sets || includes(this.sets, toFloat(this.index))) && this.clsActivated ||\n          ''];\n\n          for (const slide of this.slides) {\n            toggleClass(slide, activeClasses, includes(actives, slide));\n          }\n        },\n\n        getValidIndex(index, prevIndex) {if (index === void 0) {index = this.index;}if (prevIndex === void 0) {prevIndex = this.prevIndex;}\n          index = this.getIndex(index, prevIndex);\n\n          if (!this.sets) {\n            return index;\n          }\n\n          let prev;\n\n          do {\n            if (includes(this.sets, index)) {\n              return index;\n            }\n\n            prev = index;\n            index = this.getIndex(index + this.dir, prevIndex);\n          } while (index !== prev);\n\n          return index;\n        },\n\n        getAdjacentSlides() {\n          const { width } = dimensions$1(this.list);\n          const left = -width;\n          const right = width * 2;\n          const slideWidth = dimensions$1(this.slides[this.index]).width;\n          const slideLeft = this.center ? width / 2 - slideWidth / 2 : 0;\n          const slides = new Set();\n          for (const i of [-1, 1]) {\n            let currentLeft = slideLeft + (i > 0 ? slideWidth : 0);\n            let j = 0;\n            do {\n              const slide = this.slides[this.getIndex(this.index + i + j++ * i)];\n              currentLeft += dimensions$1(slide).width * i;\n              slides.add(slide);\n            } while (this.slides.length > j && currentLeft > left && currentLeft < right);\n          }\n          return Array.from(slides);\n        } } };\n\n\n\n    function getMaxElWidth(list) {\n      return Math.max(0, ...children(list).map((el) => dimensions$1(el).width));\n    }\n\n    var sliderParallax = {\n      mixins: [Parallax],\n\n      data: {\n        selItem: '!li' },\n\n\n      beforeConnect() {\n        this.item = query(this.selItem, this.$el);\n      },\n\n      disconnected() {\n        this.item = null;\n      },\n\n      events: [\n      {\n        name: 'itemin itemout',\n\n        self: true,\n\n        el() {\n          return this.item;\n        },\n\n        handler(_ref) {let { type, detail: { percent, duration, timing, dir } } = _ref;\n          fastdom.read(() => {\n            const propsFrom = this.getCss(getCurrentPercent(type, dir, percent));\n            const propsTo = this.getCss(isIn(type) ? 0.5 : dir > 0 ? 1 : 0);\n            fastdom.write(() => {\n              css(this.$el, propsFrom);\n              Transition.start(this.$el, propsTo, duration, timing).catch(noop);\n            });\n          });\n        } },\n\n\n      {\n        name: 'transitioncanceled transitionend',\n\n        self: true,\n\n        el() {\n          return this.item;\n        },\n\n        handler() {\n          Transition.cancel(this.$el);\n        } },\n\n\n      {\n        name: 'itemtranslatein itemtranslateout',\n\n        self: true,\n\n        el() {\n          return this.item;\n        },\n\n        handler(_ref2) {let { type, detail: { percent, dir } } = _ref2;\n          fastdom.read(() => {\n            const props = this.getCss(getCurrentPercent(type, dir, percent));\n            fastdom.write(() => css(this.$el, props));\n          });\n        } }] };\n\n\n\n\n    function isIn(type) {\n      return endsWith(type, 'in');\n    }\n\n    function getCurrentPercent(type, dir, percent) {\n      percent /= 2;\n\n      return isIn(type) ^ dir < 0 ? percent : 1 - percent;\n    }\n\n    var Animations = {\n      ...Animations$2,\n      fade: {\n        show() {\n          return [{ opacity: 0, zIndex: 0 }, { zIndex: -1 }];\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [{ opacity: 1 - percent, zIndex: 0 }, { zIndex: -1 }];\n        } },\n\n\n      scale: {\n        show() {\n          return [{ opacity: 0, transform: scale3d(1 + 0.5), zIndex: 0 }, { zIndex: -1 }];\n        },\n\n        percent(current) {\n          return 1 - css(current, 'opacity');\n        },\n\n        translate(percent) {\n          return [\n          { opacity: 1 - percent, transform: scale3d(1 + 0.5 * percent), zIndex: 0 },\n          { zIndex: -1 }];\n\n        } },\n\n\n      pull: {\n        show(dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(30), zIndex: -1 },\n          { transform: translate(), zIndex: 0 }] :\n\n          [\n          { transform: translate(-100), zIndex: 0 },\n          { transform: translate(), zIndex: -1 }];\n\n        },\n\n        percent(current, next, dir) {\n          return dir < 0 ? 1 - translated(next) : translated(current);\n        },\n\n        translate(percent, dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(30 * percent), zIndex: -1 },\n          { transform: translate(-100 * (1 - percent)), zIndex: 0 }] :\n\n          [\n          { transform: translate(-percent * 100), zIndex: 0 },\n          { transform: translate(30 * (1 - percent)), zIndex: -1 }];\n\n        } },\n\n\n      push: {\n        show(dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(100), zIndex: 0 },\n          { transform: translate(), zIndex: -1 }] :\n\n          [\n          { transform: translate(-30), zIndex: -1 },\n          { transform: translate(), zIndex: 0 }];\n\n        },\n\n        percent(current, next, dir) {\n          return dir > 0 ? 1 - translated(next) : translated(current);\n        },\n\n        translate(percent, dir) {\n          return dir < 0 ?\n          [\n          { transform: translate(percent * 100), zIndex: 0 },\n          { transform: translate(-30 * (1 - percent)), zIndex: -1 }] :\n\n          [\n          { transform: translate(-30 * percent), zIndex: -1 },\n          { transform: translate(100 * (1 - percent)), zIndex: 0 }];\n\n        } } };\n\n    var slideshow = {\n      mixins: [Class, Slideshow, SliderReactive, SliderPreload],\n\n      props: {\n        ratio: String,\n        minHeight: Number,\n        maxHeight: Number },\n\n\n      data: {\n        ratio: '16:9',\n        minHeight: false,\n        maxHeight: false,\n        selList: '.uk-slideshow-items',\n        attrItem: 'uk-slideshow-item',\n        selNav: '.uk-slideshow-nav',\n        Animations },\n\n\n      update: {\n        read() {\n          if (!this.list) {\n            return false;\n          }\n\n          let [width, height] = this.ratio.split(':').map(Number);\n\n          height = height * this.list.offsetWidth / width || 0;\n\n          if (this.minHeight) {\n            height = Math.max(this.minHeight, height);\n          }\n\n          if (this.maxHeight) {\n            height = Math.min(this.maxHeight, height);\n          }\n\n          return { height: height - boxModelAdjust(this.list, 'height', 'content-box') };\n        },\n\n        write(_ref) {let { height } = _ref;\n          height > 0 && css(this.list, 'minHeight', height);\n        },\n\n        events: ['resize'] },\n\n\n      methods: {\n        getAdjacentSlides() {\n          return [1, -1].map((i) => this.slides[this.getIndex(this.index + i)]);\n        } } };\n\n    var sortable = {\n      mixins: [Class, Animate],\n\n      props: {\n        group: String,\n        threshold: Number,\n        clsItem: String,\n        clsPlaceholder: String,\n        clsDrag: String,\n        clsDragState: String,\n        clsBase: String,\n        clsNoDrag: String,\n        clsEmpty: String,\n        clsCustom: String,\n        handle: String },\n\n\n      data: {\n        group: false,\n        threshold: 5,\n        clsItem: 'uk-sortable-item',\n        clsPlaceholder: 'uk-sortable-placeholder',\n        clsDrag: 'uk-sortable-drag',\n        clsDragState: 'uk-drag',\n        clsBase: 'uk-sortable',\n        clsNoDrag: 'uk-sortable-nodrag',\n        clsEmpty: 'uk-sortable-empty',\n        clsCustom: '',\n        handle: false,\n        pos: {} },\n\n\n      created() {\n        for (const key of ['init', 'start', 'move', 'end']) {\n          const fn = this[key];\n          this[key] = (e) => {\n            assign(this.pos, getEventPos(e));\n            fn(e);\n          };\n        }\n      },\n\n      events: {\n        name: pointerDown,\n        passive: false,\n        handler: 'init' },\n\n\n      computed: {\n        target() {\n          return (this.$el.tBodies || [this.$el])[0];\n        },\n\n        items() {\n          return children(this.target);\n        },\n\n        isEmpty: {\n          get() {\n            return isEmpty(this.items);\n          },\n\n          watch(empty) {\n            toggleClass(this.target, this.clsEmpty, empty);\n          },\n\n          immediate: true },\n\n\n        handles: {\n          get(_ref, el) {let { handle } = _ref;\n            return handle ? $$(handle, el) : this.items;\n          },\n\n          watch(handles, prev) {\n            css(prev, { touchAction: '', userSelect: '' });\n            css(handles, { touchAction: hasTouch ? 'none' : '', userSelect: 'none' }); // touchAction set to 'none' causes a performance drop in Chrome 80\n          },\n\n          immediate: true } },\n\n\n\n      update: {\n        write(data) {\n          if (!this.drag || !parent(this.placeholder)) {\n            return;\n          }\n\n          const {\n            pos: { x, y },\n            origin: { offsetTop, offsetLeft },\n            placeholder } =\n          this;\n\n          css(this.drag, {\n            top: y - offsetTop,\n            left: x - offsetLeft });\n\n\n          const sortable = this.getSortable(document.elementFromPoint(x, y));\n\n          if (!sortable) {\n            return;\n          }\n\n          const { items } = sortable;\n\n          if (items.some(Transition.inProgress)) {\n            return;\n          }\n\n          const target = findTarget(items, { x, y });\n\n          if (items.length && (!target || target === placeholder)) {\n            return;\n          }\n\n          const previous = this.getSortable(placeholder);\n          const insertTarget = findInsertTarget(\n          sortable.target,\n          target,\n          placeholder,\n          x,\n          y,\n          sortable === previous && data.moved !== target);\n\n\n          if (insertTarget === false) {\n            return;\n          }\n\n          if (insertTarget && placeholder === insertTarget) {\n            return;\n          }\n\n          if (sortable !== previous) {\n            previous.remove(placeholder);\n            data.moved = target;\n          } else {\n            delete data.moved;\n          }\n\n          sortable.insert(placeholder, insertTarget);\n\n          this.touched.add(sortable);\n        },\n\n        events: ['move'] },\n\n\n      methods: {\n        init(e) {\n          const { target, button, defaultPrevented } = e;\n          const [placeholder] = this.items.filter((el) => within(target, el));\n\n          if (\n          !placeholder ||\n          defaultPrevented ||\n          button > 0 ||\n          isInput(target) ||\n          within(target, \".\" + this.clsNoDrag) ||\n          this.handle && !within(target, this.handle))\n          {\n            return;\n          }\n\n          e.preventDefault();\n\n          this.touched = new Set([this]);\n          this.placeholder = placeholder;\n          this.origin = { target, index: index(placeholder), ...this.pos };\n\n          on(document, pointerMove, this.move);\n          on(document, pointerUp, this.end);\n\n          if (!this.threshold) {\n            this.start(e);\n          }\n        },\n\n        start(e) {\n          this.drag = appendDrag(this.$container, this.placeholder);\n          const { left, top } = this.placeholder.getBoundingClientRect();\n          assign(this.origin, { offsetLeft: this.pos.x - left, offsetTop: this.pos.y - top });\n\n          addClass(this.drag, this.clsDrag, this.clsCustom);\n          addClass(this.placeholder, this.clsPlaceholder);\n          addClass(this.items, this.clsItem);\n          addClass(document.documentElement, this.clsDragState);\n\n          trigger(this.$el, 'start', [this, this.placeholder]);\n\n          trackScroll(this.pos);\n\n          this.move(e);\n        },\n\n        move(e) {\n          if (this.drag) {\n            this.$emit('move');\n          } else if (\n          Math.abs(this.pos.x - this.origin.x) > this.threshold ||\n          Math.abs(this.pos.y - this.origin.y) > this.threshold)\n          {\n            this.start(e);\n          }\n        },\n\n        end() {\n          off(document, pointerMove, this.move);\n          off(document, pointerUp, this.end);\n\n          if (!this.drag) {\n            return;\n          }\n\n          untrackScroll();\n\n          const sortable = this.getSortable(this.placeholder);\n\n          if (this === sortable) {\n            if (this.origin.index !== index(this.placeholder)) {\n              trigger(this.$el, 'moved', [this, this.placeholder]);\n            }\n          } else {\n            trigger(sortable.$el, 'added', [sortable, this.placeholder]);\n            trigger(this.$el, 'removed', [this, this.placeholder]);\n          }\n\n          trigger(this.$el, 'stop', [this, this.placeholder]);\n\n          remove$1(this.drag);\n          this.drag = null;\n\n          for (const { clsPlaceholder, clsItem } of this.touched) {\n            for (const sortable of this.touched) {\n              removeClass(sortable.items, clsPlaceholder, clsItem);\n            }\n          }\n          this.touched = null;\n          removeClass(document.documentElement, this.clsDragState);\n        },\n\n        insert(element, target) {\n          addClass(this.items, this.clsItem);\n\n          const insert = () => target ? before(target, element) : append(this.target, element);\n\n          this.animate(insert);\n        },\n\n        remove(element) {\n          if (!within(element, this.target)) {\n            return;\n          }\n\n          this.animate(() => remove$1(element));\n        },\n\n        getSortable(element) {\n          do {\n            const sortable = this.$getComponent(element, 'sortable');\n\n            if (\n            sortable && (\n            sortable === this || this.group !== false && sortable.group === this.group))\n            {\n              return sortable;\n            }\n          } while (element = parent(element));\n        } } };\n\n\n\n    let trackTimer;\n    function trackScroll(pos) {\n      let last = Date.now();\n      trackTimer = setInterval(() => {\n        let { x, y } = pos;\n        y += scrollTop(window);\n\n        const dist = (Date.now() - last) * 0.3;\n        last = Date.now();\n\n        scrollParents(document.elementFromPoint(x, pos.y), /auto|scroll/).\n        reverse().\n        some((scrollEl) => {\n          let { scrollTop: scroll, scrollHeight } = scrollEl;\n\n          const { top, bottom, height } = offsetViewport(scrollEl);\n\n          if (top < y && top + 35 > y) {\n            scroll -= dist;\n          } else if (bottom > y && bottom - 35 < y) {\n            scroll += dist;\n          } else {\n            return;\n          }\n\n          if (scroll > 0 && scroll < scrollHeight - height) {\n            scrollTop(scrollEl, scroll);\n            return true;\n          }\n        });\n      }, 15);\n    }\n\n    function untrackScroll() {\n      clearInterval(trackTimer);\n    }\n\n    function appendDrag(container, element) {\n      const clone = append(\n      container,\n      element.outerHTML.replace(/(^<)(?:li|tr)|(?:li|tr)(\\/>$)/g, '$1div$2'));\n\n\n      css(clone, 'margin', '0', 'important');\n      css(clone, {\n        boxSizing: 'border-box',\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        padding: css(element, 'padding') });\n\n\n      height(clone.firstElementChild, height(element.firstElementChild));\n\n      return clone;\n    }\n\n    function findTarget(items, point) {\n      return items[findIndex(items, (item) => pointInRect(point, item.getBoundingClientRect()))];\n    }\n\n    function findInsertTarget(list, target, placeholder, x, y, sameList) {\n      if (!children(list).length) {\n        return;\n      }\n\n      const rect = target.getBoundingClientRect();\n      if (!sameList) {\n        if (!isHorizontal(list, placeholder)) {\n          return y < rect.top + rect.height / 2 ? target : target.nextElementSibling;\n        }\n\n        return target;\n      }\n\n      const placeholderRect = placeholder.getBoundingClientRect();\n      const sameRow = linesIntersect(\n      [rect.top, rect.bottom],\n      [placeholderRect.top, placeholderRect.bottom]);\n\n\n      const pointerPos = sameRow ? x : y;\n      const lengthProp = sameRow ? 'width' : 'height';\n      const startProp = sameRow ? 'left' : 'top';\n      const endProp = sameRow ? 'right' : 'bottom';\n\n      const diff =\n      placeholderRect[lengthProp] < rect[lengthProp] ?\n      rect[lengthProp] - placeholderRect[lengthProp] :\n      0;\n\n      if (placeholderRect[startProp] < rect[startProp]) {\n        if (diff && pointerPos < rect[startProp] + diff) {\n          return false;\n        }\n\n        return target.nextElementSibling;\n      }\n\n      if (diff && pointerPos > rect[endProp] - diff) {\n        return false;\n      }\n\n      return target;\n    }\n\n    function isHorizontal(list, placeholder) {\n      const single = children(list).length === 1;\n\n      if (single) {\n        append(list, placeholder);\n      }\n\n      const items = children(list);\n      const isHorizontal = items.some((el, i) => {\n        const rectA = el.getBoundingClientRect();\n        return items.slice(i + 1).some((el) => {\n          const rectB = el.getBoundingClientRect();\n          return !linesIntersect([rectA.left, rectA.right], [rectB.left, rectB.right]);\n        });\n      });\n\n      if (single) {\n        remove$1(placeholder);\n      }\n\n      return isHorizontal;\n    }\n\n    function linesIntersect(lineA, lineB) {\n      return lineA[1] > lineB[0] && lineB[1] > lineA[0];\n    }\n\n    var tooltip = {\n      mixins: [Container, Togglable, Position],\n\n      args: 'title',\n\n      props: {\n        delay: Number,\n        title: String },\n\n\n      data: {\n        pos: 'top',\n        title: '',\n        delay: 0,\n        animation: ['uk-animation-scale-up'],\n        duration: 100,\n        cls: 'uk-active' },\n\n\n      beforeConnect() {\n        this._hasTitle = hasAttr(this.$el, 'title');\n        attr(this.$el, 'title', '');\n        this.updateAria(false);\n        makeFocusable(this.$el);\n      },\n\n      disconnected() {\n        this.hide();\n        attr(this.$el, 'title', this._hasTitle ? this.title : null);\n      },\n\n      methods: {\n        show() {\n          if (this.isToggled(this.tooltip || null) || !this.title) {\n            return;\n          }\n\n          this._unbind = once(\n          document, \"show keydown \" +\n          pointerDown,\n          this.hide,\n          false,\n          (e) =>\n          e.type === pointerDown && !within(e.target, this.$el) ||\n          e.type === 'keydown' && e.keyCode === 27 ||\n          e.type === 'show' && e.detail[0] !== this && e.detail[0].$name === this.$name);\n\n\n          clearTimeout(this.showTimer);\n          this.showTimer = setTimeout(this._show, this.delay);\n        },\n\n        async hide() {\n          if (matches(this.$el, 'input:focus')) {\n            return;\n          }\n\n          clearTimeout(this.showTimer);\n\n          if (!this.isToggled(this.tooltip || null)) {\n            return;\n          }\n\n          await this.toggleElement(this.tooltip, false, false);\n          remove$1(this.tooltip);\n          this.tooltip = null;\n          this._unbind();\n        },\n\n        _show() {\n          this.tooltip = append(\n          this.container, \"<div class=\\\"uk-\" +\n          this.$options.name + \"\\\"> <div class=\\\"uk-\" +\n          this.$options.name + \"-inner\\\">\" + this.title + \"</div> </div>\");\n\n\n\n          on(this.tooltip, 'toggled', (e, toggled) => {\n            this.updateAria(toggled);\n\n            if (!toggled) {\n              return;\n            }\n\n            this.positionAt(this.tooltip, this.$el);\n\n            const [dir, align] = getAlignment(this.tooltip, this.$el, this.pos);\n\n            this.origin =\n            this.axis === 'y' ?\n            flipPosition(dir) + \"-\" + align :\n            align + \"-\" + flipPosition(dir);\n          });\n\n          this.toggleElement(this.tooltip, true);\n        },\n\n        updateAria(toggled) {\n          attr(this.$el, 'aria-expanded', toggled);\n        } },\n\n\n      events: {\n        focus: 'show',\n        blur: 'hide',\n\n        [pointerEnter + \" \" + pointerLeave](e) {\n          if (!isTouch(e)) {\n            this[e.type === pointerEnter ? 'show' : 'hide']();\n          }\n        },\n\n        // Clicking a button does not give it focus on all browsers and platforms\n        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus\n        [pointerDown](e) {\n          if (isTouch(e)) {\n            this.show();\n          }\n        } } };\n\n\n\n    function makeFocusable(el) {\n      if (!isFocusable(el)) {\n        attr(el, 'tabindex', '0');\n      }\n    }\n\n    function getAlignment(el, target, _ref) {let [dir, align] = _ref;\n      const elOffset = offset(el);\n      const targetOffset = offset(target);\n      const properties = [\n      ['left', 'right'],\n      ['top', 'bottom']];\n\n\n      for (const props of properties) {\n        if (elOffset[props[0]] >= targetOffset[props[1]]) {\n          dir = props[1];\n          break;\n        }\n        if (elOffset[props[1]] <= targetOffset[props[0]]) {\n          dir = props[0];\n          break;\n        }\n      }\n\n      const props = includes(properties[0], dir) ? properties[1] : properties[0];\n      if (elOffset[props[0]] === targetOffset[props[0]]) {\n        align = props[0];\n      } else if (elOffset[props[1]] === targetOffset[props[1]]) {\n        align = props[1];\n      } else {\n        align = 'center';\n      }\n\n      return [dir, align];\n    }\n\n    var upload = {\n      props: {\n        allow: String,\n        clsDragover: String,\n        concurrent: Number,\n        maxSize: Number,\n        method: String,\n        mime: String,\n        msgInvalidMime: String,\n        msgInvalidName: String,\n        msgInvalidSize: String,\n        multiple: Boolean,\n        name: String,\n        params: Object,\n        type: String,\n        url: String },\n\n\n      data: {\n        allow: false,\n        clsDragover: 'uk-dragover',\n        concurrent: 1,\n        maxSize: 0,\n        method: 'POST',\n        mime: false,\n        msgInvalidMime: 'Invalid File Type: %s',\n        msgInvalidName: 'Invalid File Name: %s',\n        msgInvalidSize: 'Invalid File Size: %s Kilobytes Max',\n        multiple: false,\n        name: 'files[]',\n        params: {},\n        type: '',\n        url: '',\n        abort: noop,\n        beforeAll: noop,\n        beforeSend: noop,\n        complete: noop,\n        completeAll: noop,\n        error: noop,\n        fail: noop,\n        load: noop,\n        loadEnd: noop,\n        loadStart: noop,\n        progress: noop },\n\n\n      events: {\n        change(e) {\n          if (!matches(e.target, 'input[type=\"file\"]')) {\n            return;\n          }\n\n          e.preventDefault();\n\n          if (e.target.files) {\n            this.upload(e.target.files);\n          }\n\n          e.target.value = '';\n        },\n\n        drop(e) {\n          stop(e);\n\n          const transfer = e.dataTransfer;\n\n          if (!(transfer != null && transfer.files)) {\n            return;\n          }\n\n          removeClass(this.$el, this.clsDragover);\n\n          this.upload(transfer.files);\n        },\n\n        dragenter(e) {\n          stop(e);\n        },\n\n        dragover(e) {\n          stop(e);\n          addClass(this.$el, this.clsDragover);\n        },\n\n        dragleave(e) {\n          stop(e);\n          removeClass(this.$el, this.clsDragover);\n        } },\n\n\n      methods: {\n        async upload(files) {\n          files = toArray(files);\n\n          if (!files.length) {\n            return;\n          }\n\n          trigger(this.$el, 'upload', [files]);\n\n          for (const file of files) {\n            if (this.maxSize && this.maxSize * 1000 < file.size) {\n              this.fail(this.msgInvalidSize.replace('%s', this.maxSize));\n              return;\n            }\n\n            if (this.allow && !match(this.allow, file.name)) {\n              this.fail(this.msgInvalidName.replace('%s', this.allow));\n              return;\n            }\n\n            if (this.mime && !match(this.mime, file.type)) {\n              this.fail(this.msgInvalidMime.replace('%s', this.mime));\n              return;\n            }\n          }\n\n          if (!this.multiple) {\n            files = files.slice(0, 1);\n          }\n\n          this.beforeAll(this, files);\n\n          const chunks = chunk(files, this.concurrent);\n          const upload = async (files) => {\n            const data = new FormData();\n\n            files.forEach((file) => data.append(this.name, file));\n\n            for (const key in this.params) {\n              data.append(key, this.params[key]);\n            }\n\n            try {\n              const xhr = await ajax(this.url, {\n                data,\n                method: this.method,\n                responseType: this.type,\n                beforeSend: (env) => {\n                  const { xhr } = env;\n                  xhr.upload && on(xhr.upload, 'progress', this.progress);\n                  for (const type of ['loadStart', 'load', 'loadEnd', 'abort']) {\n                    on(xhr, type.toLowerCase(), this[type]);\n                  }\n\n                  return this.beforeSend(env);\n                } });\n\n\n              this.complete(xhr);\n\n              if (chunks.length) {\n                await upload(chunks.shift());\n              } else {\n                this.completeAll(xhr);\n              }\n            } catch (e) {\n              this.error(e);\n            }\n          };\n\n          await upload(chunks.shift());\n        } } };\n\n\n\n    function match(pattern, path) {\n      return path.match(\n      new RegExp(\"^\" +\n      pattern.\n      replace(/\\//g, '\\\\/').\n      replace(/\\*\\*/g, '(\\\\/[^\\\\/]+)*').\n      replace(/\\*/g, '[^\\\\/]+').\n      replace(/((?!\\\\))\\?/g, '$1.') + \"$\",\n      'i'));\n\n\n    }\n\n    function chunk(files, size) {\n      const chunks = [];\n      for (let i = 0; i < files.length; i += size) {\n        chunks.push(files.slice(i, i + size));\n      }\n      return chunks;\n    }\n\n    function stop(e) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    var components = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        Countdown: countdown,\n        Filter: filter,\n        Lightbox: lightbox,\n        LightboxPanel: LightboxPanel,\n        Notification: notification,\n        Parallax: parallax,\n        Slider: slider,\n        SliderParallax: sliderParallax,\n        Slideshow: slideshow,\n        SlideshowParallax: sliderParallax,\n        Sortable: sortable,\n        Tooltip: tooltip,\n        Upload: upload\n    });\n\n    each(components, (component, name) => UIkit.component(name, component));\n\n    return UIkit;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvZGlzdC9qcy91aWtpdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUNvRztBQUN4RyxDQUFDLHVCQUF1Qjs7QUFFeEIsWUFBWSwyQkFBMkI7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksU0FBUzs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNLG9CQUFvQixPQUFPLE1BQU0sb0JBQW9CLFFBQVE7QUFDaEcsdURB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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Q0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUwsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQzs7O0FBR2hDOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0RBQXNEOzs7QUFHdEQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0Es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QUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7OztBQUlYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7O0FBRzVCO0FBQ0E7QUFDQSw0Q0FBNEM7OztBQUc1QztBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVc7Ozs7QUFJWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDOztBQUVsRCxrQkFBa0Isc0JBQXNCOztBQUV4QztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7O0FBRzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCOzs7QUFHdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOzs7QUFHMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOzs7QUFHckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7O0FBR3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7O0FBR25COztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Vpa2l0L2Rpc3QvanMvdWlraXQuanM/MmY0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgVUlraXQgMy4xNC4xIHwgaHR0cHM6Ly93d3cuZ2V0dWlraXQuY29tIHwgKGMpIDIwMTQgLSAyMDIyIFlPT3RoZW1lIHwgTUlUIExpY2Vuc2UgKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCd1aWtpdCcsIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVUlraXQgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSwgdG9TdHJpbmcgfSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCBoeXBoZW5hdGVSZSA9IC9cXEIoW0EtWl0pL2c7XG5cbiAgICBjb25zdCBoeXBoZW5hdGUgPSBtZW1vaXplKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJlLCAnLSQxJykudG9Mb3dlckNhc2UoKSk7XG5cbiAgICBjb25zdCBjYW1lbGl6ZVJlID0gLy0oXFx3KS9nO1xuXG4gICAgY29uc3QgY2FtZWxpemUgPSBtZW1vaXplKChzdHIpID0+IHN0ci5yZXBsYWNlKGNhbWVsaXplUmUsIHRvVXBwZXIpKTtcblxuICAgIGNvbnN0IHVjZmlyc3QgPSBtZW1vaXplKChzdHIpID0+XG4gICAgc3RyLmxlbmd0aCA/IHRvVXBwZXIobnVsbCwgc3RyLmNoYXJBdCgwKSkgKyBzdHIuc2xpY2UoMSkgOiAnJyk7XG5cblxuICAgIGZ1bmN0aW9uIHRvVXBwZXIoXywgYykge1xuICAgICAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoKSB7XG4gICAgICByZXR1cm4gc3RyID09IG51bGwgPyB2b2lkIDAgOiBzdHIuc3RhcnRzV2l0aCA9PSBudWxsID8gdm9pZCAwIDogc3RyLnN0YXJ0c1dpdGgoc2VhcmNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCkge1xuICAgICAgcmV0dXJuIHN0ciA9PSBudWxsID8gdm9pZCAwIDogc3RyLmVuZHNXaXRoID09IG51bGwgPyB2b2lkIDAgOiBzdHIuZW5kc1dpdGgoc2VhcmNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhvYmosIHNlYXJjaCkge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqLmluY2x1ZGVzID09IG51bGwgPyB2b2lkIDAgOiBvYmouaW5jbHVkZXMoc2VhcmNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyB2b2lkIDAgOiBhcnJheS5maW5kSW5kZXggPT0gbnVsbCA/IHZvaWQgMCA6IGFycmF5LmZpbmRJbmRleChwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgaXNBcnJheSwgZnJvbTogdG9BcnJheSB9ID0gQXJyYXk7XG4gICAgY29uc3QgeyBhc3NpZ24gfSA9IE9iamVjdDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgb2JqID09PSBvYmoud2luZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnQob2JqKSB7XG4gICAgICByZXR1cm4gbm9kZVR5cGUob2JqKSA9PT0gOTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc05vZGUob2JqKSB7XG4gICAgICByZXR1cm4gbm9kZVR5cGUob2JqKSA+PSAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgICAgIHJldHVybiBub2RlVHlwZShvYmopID09PSAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vZGVUeXBlKG9iaikge1xuICAgICAgcmV0dXJuICFpc1dpbmRvdyhvYmopICYmIGlzT2JqZWN0KG9iaikgJiYgb2JqLm5vZGVUeXBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1lcmljKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNOYU4odmFsdWUgLSBwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICAgIHJldHVybiAhKGlzQXJyYXkob2JqKSA/IG9iai5sZW5ndGggOiBpc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggOiBmYWxzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQm9vbGVhbih2YWx1ZSkgP1xuICAgICAgdmFsdWUgOlxuICAgICAgdmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJzEnIHx8IHZhbHVlID09PSAnJyA/XG4gICAgICB0cnVlIDpcbiAgICAgIHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAnMCcgP1xuICAgICAgZmFsc2UgOlxuICAgICAgdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGNvbnN0IG51bWJlciA9IE51bWJlcih2YWx1ZSk7XG4gICAgICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhbHNlIDogbnVtYmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm9kZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KVswXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vZGVzKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ICYmIChpc05vZGUoZWxlbWVudCkgPyBbZWxlbWVudF0gOiBBcnJheS5mcm9tKGVsZW1lbnQpLmZpbHRlcihpc05vZGUpKSB8fCBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b1dpbmRvdyhlbGVtZW50KSB7dmFyIF9lbGVtZW50O1xuICAgICAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBpc0RvY3VtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IChfZWxlbWVudCA9IGVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudC5vd25lckRvY3VtZW50O1xuXG4gICAgICByZXR1cm4gKGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2YWx1ZSA9PT0gb3RoZXIgfHxcbiAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgIGlzT2JqZWN0KG90aGVyKSAmJlxuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhvdGhlcikubGVuZ3RoICYmXG4gICAgICAgIGVhY2godmFsdWUsICh2YWwsIGtleSkgPT4gdmFsID09PSBvdGhlcltrZXldKSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzd2FwKHZhbHVlLCBhLCBiKSB7XG4gICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKGEgKyBcInxcIiArIGIsICdnJyksIChtYXRjaCkgPT4gbWF0Y2ggPT09IGEgPyBiIDogYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhY2gob2JqLCBjYikge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gY2Iob2JqW2tleV0sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnRCeSQxKGFycmF5LCBwcm9wKSB7XG4gICAgICByZXR1cm4gYXJyYXkuXG4gICAgICBzbGljZSgpLlxuICAgICAgc29ydCgoX3JlZiwgX3JlZjIpID0+IHtsZXQgeyBbcHJvcF06IHByb3BBID0gMCB9ID0gX3JlZjtsZXQgeyBbcHJvcF06IHByb3BCID0gMCB9ID0gX3JlZjI7cmV0dXJuIChcbiAgICAgICAgICBwcm9wQSA+IHByb3BCID8gMSA6IHByb3BCID4gcHJvcEEgPyAtMSA6IDApO30pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5pcXVlQnkoYXJyYXksIHByb3ApIHtcbiAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKChfcmVmMykgPT4ge2xldCB7IFtwcm9wXTogY2hlY2sgfSA9IF9yZWYzO3JldHVybiBzZWVuLmhhcyhjaGVjaykgPyBmYWxzZSA6IHNlZW4uYWRkKGNoZWNrKTt9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIG1pbiwgbWF4KSB7aWYgKG1pbiA9PT0gdm9pZCAwKSB7bWluID0gMDt9aWYgKG1heCA9PT0gdm9pZCAwKSB7bWF4ID0gMTt9XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodG9OdW1iZXIobnVtYmVyKSB8fCAwLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0UmVjdCgpIHtmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVjdHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7cmVjdHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07fVxuICAgICAgcmV0dXJuIFtcbiAgICAgIFsnYm90dG9tJywgJ3RvcCddLFxuICAgICAgWydyaWdodCcsICdsZWZ0J11dLlxuICAgICAgZXZlcnkoXG4gICAgICAoX3JlZjQpID0+IHtsZXQgW21pblByb3AsIG1heFByb3BdID0gX3JlZjQ7cmV0dXJuIChcbiAgICAgICAgICBNYXRoLm1pbiguLi5yZWN0cy5tYXAoKF9yZWY1KSA9PiB7bGV0IHsgW21pblByb3BdOiBtaW4gfSA9IF9yZWY1O3JldHVybiBtaW47fSkpIC1cbiAgICAgICAgICBNYXRoLm1heCguLi5yZWN0cy5tYXAoKF9yZWY2KSA9PiB7bGV0IHsgW21heFByb3BdOiBtYXggfSA9IF9yZWY2O3JldHVybiBtYXg7fSkpID5cbiAgICAgICAgICAwKTt9KTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50SW5SZWN0KHBvaW50LCByZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwb2ludC54IDw9IHJlY3QucmlnaHQgJiZcbiAgICAgICAgcG9pbnQueCA+PSByZWN0LmxlZnQgJiZcbiAgICAgICAgcG9pbnQueSA8PSByZWN0LmJvdHRvbSAmJlxuICAgICAgICBwb2ludC55ID49IHJlY3QudG9wKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhdGlvKGRpbWVuc2lvbnMsIHByb3AsIHZhbHVlKSB7XG4gICAgICBjb25zdCBhUHJvcCA9IHByb3AgPT09ICd3aWR0aCcgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFthUHJvcF06IGRpbWVuc2lvbnNbcHJvcF0gP1xuICAgICAgICBNYXRoLnJvdW5kKHZhbHVlICogZGltZW5zaW9uc1thUHJvcF0gLyBkaW1lbnNpb25zW3Byb3BdKSA6XG4gICAgICAgIGRpbWVuc2lvbnNbYVByb3BdLFxuICAgICAgICBbcHJvcF06IHZhbHVlIH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWluKGRpbWVuc2lvbnMsIG1heERpbWVuc2lvbnMpIHtcbiAgICAgIGRpbWVuc2lvbnMgPSB7IC4uLmRpbWVuc2lvbnMgfTtcblxuICAgICAgZm9yIChjb25zdCBwcm9wIGluIGRpbWVuc2lvbnMpIHtcbiAgICAgICAgZGltZW5zaW9ucyA9XG4gICAgICAgIGRpbWVuc2lvbnNbcHJvcF0gPiBtYXhEaW1lbnNpb25zW3Byb3BdID9cbiAgICAgICAgcmF0aW8oZGltZW5zaW9ucywgcHJvcCwgbWF4RGltZW5zaW9uc1twcm9wXSkgOlxuICAgICAgICBkaW1lbnNpb25zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3ZlciQxKGRpbWVuc2lvbnMsIG1heERpbWVuc2lvbnMpIHtcbiAgICAgIGRpbWVuc2lvbnMgPSBjb250YWluKGRpbWVuc2lvbnMsIG1heERpbWVuc2lvbnMpO1xuXG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBkaW1lbnNpb25zID1cbiAgICAgICAgZGltZW5zaW9uc1twcm9wXSA8IG1heERpbWVuc2lvbnNbcHJvcF0gP1xuICAgICAgICByYXRpbyhkaW1lbnNpb25zLCBwcm9wLCBtYXhEaW1lbnNpb25zW3Byb3BdKSA6XG4gICAgICAgIGRpbWVuc2lvbnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuICAgIH1cblxuICAgIGNvbnN0IERpbWVuc2lvbnMgPSB7IHJhdGlvLCBjb250YWluLCBjb3ZlcjogY292ZXIkMSB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoaSwgZWxlbWVudHMsIGN1cnJlbnQsIGZpbml0ZSkge2lmIChjdXJyZW50ID09PSB2b2lkIDApIHtjdXJyZW50ID0gMDt9aWYgKGZpbml0ZSA9PT0gdm9pZCAwKSB7ZmluaXRlID0gZmFsc2U7fVxuICAgICAgZWxlbWVudHMgPSB0b05vZGVzKGVsZW1lbnRzKTtcblxuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IGVsZW1lbnRzO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGkgPSBpc051bWVyaWMoaSkgP1xuICAgICAgdG9OdW1iZXIoaSkgOlxuICAgICAgaSA9PT0gJ25leHQnID9cbiAgICAgIGN1cnJlbnQgKyAxIDpcbiAgICAgIGkgPT09ICdwcmV2aW91cycgP1xuICAgICAgY3VycmVudCAtIDEgOlxuICAgICAgZWxlbWVudHMuaW5kZXhPZih0b05vZGUoaSkpO1xuXG4gICAgICBpZiAoZmluaXRlKSB7XG4gICAgICAgIHJldHVybiBjbGFtcChpLCAwLCBsZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgaSAlPSBsZW5ndGg7XG5cbiAgICAgIHJldHVybiBpIDwgMCA/IGkgKyBsZW5ndGggOiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiAoa2V5KSA9PiBjYWNoZVtrZXldIHx8IChjYWNoZVtrZXldID0gZm4oa2V5KSk7XG4gICAgfVxuXG4gICAgY2xhc3MgRGVmZXJyZWQge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgIH19XG5cbiAgICBmdW5jdGlvbiBhdHRyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZSkge1xuICAgICAgICAgIGF0dHIoZWxlbWVudCwga2V5LCBuYW1lW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge3ZhciBfdG9Ob2RlO1xuICAgICAgICByZXR1cm4gKF90b05vZGUgPSB0b05vZGUoZWxlbWVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfdG9Ob2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgdG9Ob2RlcyhlbGVtZW50KSkge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKGVsLCBhdHRyKGVsLCBuYW1lKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBdHRyKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQpID0+IGVsZW1lbnQuaGFzQXR0cmlidXRlKG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVBdHRyKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gdG9Ob2RlcyhlbGVtZW50KTtcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIG5hbWUuc3BsaXQoJyAnKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF0YShlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBbYXR0cmlidXRlLCBcImRhdGEtXCIgKyBhdHRyaWJ1dGVdKSB7XG4gICAgICAgIGlmIChoYXNBdHRyKGVsZW1lbnQsIG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHIoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2b2lkRWxlbWVudHMgPSB7XG4gICAgICBhcmVhOiB0cnVlLFxuICAgICAgYmFzZTogdHJ1ZSxcbiAgICAgIGJyOiB0cnVlLFxuICAgICAgY29sOiB0cnVlLFxuICAgICAgZW1iZWQ6IHRydWUsXG4gICAgICBocjogdHJ1ZSxcbiAgICAgIGltZzogdHJ1ZSxcbiAgICAgIGlucHV0OiB0cnVlLFxuICAgICAga2V5Z2VuOiB0cnVlLFxuICAgICAgbGluazogdHJ1ZSxcbiAgICAgIG1lbnVpdGVtOiB0cnVlLFxuICAgICAgbWV0YTogdHJ1ZSxcbiAgICAgIHBhcmFtOiB0cnVlLFxuICAgICAgc291cmNlOiB0cnVlLFxuICAgICAgdHJhY2s6IHRydWUsXG4gICAgICB3YnI6IHRydWUgfTtcblxuICAgIGZ1bmN0aW9uIGlzVm9pZEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZSgoZWxlbWVudCkgPT4gdm9pZEVsZW1lbnRzW2VsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWaXNpYmxlKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoXG4gICAgICAoZWxlbWVudCkgPT4gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcblxuICAgIH1cblxuICAgIGNvbnN0IHNlbElucHV0ID0gJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYSxidXR0b24nO1xuICAgIGZ1bmN0aW9uIGlzSW5wdXQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZSgoZWxlbWVudCkgPT4gbWF0Y2hlcyhlbGVtZW50LCBzZWxJbnB1dCkpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbEZvY3VzYWJsZSA9IHNlbElucHV0ICsgXCIsYVtocmVmXSxbdGFiaW5kZXhdXCI7XG4gICAgZnVuY3Rpb24gaXNGb2N1c2FibGUoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG1hdGNoZXMoZWxlbWVudCwgc2VsRm9jdXNhYmxlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJlbnQoZWxlbWVudCkge3ZhciBfdG9Ob2RlO1xuICAgICAgcmV0dXJuIChfdG9Ob2RlID0gdG9Ob2RlKGVsZW1lbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RvTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlciQxKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5maWx0ZXIoKGVsZW1lbnQpID0+IG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKChlbGVtZW50KSA9PiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc3RhcnRzV2l0aChzZWxlY3RvciwgJz4nKSkge1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNFbGVtZW50KGVsZW1lbnQpID9cbiAgICAgIGVsZW1lbnQuY2xvc2VzdChzZWxlY3RvcikgOlxuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5cbiAgICAgIG1hcCgoZWxlbWVudCkgPT4gY2xvc2VzdChlbGVtZW50LCBzZWxlY3RvcikpLlxuICAgICAgZmlsdGVyKEJvb2xlYW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhpbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKHNlbGVjdG9yKSA/XG4gICAgICBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB8fCAhIWNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIDpcbiAgICAgIGVsZW1lbnQgPT09IHNlbGVjdG9yIHx8IHRvTm9kZShzZWxlY3RvcikuY29udGFpbnModG9Ob2RlKGVsZW1lbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgICB3aGlsZSAoZWxlbWVudCA9IHBhcmVudChlbGVtZW50KSkge1xuICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGVsZW1lbnQgPSB0b05vZGUoZWxlbWVudCk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGVsZW1lbnQgPyB0b05vZGVzKGVsZW1lbnQuY2hpbGRyZW4pIDogW107XG4gICAgICByZXR1cm4gc2VsZWN0b3IgPyBmaWx0ZXIkMShjaGlsZHJlbiwgc2VsZWN0b3IpIDogY2hpbGRyZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZXgoZWxlbWVudCwgcmVmKSB7XG4gICAgICByZXR1cm4gcmVmID8gdG9Ob2RlcyhlbGVtZW50KS5pbmRleE9mKHRvTm9kZShyZWYpKSA6IGNoaWxkcmVuKHBhcmVudChlbGVtZW50KSkuaW5kZXhPZihlbGVtZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWVyeShzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGZpbmQoc2VsZWN0b3IsIGdldENvbnRleHQoc2VsZWN0b3IsIGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWVyeUFsbChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGZpbmRBbGwoc2VsZWN0b3IsIGdldENvbnRleHQoc2VsZWN0b3IsIGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlKF9xdWVyeShzZWxlY3RvciwgY29udGV4dCwgJ3F1ZXJ5U2VsZWN0b3InKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZEFsbChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoX3F1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0LCAncXVlcnlTZWxlY3RvckFsbCcpKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0U2VsZWN0b3JSZSA9IC8oXnxbXlxcXFxdLClcXHMqWyE+K34tXS87XG4gICAgY29uc3QgaXNDb250ZXh0U2VsZWN0b3IgPSBtZW1vaXplKChzZWxlY3RvcikgPT4gc2VsZWN0b3IubWF0Y2goY29udGV4dFNlbGVjdG9yUmUpKTtcblxuICAgIGZ1bmN0aW9uIGdldENvbnRleHQoc2VsZWN0b3IsIGNvbnRleHQpIHtpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7Y29udGV4dCA9IGRvY3VtZW50O31cbiAgICAgIHJldHVybiBpc1N0cmluZyhzZWxlY3RvcikgJiYgaXNDb250ZXh0U2VsZWN0b3Ioc2VsZWN0b3IpIHx8IGlzRG9jdW1lbnQoY29udGV4dCkgP1xuICAgICAgY29udGV4dCA6XG4gICAgICBjb250ZXh0Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dFNhbml0aXplUmUgPSAvKFshPit+LV0pKD89XFxzK1shPit+LV18XFxzKiQpL2c7XG4gICAgY29uc3Qgc2FuYXRpemUgPSBtZW1vaXplKChzZWxlY3RvcikgPT4gc2VsZWN0b3IucmVwbGFjZShjb250ZXh0U2FuaXRpemVSZSwgJyQxIConKSk7XG5cbiAgICBmdW5jdGlvbiBfcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQsIHF1ZXJ5Rm4pIHtpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7Y29udGV4dCA9IGRvY3VtZW50O31cbiAgICAgIGlmICghc2VsZWN0b3IgfHwgIWlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdG9yID0gc2FuYXRpemUoc2VsZWN0b3IpO1xuXG4gICAgICBpZiAoaXNDb250ZXh0U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHNlbGVjdG9yID0gJyc7XG4gICAgICAgIGZvciAobGV0IHNlbCBvZiBzcGxpdCkge1xuICAgICAgICAgIGxldCBjdHggPSBjb250ZXh0O1xuXG4gICAgICAgICAgaWYgKHNlbFswXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvcnMgPSBzZWwuc3Vic3RyKDEpLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgY3R4ID0gY2xvc2VzdChwYXJlbnQoY29udGV4dCksIHNlbGVjdG9yc1swXSk7XG4gICAgICAgICAgICBzZWwgPSBzZWxlY3RvcnMuc2xpY2UoMSkuam9pbignICcpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghc2VsLmxlbmd0aCAmJiBzcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsWzBdID09PSAnLScpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHNlbC5zdWJzdHIoMSkudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gKGN0eCB8fCBjb250ZXh0KS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgY3R4ID0gbWF0Y2hlcyhwcmV2LCBzZWwuc3Vic3RyKDEpKSA/IHByZXYgOiBudWxsO1xuICAgICAgICAgICAgc2VsID0gc2VsZWN0b3JzLnNsaWNlKDEpLmpvaW4oJyAnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBzZWxlY3RvciArPSBcIlwiICsgKHNlbGVjdG9yID8gJywnIDogJycpICsgZG9tUGF0aChjdHgpICsgXCIgXCIgKyBzZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dCA9IGRvY3VtZW50O1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29udGV4dFtxdWVyeUZuXShzZWxlY3Rvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdG9yUmUgPSAvLio/W15cXFxcXSg/Oix8JCkvZztcblxuICAgIGNvbnN0IHNwbGl0U2VsZWN0b3IgPSBtZW1vaXplKChzZWxlY3RvcikgPT5cbiAgICBzZWxlY3Rvci5tYXRjaChzZWxlY3RvclJlKS5tYXAoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5yZXBsYWNlKC8sJC8sICcnKS50cmltKCkpKTtcblxuXG4gICAgZnVuY3Rpb24gZG9tUGF0aChlbGVtZW50KSB7XG4gICAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb25zdCBpZCA9IGF0dHIoZWxlbWVudCwgJ2lkJyk7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIG5hbWVzLnVuc2hpZnQoXCIjXCIgKyBlc2NhcGUoaWQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgeyB0YWdOYW1lIH0gPSBlbGVtZW50O1xuICAgICAgICAgIGlmICh0YWdOYW1lICE9PSAnSFRNTCcpIHtcbiAgICAgICAgICAgIHRhZ05hbWUgKz0gXCI6bnRoLWNoaWxkKFwiICsgKGluZGV4KGVsZW1lbnQpICsgMSkgKyBcIilcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFtZXMudW5zaGlmdCh0YWdOYW1lKTtcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZXMuam9pbignID4gJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlKGNzcykge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNzcykgPyBDU1MuZXNjYXBlKGNzcykgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbigpIHtmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHthcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO31cbiAgICAgIGxldCBbdGFyZ2V0cywgdHlwZXMsIHNlbGVjdG9yLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSA9IGZhbHNlXSA9IGdldEFyZ3MoYXJncyk7XG5cbiAgICAgIGlmIChsaXN0ZW5lci5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxpc3RlbmVyID0gZGV0YWlsKGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZUNhcHR1cmUgIT0gbnVsbCAmJiB1c2VDYXB0dXJlLnNlbGYpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBzZWxmRmlsdGVyKGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGxpc3RlbmVyID0gZGVsZWdhdGUoc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgpID0+IG9mZih0YXJnZXRzLCB0eXBlcywgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZigpIHtmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHthcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07fVxuICAgICAgbGV0IFt0YXJnZXRzLCB0eXBlcywsIGxpc3RlbmVyLCB1c2VDYXB0dXJlID0gZmFsc2VdID0gZ2V0QXJncyhhcmdzKTtcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25jZSgpIHtmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHthcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107fVxuICAgICAgY29uc3QgW2VsZW1lbnQsIHR5cGVzLCBzZWxlY3RvciwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZSwgY29uZGl0aW9uXSA9IGdldEFyZ3MoYXJncyk7XG4gICAgICBjb25zdCBvZmYgPSBvbihcbiAgICAgIGVsZW1lbnQsXG4gICAgICB0eXBlcyxcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gIWNvbmRpdGlvbiB8fCBjb25kaXRpb24oZSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBvZmYoKTtcbiAgICAgICAgICBsaXN0ZW5lcihlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlQ2FwdHVyZSk7XG5cblxuICAgICAgcmV0dXJuIG9mZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyKHRhcmdldHMsIGV2ZW50LCBkZXRhaWwpIHtcbiAgICAgIHJldHVybiB0b0V2ZW50VGFyZ2V0cyh0YXJnZXRzKS5ldmVyeSgodGFyZ2V0KSA9PlxuICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoZXZlbnQsIHRydWUsIHRydWUsIGRldGFpbCkpKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCkge2lmIChidWJibGVzID09PSB2b2lkIDApIHtidWJibGVzID0gdHJ1ZTt9aWYgKGNhbmNlbGFibGUgPT09IHZvaWQgMCkge2NhbmNlbGFibGUgPSBmYWxzZTt9XG4gICAgICBpZiAoaXNTdHJpbmcoZSkpIHtcbiAgICAgICAgZSA9IG5ldyBDdXN0b21FdmVudChlLCB7IGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXJncyhhcmdzKSB7XG4gICAgICAvLyBFdmVudCB0YXJnZXRzXG4gICAgICBhcmdzWzBdID0gdG9FdmVudFRhcmdldHMoYXJnc1swXSk7XG5cbiAgICAgIC8vIEV2ZW50IHR5cGVzXG4gICAgICBpZiAoaXNTdHJpbmcoYXJnc1sxXSkpIHtcbiAgICAgICAgYXJnc1sxXSA9IGFyZ3NbMV0uc3BsaXQoJyAnKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVsZWdhdGU/XG4gICAgICBpZiAoaXNGdW5jdGlvbihhcmdzWzJdKSkge1xuICAgICAgICBhcmdzLnNwbGljZSgyLCAwLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGVnYXRlKHNlbGVjdG9yLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPVxuICAgICAgICBzZWxlY3RvclswXSA9PT0gJz4nID9cbiAgICAgICAgZmluZEFsbChzZWxlY3RvciwgZS5jdXJyZW50VGFyZ2V0KS5cbiAgICAgICAgcmV2ZXJzZSgpLlxuICAgICAgICBmaWx0ZXIoKGVsZW1lbnQpID0+IHdpdGhpbihlLnRhcmdldCwgZWxlbWVudCkpWzBdIDpcbiAgICAgICAgY2xvc2VzdChlLnRhcmdldCwgc2VsZWN0b3IpO1xuXG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgZS5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGFpbChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIChlKSA9PiBpc0FycmF5KGUuZGV0YWlsKSA/IGxpc3RlbmVyKGUsIC4uLmUuZGV0YWlsKSA6IGxpc3RlbmVyKGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGZGaWx0ZXIobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fCBlLnRhcmdldCA9PT0gZS5jdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmNhbGwobnVsbCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFdmVudFRhcmdldCh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0YXJnZXQgJiYgJ2FkZEV2ZW50TGlzdGVuZXInIGluIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0V2ZW50VGFyZ2V0KHRhcmdldCkge1xuICAgICAgcmV0dXJuIGlzRXZlbnRUYXJnZXQodGFyZ2V0KSA/IHRhcmdldCA6IHRvTm9kZSh0YXJnZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRXZlbnRUYXJnZXRzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodGFyZ2V0KSA/XG4gICAgICB0YXJnZXQubWFwKHRvRXZlbnRUYXJnZXQpLmZpbHRlcihCb29sZWFuKSA6XG4gICAgICBpc1N0cmluZyh0YXJnZXQpID9cbiAgICAgIGZpbmRBbGwodGFyZ2V0KSA6XG4gICAgICBpc0V2ZW50VGFyZ2V0KHRhcmdldCkgP1xuICAgICAgW3RhcmdldF0gOlxuICAgICAgdG9Ob2Rlcyh0YXJnZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVG91Y2goZSkge1xuICAgICAgcmV0dXJuIGUucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgfHwgISFlLnRvdWNoZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRQb3MoZSkge3ZhciBfZSR0b3VjaGVzLCBfZSRjaGFuZ2VkVG91Y2hlcztcbiAgICAgIGNvbnN0IHsgY2xpZW50WDogeCwgY2xpZW50WTogeSB9ID0gKChfZSR0b3VjaGVzID0gZS50b3VjaGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2UkdG91Y2hlc1swXSkgfHwgKChfZSRjaGFuZ2VkVG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXMpID09IG51bGwgPyB2b2lkIDAgOiBfZSRjaGFuZ2VkVG91Y2hlc1swXSkgfHwgZTtcblxuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFqYXgodXJsLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBlbnYgPSB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICB4aHI6IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBiZWZvcmVTZW5kOiBub29wLFxuICAgICAgICByZXNwb25zZVR5cGU6ICcnLFxuICAgICAgICAuLi5vcHRpb25zIH07XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS5cbiAgICAgIHRoZW4oKCkgPT4gZW52LmJlZm9yZVNlbmQoZW52KSkuXG4gICAgICB0aGVuKCgpID0+IHNlbmQodXJsLCBlbnYpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZW5kKHVybCwgZW52KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB7IHhociB9ID0gZW52O1xuXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBlbnYpIHtcbiAgICAgICAgICBpZiAocHJvcCBpbiB4aHIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHhocltwcm9wXSA9IGVudltwcm9wXTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHhoci5vcGVuKGVudi5tZXRob2QudG9VcHBlckNhc2UoKSwgdXJsKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBlbnYuaGVhZGVycykge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgZW52LmhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBvbih4aHIsICdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAwIHx8IHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAgICAgICByZXNvbHZlKHhocik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIGFzc2lnbihFcnJvcih4aHIuc3RhdHVzVGV4dCksIHtcbiAgICAgICAgICAgICAgeGhyLFxuICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMgfSkpO1xuXG5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9uKHhociwgJ2Vycm9yJywgKCkgPT4gcmVqZWN0KGFzc2lnbihFcnJvcignTmV0d29yayBFcnJvcicpLCB7IHhociB9KSkpO1xuICAgICAgICBvbih4aHIsICd0aW1lb3V0JywgKCkgPT4gcmVqZWN0KGFzc2lnbihFcnJvcignTmV0d29yayBUaW1lb3V0JyksIHsgeGhyIH0pKSk7XG5cbiAgICAgICAgeGhyLnNlbmQoZW52LmRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW1hZ2Uoc3JjLCBzcmNzZXQsIHNpemVzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzaXplcyAmJiAoaW1nLnNpemVzID0gc2l6ZXMpO1xuICAgICAgICBzcmNzZXQgJiYgKGltZy5zcmNzZXQgPSBzcmNzZXQpO1xuICAgICAgICBpbWcuc3JjID0gc3JjO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3NzTnVtYmVyID0ge1xuICAgICAgJ2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQnOiB0cnVlLFxuICAgICAgJ2NvbHVtbi1jb3VudCc6IHRydWUsXG4gICAgICAnZmlsbC1vcGFjaXR5JzogdHJ1ZSxcbiAgICAgICdmbGV4LWdyb3cnOiB0cnVlLFxuICAgICAgJ2ZsZXgtc2hyaW5rJzogdHJ1ZSxcbiAgICAgICdmb250LXdlaWdodCc6IHRydWUsXG4gICAgICAnbGluZS1oZWlnaHQnOiB0cnVlLFxuICAgICAgb3BhY2l0eTogdHJ1ZSxcbiAgICAgIG9yZGVyOiB0cnVlLFxuICAgICAgb3JwaGFuczogdHJ1ZSxcbiAgICAgICdzdHJva2UtZGFzaGFycmF5JzogdHJ1ZSxcbiAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6IHRydWUsXG4gICAgICB3aWRvd3M6IHRydWUsXG4gICAgICAnei1pbmRleCc6IHRydWUsXG4gICAgICB6b29tOiB0cnVlIH07XG5cblxuICAgIGZ1bmN0aW9uIGNzcyhlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5KSB7aWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHtwcmlvcml0eSA9ICcnO31cbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gdG9Ob2RlcyhlbGVtZW50KTtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBpZiAoaXNTdHJpbmcocHJvcGVydHkpKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBwcm9wTmFtZShwcm9wZXJ0eSk7XG5cbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgaXNOdW1lcmljKHZhbHVlKSAmJiAhY3NzTnVtYmVyW3Byb3BlcnR5XSA/XG4gICAgICAgICAgICB2YWx1ZSArIFwicHhcIiA6XG4gICAgICAgICAgICB2YWx1ZSB8fCBpc051bWJlcih2YWx1ZSkgP1xuICAgICAgICAgICAgdmFsdWUgOlxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBwcmlvcml0eSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcHJvcHNbcHJvcF0gPSBjc3MoZWxlbWVudCwgcHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9wcztcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBwcmlvcml0eSA9IHZhbHVlO1xuICAgICAgICAgIGVhY2gocHJvcGVydHksICh2YWx1ZSwgcHJvcGVydHkpID0+IGNzcyhlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50c1swXTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wZXJ0eVJlID0gL15cXHMqKFtcIiddKT8oLio/KVxcMVxccyokLztcbiAgICBmdW5jdGlvbiBnZXRDc3NWYXIobmFtZSwgZWxlbWVudCkge2lmIChlbGVtZW50ID09PSB2b2lkIDApIHtlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O31cbiAgICAgIHJldHVybiBjc3MoZWxlbWVudCwgXCItLXVrLVwiICsgbmFtZSkucmVwbGFjZShwcm9wZXJ0eVJlLCAnJDInKTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2RvbS1jc3NzdHlsZWRlY2xhcmF0aW9uLXNldHByb3BlcnR5XG4gICAgY29uc3QgcHJvcE5hbWUgPSBtZW1vaXplKChuYW1lKSA9PiB2ZW5kb3JQcm9wTmFtZShuYW1lKSk7XG5cbiAgICBjb25zdCBjc3NQcmVmaXhlcyA9IFsnd2Via2l0JywgJ21veiddO1xuXG4gICAgZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUobmFtZSkge1xuICAgICAgaWYgKG5hbWVbMF0gPT09ICctJykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cblxuICAgICAgbmFtZSA9IGh5cGhlbmF0ZShuYW1lKTtcblxuICAgICAgY29uc3QgeyBzdHlsZSB9ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICBpZiAobmFtZSBpbiBzdHlsZSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBjc3NQcmVmaXhlcy5sZW5ndGgsXG4gICAgICBwcmVmaXhlZE5hbWU7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcHJlZml4ZWROYW1lID0gXCItXCIgKyBjc3NQcmVmaXhlc1tpXSArIFwiLVwiICsgbmFtZTtcbiAgICAgICAgaWYgKHByZWZpeGVkTmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXhlZE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50KSB7Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge2FyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO31cbiAgICAgIGFwcGx5JDEoZWxlbWVudCwgYXJncywgJ2FkZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQpIHtmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge2FyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07fVxuICAgICAgYXBwbHkkMShlbGVtZW50LCBhcmdzLCAncmVtb3ZlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhlbGVtZW50LCBjbHMpIHtcbiAgICAgIGF0dHIoZWxlbWVudCwgJ2NsYXNzJywgKHZhbHVlKSA9PiAodmFsdWUgfHwgJycpLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxiXCIgKyBjbHMgKyBcIlxcXFxiXCIsICdnJyksICcnKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUNsYXNzKGVsZW1lbnQpIHtcbiAgICAgIChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0pICYmIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSk7XG4gICAgICAoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKSAmJiBhZGRDbGFzcyhlbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNscykge1xuICAgICAgW2Nsc10gPSBnZXRDbGFzc2VzKGNscyk7XG4gICAgICByZXR1cm4gISFjbHMgJiYgdG9Ob2RlcyhlbGVtZW50KS5zb21lKChub2RlKSA9PiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbHMsIGZvcmNlKSB7XG4gICAgICBjb25zdCBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhjbHMpO1xuXG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKGZvcmNlKSkge1xuICAgICAgICBmb3JjZSA9ICEhZm9yY2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0b05vZGVzKGVsZW1lbnQpKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2xzIG9mIGNsYXNzZXMpIHtcbiAgICAgICAgICBub2RlLmNsYXNzTGlzdC50b2dnbGUoY2xzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseSQxKGVsZW1lbnQsIGFyZ3MsIGZuKSB7XG4gICAgICBhcmdzID0gYXJncy5yZWR1Y2UoKGFyZ3MsIGFyZykgPT4gYXJncy5jb25jYXQoZ2V0Q2xhc3NlcyhhcmcpKSwgW10pO1xuXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdG9Ob2RlcyhlbGVtZW50KSkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdFtmbl0oLi4uYXJncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2xhc3NlcyhzdHIpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5zcGxpdCgvXFxzfCwvKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbihlbGVtZW50LCBwcm9wcywgZHVyYXRpb24sIHRpbWluZykge2lmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7ZHVyYXRpb24gPSA0MDA7fWlmICh0aW1pbmcgPT09IHZvaWQgMCkge3RpbWluZyA9ICdsaW5lYXInO31cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKFxuICAgICAgKGVsZW1lbnQpID0+XG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3NzKGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGNzcyhlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRyaWdnZXIoZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnKSwgZHVyYXRpb24pO1xuXG4gICAgICAgIG9uY2UoXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgICd0cmFuc2l0aW9uZW5kIHRyYW5zaXRpb25jYW5jZWxlZCcsXG4gICAgICAgIChfcmVmKSA9PiB7bGV0IHsgdHlwZSB9ID0gX3JlZjtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsICd1ay10cmFuc2l0aW9uJyk7XG4gICAgICAgICAgY3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogJycsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246ICcnLFxuICAgICAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAnJyB9KTtcblxuICAgICAgICAgIHR5cGUgPT09ICd0cmFuc2l0aW9uY2FuY2VsZWQnID8gcmVqZWN0KCkgOiByZXNvbHZlKGVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICB7IHNlbGY6IHRydWUgfSk7XG5cblxuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCAndWstdHJhbnNpdGlvbicpO1xuICAgICAgICBjc3MoZWxlbWVudCwge1xuICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMocHJvcHMpLm1hcChwcm9wTmFtZSkuam9pbignLCcpLFxuICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogZHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiB0aW1pbmcsXG4gICAgICAgICAgLi4ucHJvcHMgfSk7XG5cbiAgICAgIH0pKSk7XG5cblxuICAgIH1cblxuICAgIGNvbnN0IFRyYW5zaXRpb24gPSB7XG4gICAgICBzdGFydDogdHJhbnNpdGlvbixcblxuICAgICAgc3RvcChlbGVtZW50KSB7XG4gICAgICAgIHRyaWdnZXIoZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfSxcblxuICAgICAgY2FuY2VsKGVsZW1lbnQpIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAndHJhbnNpdGlvbmNhbmNlbGVkJyk7XG4gICAgICB9LFxuXG4gICAgICBpblByb2dyZXNzKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGhhc0NsYXNzKGVsZW1lbnQsICd1ay10cmFuc2l0aW9uJyk7XG4gICAgICB9IH07XG5cblxuICAgIGNvbnN0IGFuaW1hdGlvblByZWZpeCA9ICd1ay1hbmltYXRpb24tJztcblxuICAgIGZ1bmN0aW9uIGFuaW1hdGUkMShlbGVtZW50LCBhbmltYXRpb24sIGR1cmF0aW9uLCBvcmlnaW4sIG91dCkge2lmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7ZHVyYXRpb24gPSAyMDA7fVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5tYXAoXG4gICAgICAoZWxlbWVudCkgPT5cbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAnYW5pbWF0aW9uY2FuY2VsZWQnKTtcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRyaWdnZXIoZWxlbWVudCwgJ2FuaW1hdGlvbmVuZCcpLCBkdXJhdGlvbik7XG5cbiAgICAgICAgb25jZShcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgJ2FuaW1hdGlvbmVuZCBhbmltYXRpb25jYW5jZWxlZCcsXG4gICAgICAgIChfcmVmMikgPT4ge2xldCB7IHR5cGUgfSA9IF9yZWYyO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgICAgICB0eXBlID09PSAnYW5pbWF0aW9uY2FuY2VsZWQnID8gcmVqZWN0KCkgOiByZXNvbHZlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgY3NzKGVsZW1lbnQsICdhbmltYXRpb25EdXJhdGlvbicsICcnKTtcbiAgICAgICAgICByZW1vdmVDbGFzc2VzKGVsZW1lbnQsIGFuaW1hdGlvblByZWZpeCArIFwiXFxcXFMqXCIpO1xuICAgICAgICB9LFxuICAgICAgICB7IHNlbGY6IHRydWUgfSk7XG5cblxuICAgICAgICBjc3MoZWxlbWVudCwgJ2FuaW1hdGlvbkR1cmF0aW9uJywgZHVyYXRpb24gKyBcIm1zXCIpO1xuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBhbmltYXRpb24sIGFuaW1hdGlvblByZWZpeCArIChvdXQgPyAnbGVhdmUnIDogJ2VudGVyJykpO1xuXG4gICAgICAgIGlmIChzdGFydHNXaXRoKGFuaW1hdGlvbiwgYW5pbWF0aW9uUHJlZml4KSkge1xuICAgICAgICAgIG9yaWdpbiAmJiBhZGRDbGFzcyhlbGVtZW50LCBcInVrLXRyYW5zZm9ybS1vcmlnaW4tXCIgKyBvcmlnaW4pO1xuICAgICAgICAgIG91dCAmJiBhZGRDbGFzcyhlbGVtZW50LCBhbmltYXRpb25QcmVmaXggKyBcInJldmVyc2VcIik7XG4gICAgICAgIH1cbiAgICAgIH0pKSk7XG5cblxuICAgIH1cblxuICAgIGNvbnN0IGluUHJvZ3Jlc3MgPSBuZXcgUmVnRXhwKGFuaW1hdGlvblByZWZpeCArIFwiKGVudGVyfGxlYXZlKVwiKTtcbiAgICBjb25zdCBBbmltYXRpb24gPSB7XG4gICAgICBpbjogYW5pbWF0ZSQxLFxuXG4gICAgICBvdXQoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRlJDEoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luLCB0cnVlKTtcbiAgICAgIH0sXG5cbiAgICAgIGluUHJvZ3Jlc3MoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaW5Qcm9ncmVzcy50ZXN0KGF0dHIoZWxlbWVudCwgJ2NsYXNzJykpO1xuICAgICAgfSxcblxuICAgICAgY2FuY2VsKGVsZW1lbnQpIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAnYW5pbWF0aW9uY2FuY2VsZWQnKTtcbiAgICAgIH0gfTtcblxuICAgIGNvbnN0IGRpcnMkMSA9IHtcbiAgICAgIHdpZHRoOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgIGhlaWdodDogWyd0b3AnLCAnYm90dG9tJ10gfTtcblxuXG4gICAgZnVuY3Rpb24gZGltZW5zaW9ucyQxKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBpc0VsZW1lbnQoZWxlbWVudCkgP1xuICAgICAgdG9Ob2RlKGVsZW1lbnQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDpcbiAgICAgIHsgaGVpZ2h0OiBoZWlnaHQoZWxlbWVudCksIHdpZHRoOiB3aWR0aChlbGVtZW50KSwgdG9wOiAwLCBsZWZ0OiAwIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgICAgIGJvdHRvbTogcmVjdC50b3AgKyByZWN0LmhlaWdodCxcbiAgICAgICAgcmlnaHQ6IHJlY3QubGVmdCArIHJlY3Qud2lkdGggfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldChlbGVtZW50LCBjb29yZGluYXRlcykge1xuICAgICAgY29uc3QgY3VycmVudE9mZnNldCA9IGRpbWVuc2lvbnMkMShlbGVtZW50KTtcblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxZLCBzY3JvbGxYIH0gPSB0b1dpbmRvdyhlbGVtZW50KTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0QnkgPSB7IGhlaWdodDogc2Nyb2xsWSwgd2lkdGg6IHNjcm9sbFggfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGRpciBpbiBkaXJzJDEpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgZGlycyQxW2Rpcl0pIHtcbiAgICAgICAgICAgIGN1cnJlbnRPZmZzZXRbcHJvcF0gKz0gb2Zmc2V0QnlbZGlyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY3VycmVudE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcG9zID0gY3NzKGVsZW1lbnQsICdwb3NpdGlvbicpO1xuXG4gICAgICBlYWNoKGNzcyhlbGVtZW50LCBbJ2xlZnQnLCAndG9wJ10pLCAodmFsdWUsIHByb3ApID0+XG4gICAgICBjc3MoXG4gICAgICBlbGVtZW50LFxuICAgICAgcHJvcCxcbiAgICAgIGNvb3JkaW5hdGVzW3Byb3BdIC1cbiAgICAgIGN1cnJlbnRPZmZzZXRbcHJvcF0gK1xuICAgICAgdG9GbG9hdChwb3MgPT09ICdhYnNvbHV0ZScgJiYgdmFsdWUgPT09ICdhdXRvJyA/IHBvc2l0aW9uKGVsZW1lbnQpW3Byb3BdIDogdmFsdWUpKSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGxldCB7IHRvcCwgbGVmdCB9ID0gb2Zmc2V0KGVsZW1lbnQpO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIG93bmVyRG9jdW1lbnQ6IHsgYm9keSwgZG9jdW1lbnRFbGVtZW50IH0sXG4gICAgICAgIG9mZnNldFBhcmVudCB9ID1cbiAgICAgIHRvTm9kZShlbGVtZW50KTtcbiAgICAgIGxldCBwYXJlbnQgPSBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICB3aGlsZSAoXG4gICAgICBwYXJlbnQgJiYgKFxuICAgICAgcGFyZW50ID09PSBib2R5IHx8IHBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50KSAmJlxuICAgICAgY3NzKHBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKVxuICAgICAge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWxlbWVudChwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE9mZnNldCA9IG9mZnNldChwYXJlbnQpO1xuICAgICAgICB0b3AgLT0gcGFyZW50T2Zmc2V0LnRvcCArIHRvRmxvYXQoY3NzKHBhcmVudCwgJ2JvcmRlclRvcFdpZHRoJykpO1xuICAgICAgICBsZWZ0IC09IHBhcmVudE9mZnNldC5sZWZ0ICsgdG9GbG9hdChjc3MocGFyZW50LCAnYm9yZGVyTGVmdFdpZHRoJykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcCAtIHRvRmxvYXQoY3NzKGVsZW1lbnQsICdtYXJnaW5Ub3AnKSksXG4gICAgICAgIGxlZnQ6IGxlZnQgLSB0b0Zsb2F0KGNzcyhlbGVtZW50LCAnbWFyZ2luTGVmdCcpKSB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0UG9zaXRpb24oZWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gWzAsIDBdO1xuXG4gICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG9mZnNldFswXSArPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgb2Zmc2V0WzFdICs9IGVsZW1lbnQub2Zmc2V0TGVmdDtcblxuICAgICAgICBpZiAoY3NzKGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgY29uc3Qgd2luID0gdG9XaW5kb3coZWxlbWVudCk7XG4gICAgICAgICAgb2Zmc2V0WzBdICs9IHdpbi5zY3JvbGxZO1xuICAgICAgICAgIG9mZnNldFsxXSArPSB3aW4uc2Nyb2xsWDtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQpO1xuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGNvbnN0IGhlaWdodCA9IGRpbWVuc2lvbignaGVpZ2h0Jyk7XG4gICAgY29uc3Qgd2lkdGggPSBkaW1lbnNpb24oJ3dpZHRoJyk7XG5cbiAgICBmdW5jdGlvbiBkaW1lbnNpb24ocHJvcCkge1xuICAgICAgY29uc3QgcHJvcE5hbWUgPSB1Y2ZpcnN0KHByb3ApO1xuICAgICAgcmV0dXJuIChlbGVtZW50LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFtcImlubmVyXCIgKyBwcm9wTmFtZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRG9jdW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGVsZW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGRvY1tcIm9mZnNldFwiICsgcHJvcE5hbWVdLCBkb2NbXCJzY3JvbGxcIiArIHByb3BOYW1lXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcblxuICAgICAgICAgIHZhbHVlID0gY3NzKGVsZW1lbnQsIHByb3ApO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICdhdXRvJyA/IGVsZW1lbnRbXCJvZmZzZXRcIiArIHByb3BOYW1lXSA6IHRvRmxvYXQodmFsdWUpIHx8IDA7XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgLSBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3NzKFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICAhdmFsdWUgJiYgdmFsdWUgIT09IDAgPyAnJyA6ICt2YWx1ZSArIGJveE1vZGVsQWRqdXN0KGVsZW1lbnQsIHByb3ApICsgJ3B4Jyk7XG5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wLCBzaXppbmcpIHtpZiAoc2l6aW5nID09PSB2b2lkIDApIHtzaXppbmcgPSAnYm9yZGVyLWJveCc7fVxuICAgICAgcmV0dXJuIGNzcyhlbGVtZW50LCAnYm94U2l6aW5nJykgPT09IHNpemluZyA/XG4gICAgICBkaXJzJDFbcHJvcF0uXG4gICAgICBtYXAodWNmaXJzdCkuXG4gICAgICByZWR1Y2UoXG4gICAgICAodmFsdWUsIHByb3ApID0+XG4gICAgICB2YWx1ZSArXG4gICAgICB0b0Zsb2F0KGNzcyhlbGVtZW50LCBcInBhZGRpbmdcIiArIHByb3ApKSArXG4gICAgICB0b0Zsb2F0KGNzcyhlbGVtZW50LCBcImJvcmRlclwiICsgcHJvcCArIFwiV2lkdGhcIikpLFxuICAgICAgMCkgOlxuXG4gICAgICAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsaXBQb3NpdGlvbihwb3MpIHtcbiAgICAgIGZvciAoY29uc3QgZGlyIGluIGRpcnMkMSkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gZGlycyQxW2Rpcl0pIHtcbiAgICAgICAgICBpZiAoZGlycyQxW2Rpcl1baV0gPT09IHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIGRpcnMkMVtkaXJdWzEgLSBpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9QeCh2YWx1ZSwgcHJvcGVydHksIGVsZW1lbnQsIG9mZnNldERpbSkge2lmIChwcm9wZXJ0eSA9PT0gdm9pZCAwKSB7cHJvcGVydHkgPSAnd2lkdGgnO31pZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7ZWxlbWVudCA9IHdpbmRvdzt9aWYgKG9mZnNldERpbSA9PT0gdm9pZCAwKSB7b2Zmc2V0RGltID0gZmFsc2U7fVxuICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRvRmxvYXQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VDYWxjKHZhbHVlKS5yZWR1Y2UoKHJlc3VsdCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdW5pdCA9IHBhcnNlVW5pdCh2YWx1ZSk7XG4gICAgICAgIGlmICh1bml0KSB7XG4gICAgICAgICAgdmFsdWUgPSBwZXJjZW50KFxuICAgICAgICAgIHVuaXQgPT09ICd2aCcgP1xuICAgICAgICAgIGhlaWdodCh0b1dpbmRvdyhlbGVtZW50KSkgOlxuICAgICAgICAgIHVuaXQgPT09ICd2dycgP1xuICAgICAgICAgIHdpZHRoKHRvV2luZG93KGVsZW1lbnQpKSA6XG4gICAgICAgICAgb2Zmc2V0RGltID9cbiAgICAgICAgICBlbGVtZW50W1wib2Zmc2V0XCIgKyB1Y2ZpcnN0KHByb3BlcnR5KV0gOlxuICAgICAgICAgIGRpbWVuc2lvbnMkMShlbGVtZW50KVtwcm9wZXJ0eV0sXG4gICAgICAgICAgdmFsdWUpO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgdG9GbG9hdCh2YWx1ZSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWxjUmUgPSAvLT9cXGQrKD86XFwuXFxkKyk/KD86dlt3aF18JXxweCk/L2c7XG4gICAgY29uc3QgcGFyc2VDYWxjID0gbWVtb2l6ZSgoY2FsYykgPT4gY2FsYy50b1N0cmluZygpLnJlcGxhY2UoL1xccy9nLCAnJykubWF0Y2goY2FsY1JlKSB8fCBbXSk7XG4gICAgY29uc3QgdW5pdFJlJDEgPSAvKD86dltod118JSkkLztcbiAgICBjb25zdCBwYXJzZVVuaXQgPSBtZW1vaXplKChzdHIpID0+IChzdHIubWF0Y2godW5pdFJlJDEpIHx8IFtdKVswXSk7XG5cbiAgICBmdW5jdGlvbiBwZXJjZW50KGJhc2UsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZSAqIHRvRmxvYXQodmFsdWUpIC8gMTAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWR5KGZuKSB7XG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb25jZShkb2N1bWVudCwgJ0RPTUNvbnRlbnRMb2FkZWQnLCBmbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNUYWcoZWxlbWVudCwgdGFnTmFtZSkge3ZhciBfZWxlbWVudCR0YWdOYW1lO1xuICAgICAgcmV0dXJuIChlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiAoX2VsZW1lbnQkdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JHRhZ05hbWUudG9Mb3dlckNhc2UoKSkgPT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbXB0eShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gcmVwbGFjZUNoaWxkcmVuKGVsZW1lbnQsICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodG1sKHBhcmVudCwgaHRtbCkge1xuICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGh0bWwpID8gJChwYXJlbnQpLmlubmVySFRNTCA6IHJlcGxhY2VDaGlsZHJlbihwYXJlbnQsIGh0bWwpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcGxhY2VDaGlsZHJlbiA9IGFwcGx5Rm4oJ3JlcGxhY2VDaGlsZHJlbicpO1xuICAgIGNvbnN0IHByZXBlbmQgPSBhcHBseUZuKCdwcmVwZW5kJyk7XG4gICAgY29uc3QgYXBwZW5kID0gYXBwbHlGbignYXBwZW5kJyk7XG4gICAgY29uc3QgYmVmb3JlID0gYXBwbHlGbignYmVmb3JlJyk7XG4gICAgY29uc3QgYWZ0ZXIgPSBhcHBseUZuKCdhZnRlcicpO1xuXG4gICAgZnVuY3Rpb24gYXBwbHlGbihmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZWYsIGVsZW1lbnQpIHt2YXIgXyQ7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdG9Ob2Rlcyhpc1N0cmluZyhlbGVtZW50KSA/IGZyYWdtZW50KGVsZW1lbnQpIDogZWxlbWVudCk7XG4gICAgICAgIChfJCA9ICQocmVmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF8kW2ZuXSguLi5ub2Rlcyk7XG4gICAgICAgIHJldHVybiB1bndyYXBTaW5nbGUobm9kZXMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUkMShlbGVtZW50KSB7XG4gICAgICB0b05vZGVzKGVsZW1lbnQpLmZvckVhY2goKGVsZW1lbnQpID0+IGVsZW1lbnQucmVtb3ZlKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBBbGwoZWxlbWVudCwgc3RydWN0dXJlKSB7XG4gICAgICBzdHJ1Y3R1cmUgPSB0b05vZGUoYmVmb3JlKGVsZW1lbnQsIHN0cnVjdHVyZSkpO1xuXG4gICAgICB3aGlsZSAoc3RydWN0dXJlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgc3RydWN0dXJlID0gc3RydWN0dXJlLmZpcnN0Q2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZChzdHJ1Y3R1cmUsIGVsZW1lbnQpO1xuXG4gICAgICByZXR1cm4gc3RydWN0dXJlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBJbm5lcihlbGVtZW50LCBzdHJ1Y3R1cmUpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKFxuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5tYXAoKGVsZW1lbnQpID0+XG4gICAgICBlbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSA/XG4gICAgICB3cmFwQWxsKHRvTm9kZXMoZWxlbWVudC5jaGlsZE5vZGVzKSwgc3RydWN0dXJlKSA6XG4gICAgICBhcHBlbmQoZWxlbWVudCwgc3RydWN0dXJlKSkpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bndyYXAoZWxlbWVudCkge1xuICAgICAgdG9Ob2RlcyhlbGVtZW50KS5cbiAgICAgIG1hcChwYXJlbnQpLlxuICAgICAgZmlsdGVyKCh2YWx1ZSwgaW5kZXgsIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4KS5cbiAgICAgIGZvckVhY2goKHBhcmVudCkgPT4gcGFyZW50LnJlcGxhY2VXaXRoKC4uLnBhcmVudC5jaGlsZE5vZGVzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZnJhZ21lbnRSZSA9IC9eXFxzKjwoXFx3K3whKVtePl0qPi87XG4gICAgY29uc3Qgc2luZ2xlVGFnUmUgPSAvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPik/JC87XG5cbiAgICBmdW5jdGlvbiBmcmFnbWVudChodG1sKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gc2luZ2xlVGFnUmUuZXhlYyhodG1sKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG1hdGNoZXNbMV0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGlmIChmcmFnbWVudFJlLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgaHRtbC50cmltKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gaHRtbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZShjb250YWluZXIuY2hpbGROb2Rlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW53cmFwU2luZ2xlKG5vZGVzKSB7XG4gICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMSA/IG5vZGVzIDogbm9kZXNbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkobm9kZSwgZm4pIHtcbiAgICAgIGlmICghaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm4obm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgYXBwbHkobm9kZSwgZm4pO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gaXNIdG1sKHNlbGVjdG9yKSA/IHRvTm9kZShmcmFnbWVudChzZWxlY3RvcikpIDogZmluZChzZWxlY3RvciwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBpc0h0bWwoc2VsZWN0b3IpID8gdG9Ob2RlcyhmcmFnbWVudChzZWxlY3RvcikpIDogZmluZEFsbChzZWxlY3RvciwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIdG1sKHN0cikge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKHN0cikgJiYgc3RhcnRzV2l0aChzdHIudHJpbSgpLCAnPCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgIGNvbnN0IGlzUnRsID0gaW5Ccm93c2VyICYmIGF0dHIoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnZGlyJykgPT09ICdydGwnO1xuXG4gICAgY29uc3QgaGFzVG91Y2ggPSBpbkJyb3dzZXIgJiYgJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuICAgIGNvbnN0IGhhc1BvaW50ZXJFdmVudHMgPSBpbkJyb3dzZXIgJiYgd2luZG93LlBvaW50ZXJFdmVudDtcblxuICAgIGNvbnN0IHBvaW50ZXJEb3duID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVyZG93bicgOiBoYXNUb3VjaCA/ICd0b3VjaHN0YXJ0JyA6ICdtb3VzZWRvd24nO1xuICAgIGNvbnN0IHBvaW50ZXJNb3ZlID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVybW92ZScgOiBoYXNUb3VjaCA/ICd0b3VjaG1vdmUnIDogJ21vdXNlbW92ZSc7XG4gICAgY29uc3QgcG9pbnRlclVwID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVydXAnIDogaGFzVG91Y2ggPyAndG91Y2hlbmQnIDogJ21vdXNldXAnO1xuICAgIGNvbnN0IHBvaW50ZXJFbnRlciA9IGhhc1BvaW50ZXJFdmVudHMgPyAncG9pbnRlcmVudGVyJyA6IGhhc1RvdWNoID8gJycgOiAnbW91c2VlbnRlcic7XG4gICAgY29uc3QgcG9pbnRlckxlYXZlID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVybGVhdmUnIDogaGFzVG91Y2ggPyAnJyA6ICdtb3VzZWxlYXZlJztcbiAgICBjb25zdCBwb2ludGVyQ2FuY2VsID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVyY2FuY2VsJyA6ICd0b3VjaGNhbmNlbCc7XG5cbiAgICAvKlxuICAgICAgICBCYXNlZCBvbjpcbiAgICAgICAgQ29weXJpZ2h0IChjKSAyMDE2IFdpbHNvbiBQYWdlIHdpbHNvbnBhZ2VAbWUuY29tXG4gICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS93aWxzb25wYWdlL2Zhc3Rkb21cbiAgICAqL1xuXG4gICAgY29uc3QgZmFzdGRvbSA9IHtcbiAgICAgIHJlYWRzOiBbXSxcbiAgICAgIHdyaXRlczogW10sXG5cbiAgICAgIHJlYWQodGFzaykge1xuICAgICAgICB0aGlzLnJlYWRzLnB1c2godGFzayk7XG4gICAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICB9LFxuXG4gICAgICB3cml0ZSh0YXNrKSB7XG4gICAgICAgIHRoaXMud3JpdGVzLnB1c2godGFzayk7XG4gICAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICB9LFxuXG4gICAgICBjbGVhcih0YXNrKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLnJlYWRzLCB0YXNrKTtcbiAgICAgICAgcmVtb3ZlKHRoaXMud3JpdGVzLCB0YXNrKTtcbiAgICAgIH0sXG5cbiAgICAgIGZsdXNoIH07XG5cblxuICAgIGZ1bmN0aW9uIGZsdXNoKHJlY3Vyc2lvbikge1xuICAgICAgcnVuVGFza3MoZmFzdGRvbS5yZWFkcyk7XG4gICAgICBydW5UYXNrcyhmYXN0ZG9tLndyaXRlcy5zcGxpY2UoMCkpO1xuXG4gICAgICBmYXN0ZG9tLnNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZmFzdGRvbS5yZWFkcy5sZW5ndGggfHwgZmFzdGRvbS53cml0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHNjaGVkdWxlRmx1c2gocmVjdXJzaW9uICsgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gNDtcbiAgICBmdW5jdGlvbiBzY2hlZHVsZUZsdXNoKHJlY3Vyc2lvbikge1xuICAgICAgaWYgKGZhc3Rkb20uc2NoZWR1bGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmFzdGRvbS5zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgaWYgKHJlY3Vyc2lvbiAmJiByZWN1cnNpb24gPCBSRUNVUlNJT05fTElNSVQpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBmbHVzaChyZWN1cnNpb24pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBmbHVzaCgxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuVGFza3ModGFza3MpIHtcbiAgICAgIGxldCB0YXNrO1xuICAgICAgd2hpbGUgKHRhc2sgPSB0YXNrcy5zaGlmdCgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGFzaygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaXRlbSkge1xuICAgICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgICAgcmV0dXJuIH5pbmRleCAmJiBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE1vdXNlVHJhY2tlcigpIHt9XG5cbiAgICBNb3VzZVRyYWNrZXIucHJvdG90eXBlID0ge1xuICAgICAgcG9zaXRpb25zOiBbXSxcblxuICAgICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBbXTtcblxuICAgICAgICBsZXQgcG9zaXRpb247XG4gICAgICAgIHRoaXMudW5iaW5kID0gb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCAoZSkgPT4gcG9zaXRpb24gPSBnZXRFdmVudFBvcyhlKSk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25zLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MCk7XG4gICAgICB9LFxuXG4gICAgICBjYW5jZWwoKSB7dmFyIF90aGlzJHVuYmluZDtcbiAgICAgICAgKF90aGlzJHVuYmluZCA9IHRoaXMudW5iaW5kKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdW5iaW5kLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgIH0sXG5cbiAgICAgIG1vdmVzVG8odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IHA7XG5cbiAgICAgICAgY29uc3QgW3ByZXZQb3NpdGlvbl0gPSB0aGlzLnBvc2l0aW9ucztcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBsYXN0KHRoaXMucG9zaXRpb25zKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IFtwcmV2UG9zaXRpb24sIHBvc2l0aW9uXTtcblxuICAgICAgICBpZiAocG9pbnRJblJlY3QocG9zaXRpb24sIHApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGlhZ29uYWxzID0gW1xuICAgICAgICBbXG4gICAgICAgIHsgeDogbGVmdCwgeTogdG9wIH0sXG4gICAgICAgIHsgeDogcmlnaHQsIHk6IGJvdHRvbSB9XSxcblxuICAgICAgICBbXG4gICAgICAgIHsgeDogbGVmdCwgeTogYm90dG9tIH0sXG4gICAgICAgIHsgeDogcmlnaHQsIHk6IHRvcCB9XV07XG5cblxuXG4gICAgICAgIHJldHVybiBkaWFnb25hbHMuc29tZSgoZGlhZ29uYWwpID0+IHtcbiAgICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3QocGF0aCwgZGlhZ29uYWwpO1xuICAgICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24gJiYgcG9pbnRJblJlY3QoaW50ZXJzZWN0aW9uLCBwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IH07XG5cblxuICAgIC8vIEluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9nZW9tZXRyeS9wb2ludGxpbmVwbGFuZS9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoX3JlZiwgX3JlZjIpIHtsZXQgW3sgeDogeDEsIHk6IHkxIH0sIHsgeDogeDIsIHk6IHkyIH1dID0gX3JlZjtsZXQgW3sgeDogeDMsIHk6IHkzIH0sIHsgeDogeDQsIHk6IHk0IH1dID0gX3JlZjI7XG4gICAgICBjb25zdCBkZW5vbWluYXRvciA9ICh5NCAtIHkzKSAqICh4MiAtIHgxKSAtICh4NCAtIHgzKSAqICh5MiAtIHkxKTtcblxuICAgICAgLy8gTGluZXMgYXJlIHBhcmFsbGVsXG4gICAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1YSA9ICgoeDQgLSB4MykgKiAoeTEgLSB5MykgLSAoeTQgLSB5MykgKiAoeDEgLSB4MykpIC8gZGVub21pbmF0b3I7XG5cbiAgICAgIGlmICh1YSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIGludGVyc2VjdGlvblxuICAgICAgcmV0dXJuIHsgeDogeDEgKyB1YSAqICh4MiAtIHgxKSwgeTogeTEgKyB1YSAqICh5MiAtIHkxKSB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ic2VydmVJbnRlcnNlY3Rpb24odGFyZ2V0cywgY2IsIG9wdGlvbnMsIGludGVyc2VjdGluZykge2lmIChpbnRlcnNlY3RpbmcgPT09IHZvaWQgMCkge2ludGVyc2VjdGluZyA9IHRydWU7fVxuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICBpbnRlcnNlY3RpbmcgP1xuICAgICAgKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgIGlmIChlbnRyaWVzLnNvbWUoKGVudHJ5KSA9PiBlbnRyeS5pc0ludGVyc2VjdGluZykpIHtcbiAgICAgICAgICBjYihlbnRyaWVzLCBvYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgIH0gOlxuICAgICAgY2IsXG4gICAgICBvcHRpb25zKTtcblxuICAgICAgZm9yIChjb25zdCBlbCBvZiB0b05vZGVzKHRhcmdldHMpKSB7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzUmVzaXplT2JzZXJ2ZXIgPSBpbkJyb3dzZXIgJiYgd2luZG93LlJlc2l6ZU9ic2VydmVyO1xuICAgIGZ1bmN0aW9uIG9ic2VydmVSZXNpemUodGFyZ2V0cywgY2IsIG9wdGlvbnMpIHtpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7b3B0aW9ucyA9IHsgYm94OiAnYm9yZGVyLWJveCcgfTt9XG4gICAgICBpZiAoaGFzUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmUoUmVzaXplT2JzZXJ2ZXIsIHRhcmdldHMsIGNiLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmFsbGJhY2sgU2FmYXJpIDwgMTMuMVxuICAgICAgaW5pdFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICBsaXN0ZW5lcnMuYWRkKGNiKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgICAgfSB9O1xuXG4gICAgfVxuXG4gICAgbGV0IGxpc3RlbmVycztcbiAgICBmdW5jdGlvbiBpbml0UmVzaXplTGlzdGVuZXIoKSB7XG4gICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuXG4gICAgICAvLyB0aHJvdHRsZSAncmVzaXplJ1xuICAgICAgbGV0IHBlbmRpbmdSZXNpemU7XG4gICAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChwZW5kaW5nUmVzaXplKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdSZXNpemUgPSB0cnVlO1xuICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4gcGVuZGluZ1Jlc2l6ZSA9IGZhbHNlKTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBvbih3aW5kb3csICdsb2FkIHJlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBvbihkb2N1bWVudCwgJ2xvYWRlZG1ldGFkYXRhIGxvYWQnLCBoYW5kbGVSZXNpemUsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ic2VydmVNdXRhdGlvbih0YXJnZXRzLCBjYiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9ic2VydmUoTXV0YXRpb25PYnNlcnZlciwgdGFyZ2V0cywgY2IsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ic2VydmUoT2JzZXJ2ZXIsIHRhcmdldHMsIGNiLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBPYnNlcnZlcihjYik7XG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIHRvTm9kZXModGFyZ2V0cykpIHtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJhdHMgPSB7fTtcblxuICAgIHN0cmF0cy5ldmVudHMgPVxuICAgIHN0cmF0cy5jcmVhdGVkID1cbiAgICBzdHJhdHMuYmVmb3JlQ29ubmVjdCA9XG4gICAgc3RyYXRzLmNvbm5lY3RlZCA9XG4gICAgc3RyYXRzLmJlZm9yZURpc2Nvbm5lY3QgPVxuICAgIHN0cmF0cy5kaXNjb25uZWN0ZWQgPVxuICAgIHN0cmF0cy5kZXN0cm95ID1cbiAgICBjb25jYXRTdHJhdDtcblxuICAgIC8vIGFyZ3Mgc3RyYXRlZ3lcbiAgICBzdHJhdHMuYXJncyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWwgIT09IGZhbHNlICYmIGNvbmNhdFN0cmF0KGNoaWxkVmFsIHx8IHBhcmVudFZhbCk7XG4gICAgfTtcblxuICAgIC8vIHVwZGF0ZSBzdHJhdGVneVxuICAgIHN0cmF0cy51cGRhdGUgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHNvcnRCeSQxKFxuICAgICAgY29uY2F0U3RyYXQocGFyZW50VmFsLCBpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IHsgcmVhZDogY2hpbGRWYWwgfSA6IGNoaWxkVmFsKSxcbiAgICAgICdvcmRlcicpO1xuXG4gICAgfTtcblxuICAgIC8vIHByb3BlcnR5IHN0cmF0ZWd5XG4gICAgc3RyYXRzLnByb3BzID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgIGlmIChpc0FycmF5KGNoaWxkVmFsKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBjaGlsZFZhbCkge1xuICAgICAgICAgIHZhbHVlW2tleV0gPSBTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRWYWwgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmF0cy5tZXRob2RzKHBhcmVudFZhbCwgY2hpbGRWYWwpO1xuICAgIH07XG5cbiAgICAvLyBleHRlbmQgc3RyYXRlZ3lcbiAgICBzdHJhdHMuY29tcHV0ZWQgPSBzdHJhdHMubWV0aG9kcyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWwgPyBwYXJlbnRWYWwgPyB7IC4uLnBhcmVudFZhbCwgLi4uY2hpbGRWYWwgfSA6IGNoaWxkVmFsIDogcGFyZW50VmFsO1xuICAgIH07XG5cbiAgICAvLyBkYXRhIHN0cmF0ZWd5XG4gICAgc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgICAgIGlmICghdm0pIHtcbiAgICAgICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodm0pIHtcbiAgICAgICAgICByZXR1cm4gbWVyZ2VGbkRhdGEocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VGbkRhdGEocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZuRGF0YShwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICAgICAgcmV0dXJuIHN0cmF0cy5jb21wdXRlZChcbiAgICAgIGlzRnVuY3Rpb24ocGFyZW50VmFsKSA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSkgOiBwYXJlbnRWYWwsXG4gICAgICBpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKSA6IGNoaWxkVmFsKTtcblxuICAgIH1cblxuICAgIC8vIGNvbmNhdCBzdHJhdGVneVxuICAgIGZ1bmN0aW9uIGNvbmNhdFN0cmF0KHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgIHBhcmVudFZhbCA9IHBhcmVudFZhbCAmJiAhaXNBcnJheShwYXJlbnRWYWwpID8gW3BhcmVudFZhbF0gOiBwYXJlbnRWYWw7XG5cbiAgICAgIHJldHVybiBjaGlsZFZhbCA/XG4gICAgICBwYXJlbnRWYWwgP1xuICAgICAgcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbCkgOlxuICAgICAgaXNBcnJheShjaGlsZFZhbCkgP1xuICAgICAgY2hpbGRWYWwgOlxuICAgICAgW2NoaWxkVmFsXSA6XG4gICAgICBwYXJlbnRWYWw7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBzdHJhdGVneVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gaXNVbmRlZmluZWQoY2hpbGRWYWwpID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQsIHZtKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge307XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgICBmb3IgKGNvbnN0IG1peGluIG9mIGNoaWxkLm1peGlucykge1xuICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyZW50KSB7XG4gICAgICAgIG1lcmdlS2V5KGtleSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNoaWxkKSB7XG4gICAgICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgICAgIG1lcmdlS2V5KGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWVyZ2VLZXkoa2V5KSB7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IChzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQpKHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRpb25zLCBhcmdzKSB7aWYgKGFyZ3MgPT09IHZvaWQgMCkge2FyZ3MgPSBbXTt9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucyA/XG4gICAgICAgIHN0YXJ0c1dpdGgob3B0aW9ucywgJ3snKSA/XG4gICAgICAgIEpTT04ucGFyc2Uob3B0aW9ucykgOlxuICAgICAgICBhcmdzLmxlbmd0aCAmJiAhaW5jbHVkZXMob3B0aW9ucywgJzonKSA/XG4gICAgICAgIHsgW2FyZ3NbMF1dOiBvcHRpb25zIH0gOlxuICAgICAgICBvcHRpb25zLnNwbGl0KCc7JykucmVkdWNlKChvcHRpb25zLCBvcHRpb24pID0+IHtcbiAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBvcHRpb24uc3BsaXQoLzooLiopLyk7XG4gICAgICAgICAgaWYgKGtleSAmJiAhaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBvcHRpb25zW2tleS50cmltKCldID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfSwge30pIDpcbiAgICAgICAge307XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwbGF5KGVsKSB7XG4gICAgICBpZiAoaXNJRnJhbWUoZWwpKSB7XG4gICAgICAgIGNhbGwoZWwsIHsgZnVuYzogJ3BsYXlWaWRlbycsIG1ldGhvZDogJ3BsYXknIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNIVE1MNShlbCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlbC5wbGF5KCkuY2F0Y2gobm9vcCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXVzZShlbCkge1xuICAgICAgaWYgKGlzSUZyYW1lKGVsKSkge1xuICAgICAgICBjYWxsKGVsLCB7IGZ1bmM6ICdwYXVzZVZpZGVvJywgbWV0aG9kOiAncGF1c2UnIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNIVE1MNShlbCkpIHtcbiAgICAgICAgZWwucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdXRlKGVsKSB7XG4gICAgICBpZiAoaXNJRnJhbWUoZWwpKSB7XG4gICAgICAgIGNhbGwoZWwsIHsgZnVuYzogJ211dGUnLCBtZXRob2Q6ICdzZXRWb2x1bWUnLCB2YWx1ZTogMCB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSFRNTDUoZWwpKSB7XG4gICAgICAgIGVsLm11dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZpZGVvKGVsKSB7XG4gICAgICByZXR1cm4gaXNIVE1MNShlbCkgfHwgaXNJRnJhbWUoZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSFRNTDUoZWwpIHtcbiAgICAgIHJldHVybiBpc1RhZyhlbCwgJ3ZpZGVvJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJRnJhbWUoZWwpIHtcbiAgICAgIHJldHVybiBpc1RhZyhlbCwgJ2lmcmFtZScpICYmIChpc1lvdXR1YmUoZWwpIHx8IGlzVmltZW8oZWwpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1lvdXR1YmUoZWwpIHtcbiAgICAgIHJldHVybiAhIWVsLnNyYy5tYXRjaChcbiAgICAgIC9cXC9cXC8uKj95b3V0dWJlKC1ub2Nvb2tpZSk/XFwuW2Etel0rXFwvKHdhdGNoXFw/dj1bXiZcXHNdK3xlbWJlZCl8eW91dHVcXC5iZVxcLy4qLyk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZpbWVvKGVsKSB7XG4gICAgICByZXR1cm4gISFlbC5zcmMubWF0Y2goL3ZpbWVvXFwuY29tXFwvdmlkZW9cXC8uKi8pO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNhbGwoZWwsIGNtZCkge1xuICAgICAgYXdhaXQgZW5hYmxlQXBpKGVsKTtcbiAgICAgIHBvc3QoZWwsIGNtZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zdChlbCwgY21kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbC5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHsgZXZlbnQ6ICdjb21tYW5kJywgLi4uY21kIH0pLCAnKicpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBub29wXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGVLZXkgPSAnX3VrUGxheWVyJztcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgZnVuY3Rpb24gZW5hYmxlQXBpKGVsKSB7XG4gICAgICBpZiAoZWxbc3RhdGVLZXldKSB7XG4gICAgICAgIHJldHVybiBlbFtzdGF0ZUtleV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHlvdXR1YmUgPSBpc1lvdXR1YmUoZWwpO1xuICAgICAgY29uc3QgdmltZW8gPSBpc1ZpbWVvKGVsKTtcblxuICAgICAgY29uc3QgaWQgPSArK2NvdW50ZXI7XG4gICAgICBsZXQgcG9sbGVyO1xuXG4gICAgICByZXR1cm4gZWxbc3RhdGVLZXldID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgeW91dHViZSAmJlxuICAgICAgICBvbmNlKGVsLCAnbG9hZCcsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHBvc3QoZWwsIHsgZXZlbnQ6ICdsaXN0ZW5pbmcnLCBpZCB9KTtcbiAgICAgICAgICBwb2xsZXIgPSBzZXRJbnRlcnZhbChsaXN0ZW5lciwgMTAwKTtcbiAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvbmNlKHdpbmRvdywgJ21lc3NhZ2UnLCByZXNvbHZlLCBmYWxzZSwgKF9yZWYpID0+IHtsZXQgeyBkYXRhIH0gPSBfcmVmO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGRhdGEgJiYgKFxuICAgICAgICAgICAgICB5b3V0dWJlICYmIGRhdGEuaWQgPT09IGlkICYmIGRhdGEuZXZlbnQgPT09ICdvblJlYWR5JyB8fFxuICAgICAgICAgICAgICB2aW1lbyAmJiBOdW1iZXIoZGF0YS5wbGF5ZXJfaWQpID09PSBpZCkpO1xuXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWwuc3JjID0gXCJcIiArIGVsLnNyYyArIChpbmNsdWRlcyhlbC5zcmMsICc/JykgPyAnJicgOiAnPycpICsgKFxuICAgICAgICB5b3V0dWJlID8gJ2VuYWJsZWpzYXBpPTEnIDogXCJhcGk9MSZwbGF5ZXJfaWQ9XCIgKyBpZCk7XG5cbiAgICAgIH0pLnRoZW4oKCkgPT4gY2xlYXJJbnRlcnZhbChwb2xsZXIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0luVmlldyhlbGVtZW50LCBvZmZzZXRUb3AsIG9mZnNldExlZnQpIHtpZiAob2Zmc2V0VG9wID09PSB2b2lkIDApIHtvZmZzZXRUb3AgPSAwO31pZiAob2Zmc2V0TGVmdCA9PT0gdm9pZCAwKSB7b2Zmc2V0TGVmdCA9IDA7fVxuICAgICAgaWYgKCFpc1Zpc2libGUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0UmVjdChcbiAgICAgIC4uLnNjcm9sbFBhcmVudHMoZWxlbWVudCkuXG4gICAgICBtYXAoKHBhcmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCB9ID0gb2Zmc2V0Vmlld3BvcnQocGFyZW50KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogdG9wIC0gb2Zmc2V0VG9wLFxuICAgICAgICAgIGxlZnQ6IGxlZnQgLSBvZmZzZXRMZWZ0LFxuICAgICAgICAgIGJvdHRvbTogYm90dG9tICsgb2Zmc2V0VG9wLFxuICAgICAgICAgIHJpZ2h0OiByaWdodCArIG9mZnNldExlZnQgfTtcblxuICAgICAgfSkuXG4gICAgICBjb25jYXQob2Zmc2V0KGVsZW1lbnQpKSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxUb3AoZWxlbWVudCwgdG9wKSB7XG4gICAgICBpZiAoaXNXaW5kb3coZWxlbWVudCkgfHwgaXNEb2N1bWVudChlbGVtZW50KSkge1xuICAgICAgICBlbGVtZW50ID0gc2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSB0b05vZGUoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1VuZGVmaW5lZCh0b3ApKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsZW1lbnQsIF90ZW1wKSB7bGV0IHsgb2Zmc2V0OiBvZmZzZXRCeSA9IDAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICAgICAgY29uc3QgcGFyZW50cyA9IGlzVmlzaWJsZShlbGVtZW50KSA/IHNjcm9sbFBhcmVudHMoZWxlbWVudCkgOiBbXTtcbiAgICAgIHJldHVybiBwYXJlbnRzLnJlZHVjZShcbiAgICAgIChmbiwgc2Nyb2xsRWxlbWVudCwgaSkgPT4ge1xuICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQgfSA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IG1heFNjcm9sbCA9IHNjcm9sbEhlaWdodCAtIHZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQ6IGVsSGVpZ2h0LCB0b3A6IGVsVG9wIH0gPSBwYXJlbnRzW2kgLSAxXSA/XG4gICAgICAgIG9mZnNldFZpZXdwb3J0KHBhcmVudHNbaSAtIDFdKSA6XG4gICAgICAgIG9mZnNldChlbGVtZW50KTtcblxuICAgICAgICBsZXQgdG9wID0gTWF0aC5jZWlsKGVsVG9wIC0gdmlld3BvcnQudG9wIC0gb2Zmc2V0QnkgKyBzY3JvbGxUb3ApO1xuXG4gICAgICAgIGlmIChvZmZzZXRCeSA+IDAgJiYgb2Zmc2V0SGVpZ2h0IDwgZWxIZWlnaHQgKyBvZmZzZXRCeSkge1xuICAgICAgICAgIHRvcCArPSBvZmZzZXRCeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXRCeSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wID4gbWF4U2Nyb2xsKSB7XG4gICAgICAgICAgb2Zmc2V0QnkgLT0gdG9wIC0gbWF4U2Nyb2xsO1xuICAgICAgICAgIHRvcCA9IG1heFNjcm9sbDtcbiAgICAgICAgfSBlbHNlIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0QnkgLT0gdG9wO1xuICAgICAgICAgIHRvcCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKCkgPT4gc2Nyb2xsVG8oc2Nyb2xsRWxlbWVudCwgdG9wIC0gc2Nyb2xsVG9wKS50aGVuKGZuKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSkoKTtcblxuXG4gICAgICBmdW5jdGlvbiBzY3JvbGxUbyhlbGVtZW50LCB0b3ApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBnZXREdXJhdGlvbihNYXRoLmFicyh0b3ApKTtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAoZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSBlYXNlKGNsYW1wKChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24pKTtcblxuICAgICAgICAgICAgc2Nyb2xsVG9wKGVsZW1lbnQsIHNjcm9sbCArIHRvcCAqIHBlcmNlbnQpO1xuXG4gICAgICAgICAgICAvLyBzY3JvbGwgbW9yZSBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIG91ciBkZXN0aW5hdGlvblxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXREdXJhdGlvbihkaXN0KSB7XG4gICAgICAgIHJldHVybiA0MCAqIE1hdGgucG93KGRpc3QsIDAuMzc1KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWFzZShrKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsZWRPdmVyKGVsZW1lbnQsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtpZiAoc3RhcnRPZmZzZXQgPT09IHZvaWQgMCkge3N0YXJ0T2Zmc2V0ID0gMDt9aWYgKGVuZE9mZnNldCA9PT0gdm9pZCAwKSB7ZW5kT2Zmc2V0ID0gMDt9XG4gICAgICBpZiAoIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW3Njcm9sbEVsZW1lbnRdID0gc2Nyb2xsUGFyZW50cyhlbGVtZW50LCAvYXV0b3xzY3JvbGwvLCB0cnVlKTtcbiAgICAgIGNvbnN0IHsgc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUb3AgfSA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICBjb25zdCB7IGhlaWdodDogdmlld3BvcnRIZWlnaHQgfSA9IG9mZnNldFZpZXdwb3J0KHNjcm9sbEVsZW1lbnQpO1xuICAgICAgY29uc3QgbWF4U2Nyb2xsID0gc2Nyb2xsSGVpZ2h0IC0gdmlld3BvcnRIZWlnaHQ7XG4gICAgICBjb25zdCBlbGVtZW50T2Zmc2V0VG9wID0gb2Zmc2V0UG9zaXRpb24oZWxlbWVudClbMF0gLSBvZmZzZXRQb3NpdGlvbihzY3JvbGxFbGVtZW50KVswXTtcblxuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBlbGVtZW50T2Zmc2V0VG9wIC0gdmlld3BvcnRIZWlnaHQgKyBzdGFydE9mZnNldCk7XG4gICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihtYXhTY3JvbGwsIGVsZW1lbnRPZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGVuZE9mZnNldCk7XG5cbiAgICAgIHJldHVybiBjbGFtcCgoc2Nyb2xsVG9wIC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsUGFyZW50cyhlbGVtZW50LCBvdmVyZmxvd1JlLCBzY3JvbGxhYmxlKSB7aWYgKG92ZXJmbG93UmUgPT09IHZvaWQgMCkge292ZXJmbG93UmUgPSAvYXV0b3xzY3JvbGx8aGlkZGVuLzt9aWYgKHNjcm9sbGFibGUgPT09IHZvaWQgMCkge3Njcm9sbGFibGUgPSBmYWxzZTt9XG4gICAgICBjb25zdCBzY3JvbGxFbCA9IHNjcm9sbGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgIGxldCBhbmNlc3RvcnMgPSBwYXJlbnRzKGVsZW1lbnQpLnJldmVyc2UoKTtcbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5zbGljZShhbmNlc3RvcnMuaW5kZXhPZihzY3JvbGxFbCkgKyAxKTtcblxuICAgICAgY29uc3QgZml4ZWRJbmRleCA9IGZpbmRJbmRleChhbmNlc3RvcnMsIChlbCkgPT4gY3NzKGVsLCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJyk7XG4gICAgICBpZiAofmZpeGVkSW5kZXgpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLnNsaWNlKGZpeGVkSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3Njcm9sbEVsXS5cbiAgICAgIGNvbmNhdChcbiAgICAgIGFuY2VzdG9ycy5maWx0ZXIoXG4gICAgICAocGFyZW50KSA9PlxuICAgICAgb3ZlcmZsb3dSZS50ZXN0KGNzcyhwYXJlbnQsICdvdmVyZmxvdycpKSAmJiAoXG4gICAgICAhc2Nyb2xsYWJsZSB8fCBwYXJlbnQuc2Nyb2xsSGVpZ2h0ID4gb2Zmc2V0Vmlld3BvcnQocGFyZW50KS5oZWlnaHQpKSkuXG5cblxuICAgICAgcmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldFZpZXdwb3J0KHNjcm9sbEVsZW1lbnQpIHtcbiAgICAgIGxldCB2aWV3cG9ydEVsZW1lbnQgPSBnZXRWaWV3cG9ydCQxKHNjcm9sbEVsZW1lbnQpO1xuXG4gICAgICAvLyBpT1MgMTIgcmV0dXJucyA8Ym9keT4gYXMgc2Nyb2xsaW5nRWxlbWVudFxuICAgICAgaWYgKHZpZXdwb3J0RWxlbWVudCA9PT0gc2Nyb2xsaW5nRWxlbWVudCh2aWV3cG9ydEVsZW1lbnQpKSB7XG4gICAgICAgIHZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlY3QgPSBvZmZzZXQodmlld3BvcnRFbGVtZW50KTtcbiAgICAgIGZvciAobGV0IFtwcm9wLCBkaXIsIHN0YXJ0LCBlbmRdIG9mIFtcbiAgICAgIFsnd2lkdGgnLCAneCcsICdsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICBbJ2hlaWdodCcsICd5JywgJ3RvcCcsICdib3R0b20nXV0pXG4gICAgICB7XG4gICAgICAgIGlmICghaXNXaW5kb3coZ2V0Vmlld3BvcnQkMSh2aWV3cG9ydEVsZW1lbnQpKSkge1xuICAgICAgICAgIHJlY3Rbc3RhcnRdICs9IHRvRmxvYXQoY3NzKHZpZXdwb3J0RWxlbWVudCwgXCJib3JkZXJcIiArIHVjZmlyc3Qoc3RhcnQpICsgXCJXaWR0aFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdFtwcm9wXSA9IHJlY3RbZGlyXSA9IChcbiAgICAgICAgaXNXaW5kb3codmlld3BvcnRFbGVtZW50KSA/IHNjcm9sbGluZ0VsZW1lbnQodmlld3BvcnRFbGVtZW50KSA6IHZpZXdwb3J0RWxlbWVudClbXCJjbGllbnRcIiArXG4gICAgICAgIHVjZmlyc3QocHJvcCldO1xuICAgICAgICByZWN0W2VuZF0gPSByZWN0W3Byb3BdICsgcmVjdFtzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZG9jdW1lbnQ6IHsgc2Nyb2xsaW5nRWxlbWVudCB9IH0gPVxuICAgICAgdG9XaW5kb3coZWxlbWVudCk7XG4gICAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydCQxKHNjcm9sbEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBzY3JvbGxFbGVtZW50ID09PSBzY3JvbGxpbmdFbGVtZW50KHNjcm9sbEVsZW1lbnQpID8gd2luZG93IDogc2Nyb2xsRWxlbWVudDtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJzID0gW1xuICAgIFsnd2lkdGgnLCAneCcsICdsZWZ0JywgJ3JpZ2h0J10sXG4gICAgWydoZWlnaHQnLCAneScsICd0b3AnLCAnYm90dG9tJ11dO1xuXG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbkF0KGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgYXR0YWNoOiB7XG4gICAgICAgICAgZWxlbWVudDogWydsZWZ0JywgJ3RvcCddLFxuICAgICAgICAgIHRhcmdldDogWydsZWZ0JywgJ3RvcCddLFxuICAgICAgICAgIC4uLm9wdGlvbnMuYXR0YWNoIH0sXG5cbiAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgIC4uLm9wdGlvbnMgfTtcblxuXG4gICAgICBjb25zdCBkaW0gPSBvcHRpb25zLmZsaXAgP1xuICAgICAgYXR0YWNoVG9XaXRoRmxpcChlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpIDpcbiAgICAgIGF0dGFjaFRvKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgICAgIG9mZnNldChlbGVtZW50LCBkaW0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF0dGFjaFRvKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgbGV0IHsgYXR0YWNoLCBvZmZzZXQ6IG9mZnNldEJ5IH0gPSB7XG4gICAgICAgIGF0dGFjaDoge1xuICAgICAgICAgIGVsZW1lbnQ6IFsnbGVmdCcsICd0b3AnXSxcbiAgICAgICAgICB0YXJnZXQ6IFsnbGVmdCcsICd0b3AnXSxcbiAgICAgICAgICAuLi5vcHRpb25zLmF0dGFjaCB9LFxuXG4gICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICAuLi5vcHRpb25zIH07XG5cblxuICAgICAgY29uc3QgcG9zaXRpb24gPSBvZmZzZXQoZWxlbWVudCk7XG4gICAgICBjb25zdCB0YXJnZXRPZmZzZXQgPSBvZmZzZXQodGFyZ2V0KTtcbiAgICAgIGZvciAoY29uc3QgW2ksIFtwcm9wLCBkaXIsIHN0YXJ0LCBlbmRdXSBvZiBPYmplY3QuZW50cmllcyhkaXJzKSkge1xuICAgICAgICBwb3NpdGlvbltzdGFydF0gPSBwb3NpdGlvbltkaXJdID1cbiAgICAgICAgdGFyZ2V0T2Zmc2V0W3N0YXJ0XSArXG4gICAgICAgIG1vdmVCeShhdHRhY2gudGFyZ2V0W2ldLCBlbmQsIHRhcmdldE9mZnNldFtwcm9wXSkgLVxuICAgICAgICBtb3ZlQnkoYXR0YWNoLmVsZW1lbnRbaV0sIGVuZCwgcG9zaXRpb25bcHJvcF0pICtcbiAgICAgICAgK29mZnNldEJ5W2ldO1xuICAgICAgICBwb3NpdGlvbltlbmRdID0gcG9zaXRpb25bc3RhcnRdICsgcG9zaXRpb25bcHJvcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0YWNoVG9XaXRoRmxpcChlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gYXR0YWNoVG8oZWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHRhcmdldERpbSA9IG9mZnNldCh0YXJnZXQpO1xuXG4gICAgICBsZXQge1xuICAgICAgICBmbGlwLFxuICAgICAgICBhdHRhY2g6IHsgZWxlbWVudDogZWxBdHRhY2gsIHRhcmdldDogdGFyZ2V0QXR0YWNoIH0sXG4gICAgICAgIG9mZnNldDogZWxPZmZzZXQsXG4gICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgdmlld3BvcnRQYWRkaW5nIH0gPVxuICAgICAgb3B0aW9ucztcblxuICAgICAgbGV0IHZpZXdwb3J0cyA9IHNjcm9sbFBhcmVudHMoZWxlbWVudCk7XG4gICAgICBpZiAoYm91bmRhcnkgPT09IHRhcmdldCkge1xuICAgICAgICB2aWV3cG9ydHMgPSB2aWV3cG9ydHMuZmlsdGVyKCh2aWV3cG9ydCkgPT4gdmlld3BvcnQgIT09IGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtzY3JvbGxFbGVtZW50XSA9IHZpZXdwb3J0cztcbiAgICAgIHZpZXdwb3J0cy5wdXNoKHZpZXdwb3J0KTtcblxuICAgICAgY29uc3Qgb2Zmc2V0UG9zaXRpb24gPSB7IC4uLnBvc2l0aW9uIH07XG4gICAgICBmb3IgKGNvbnN0IFtpLCBbcHJvcCwgZGlyLCBzdGFydCwgZW5kXV0gb2YgT2JqZWN0LmVudHJpZXMoZGlycykpIHtcbiAgICAgICAgaWYgKGZsaXAgIT09IHRydWUgJiYgIWluY2x1ZGVzKGZsaXAsIGRpcikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpbGxGbGlwID1cbiAgICAgICAgIWludGVyc2VjdExpbmUocG9zaXRpb24sIHRhcmdldERpbSwgaSkgJiYgaW50ZXJzZWN0TGluZShwb3NpdGlvbiwgdGFyZ2V0RGltLCAxIC0gaSk7XG5cbiAgICAgICAgdmlld3BvcnQgPSBnZXRJbnRlcnNlY3Rpb25BcmVhKC4uLnZpZXdwb3J0cy5maWx0ZXIoQm9vbGVhbikubWFwKG9mZnNldFZpZXdwb3J0KSk7XG5cbiAgICAgICAgaWYgKHZpZXdwb3J0UGFkZGluZykge1xuICAgICAgICAgIHZpZXdwb3J0W3N0YXJ0XSArPSB2aWV3cG9ydFBhZGRpbmc7XG4gICAgICAgICAgdmlld3BvcnRbZW5kXSAtPSB2aWV3cG9ydFBhZGRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm91bmRhcnkgJiYgIXdpbGxGbGlwICYmIHBvc2l0aW9uW3Byb3BdIDw9IG9mZnNldChib3VuZGFyeSlbcHJvcF0pIHtcbiAgICAgICAgICB2aWV3cG9ydCA9IGdldEludGVyc2VjdGlvbkFyZWEodmlld3BvcnQsIG9mZnNldChib3VuZGFyeSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNJblN0YXJ0Qm91bmRhcnkgPSBwb3NpdGlvbltzdGFydF0gPj0gdmlld3BvcnRbc3RhcnRdO1xuICAgICAgICBjb25zdCBpc0luRW5kQm91bmRhcnkgPSBwb3NpdGlvbltlbmRdIDw9IHZpZXdwb3J0W2VuZF07XG5cbiAgICAgICAgaWYgKGlzSW5TdGFydEJvdW5kYXJ5ICYmIGlzSW5FbmRCb3VuZGFyeSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9mZnNldEJ5O1xuXG4gICAgICAgIC8vIEZsaXBcbiAgICAgICAgaWYgKHdpbGxGbGlwKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGVsQXR0YWNoW2ldID09PSBlbmQgJiYgaXNJblN0YXJ0Qm91bmRhcnkgfHxcbiAgICAgICAgICBlbEF0dGFjaFtpXSA9PT0gc3RhcnQgJiYgaXNJbkVuZEJvdW5kYXJ5KVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9mZnNldEJ5ID1cbiAgICAgICAgICAoZWxBdHRhY2hbaV0gPT09IHN0YXJ0ID9cbiAgICAgICAgICAtcG9zaXRpb25bcHJvcF0gOlxuICAgICAgICAgIGVsQXR0YWNoW2ldID09PSBlbmQgP1xuICAgICAgICAgIHBvc2l0aW9uW3Byb3BdIDpcbiAgICAgICAgICAwKSArIChcbiAgICAgICAgICB0YXJnZXRBdHRhY2hbaV0gPT09IHN0YXJ0ID9cbiAgICAgICAgICB0YXJnZXREaW1bcHJvcF0gOlxuICAgICAgICAgIHRhcmdldEF0dGFjaFtpXSA9PT0gZW5kID9cbiAgICAgICAgICAtdGFyZ2V0RGltW3Byb3BdIDpcbiAgICAgICAgICAwKSAtXG4gICAgICAgICAgZWxPZmZzZXRbaV0gKiAyO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICFpc0luU2Nyb2xsQXJlYShcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5wb3NpdGlvbixcbiAgICAgICAgICAgIFtzdGFydF06IHBvc2l0aW9uW3N0YXJ0XSArIG9mZnNldEJ5LFxuICAgICAgICAgICAgW2VuZF06IHBvc2l0aW9uW2VuZF0gKyBvZmZzZXRCeSB9LFxuXG4gICAgICAgICAgc2Nyb2xsRWxlbWVudCxcbiAgICAgICAgICBpKSlcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc0luU2Nyb2xsQXJlYShwb3NpdGlvbiwgc2Nyb2xsRWxlbWVudCwgaSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlY3Vyc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1BvcyA9IGF0dGFjaFRvV2l0aEZsaXAoZWxlbWVudCwgdGFyZ2V0LCB7XG4gICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgIGF0dGFjaDoge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsQXR0YWNoLm1hcChmbGlwRGlyKS5yZXZlcnNlKCksXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRBdHRhY2gubWFwKGZsaXBEaXIpLnJldmVyc2UoKSB9LFxuXG4gICAgICAgICAgICAgIG9mZnNldDogZWxPZmZzZXQucmV2ZXJzZSgpLFxuICAgICAgICAgICAgICBmbGlwOiBmbGlwID09PSB0cnVlID8gZmxpcCA6IFsuLi5mbGlwLCBkaXJzWzEgLSBpXVsxXV0sXG4gICAgICAgICAgICAgIHJlY3Vyc2lvbjogdHJ1ZSB9KTtcblxuXG4gICAgICAgICAgICBpZiAobmV3UG9zICYmIGlzSW5TY3JvbGxBcmVhKG5ld1Bvcywgc2Nyb2xsRWxlbWVudCwgMSAtIGkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXdQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTW92ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldEJ5ID1cbiAgICAgICAgICBjbGFtcChcbiAgICAgICAgICBjbGFtcChwb3NpdGlvbltzdGFydF0sIHZpZXdwb3J0W3N0YXJ0XSwgdmlld3BvcnRbZW5kXSAtIHBvc2l0aW9uW3Byb3BdKSxcbiAgICAgICAgICB0YXJnZXREaW1bc3RhcnRdIC0gcG9zaXRpb25bcHJvcF0gKyBlbE9mZnNldFtpXSxcbiAgICAgICAgICB0YXJnZXREaW1bZW5kXSAtIGVsT2Zmc2V0W2ldKSAtXG4gICAgICAgICAgcG9zaXRpb25bc3RhcnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0UG9zaXRpb25bc3RhcnRdID0gcG9zaXRpb25bZGlyXSA9IHBvc2l0aW9uW3N0YXJ0XSArIG9mZnNldEJ5O1xuICAgICAgICBvZmZzZXRQb3NpdGlvbltlbmRdICs9IG9mZnNldEJ5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0UG9zaXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZUJ5KHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgICAgcmV0dXJuIHN0YXJ0ID09PSAnY2VudGVyJyA/IGRpbSAvIDIgOiBzdGFydCA9PT0gZW5kID8gZGltIDogMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25BcmVhKCkge1xuICAgICAgbGV0IGFyZWEgPSB7fTtmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVjdHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7cmVjdHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07fVxuICAgICAgZm9yIChjb25zdCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgIGZvciAoY29uc3QgWywsIHN0YXJ0LCBlbmRdIG9mIGRpcnMpIHtcbiAgICAgICAgICBhcmVhW3N0YXJ0XSA9IE1hdGgubWF4KGFyZWFbc3RhcnRdIHx8IDAsIHJlY3Rbc3RhcnRdKTtcbiAgICAgICAgICBhcmVhW2VuZF0gPSBNYXRoLm1pbiguLi5bYXJlYVtlbmRdLCByZWN0W2VuZF1dLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW5TY3JvbGxBcmVhKHBvc2l0aW9uLCBzY3JvbGxFbGVtZW50LCBkaXIpIHtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICBjb25zdCBbcHJvcCwsIHN0YXJ0LCBlbmRdID0gZGlyc1tkaXJdO1xuICAgICAgdmlld3BvcnRbc3RhcnRdIC09IHNjcm9sbEVsZW1lbnRbXCJzY3JvbGxcIiArIHVjZmlyc3Qoc3RhcnQpXTtcbiAgICAgIHZpZXdwb3J0W2VuZF0gPSB2aWV3cG9ydFtzdGFydF0gKyBzY3JvbGxFbGVtZW50W1wic2Nyb2xsXCIgKyB1Y2ZpcnN0KHByb3ApXTtcblxuICAgICAgcmV0dXJuIHBvc2l0aW9uW3N0YXJ0XSA+PSB2aWV3cG9ydFtzdGFydF0gJiYgcG9zaXRpb25bZW5kXSA8PSB2aWV3cG9ydFtlbmRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludGVyc2VjdExpbmUoZGltQSwgZGltQiwgZGlyKSB7XG4gICAgICBjb25zdCBbLCwgc3RhcnQsIGVuZF0gPSBkaXJzW2Rpcl07XG4gICAgICByZXR1cm4gZGltQVtlbmRdID4gZGltQltzdGFydF0gJiYgZGltQltlbmRdID4gZGltQVtzdGFydF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmxpcERpcihwcm9wKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBkaXJzW2ldLmluZGV4T2YocHJvcCk7XG4gICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gZGlyc1sxIC0gaV1baW5kZXggJSAyICsgMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXRpbCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBhamF4OiBhamF4LFxuICAgICAgICBnZXRJbWFnZTogZ2V0SW1hZ2UsXG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICAgIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gICAgICAgIGFuaW1hdGU6IGFuaW1hdGUkMSxcbiAgICAgICAgQW5pbWF0aW9uOiBBbmltYXRpb24sXG4gICAgICAgIGF0dHI6IGF0dHIsXG4gICAgICAgIGhhc0F0dHI6IGhhc0F0dHIsXG4gICAgICAgIHJlbW92ZUF0dHI6IHJlbW92ZUF0dHIsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICAgICAgICByZW1vdmVDbGFzc2VzOiByZW1vdmVDbGFzc2VzLFxuICAgICAgICByZXBsYWNlQ2xhc3M6IHJlcGxhY2VDbGFzcyxcbiAgICAgICAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxuICAgICAgICB0b2dnbGVDbGFzczogdG9nZ2xlQ2xhc3MsXG4gICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMkMSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgb2Zmc2V0UG9zaXRpb246IG9mZnNldFBvc2l0aW9uLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBib3hNb2RlbEFkanVzdDogYm94TW9kZWxBZGp1c3QsXG4gICAgICAgIGZsaXBQb3NpdGlvbjogZmxpcFBvc2l0aW9uLFxuICAgICAgICB0b1B4OiB0b1B4LFxuICAgICAgICByZWFkeTogcmVhZHksXG4gICAgICAgIGlzVGFnOiBpc1RhZyxcbiAgICAgICAgZW1wdHk6IGVtcHR5LFxuICAgICAgICBodG1sOiBodG1sLFxuICAgICAgICByZXBsYWNlQ2hpbGRyZW46IHJlcGxhY2VDaGlsZHJlbixcbiAgICAgICAgcHJlcGVuZDogcHJlcGVuZCxcbiAgICAgICAgYXBwZW5kOiBhcHBlbmQsXG4gICAgICAgIGJlZm9yZTogYmVmb3JlLFxuICAgICAgICBhZnRlcjogYWZ0ZXIsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlJDEsXG4gICAgICAgIHdyYXBBbGw6IHdyYXBBbGwsXG4gICAgICAgIHdyYXBJbm5lcjogd3JhcElubmVyLFxuICAgICAgICB1bndyYXA6IHVud3JhcCxcbiAgICAgICAgZnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgICAgICBhcHBseTogYXBwbHksXG4gICAgICAgICQ6ICQsXG4gICAgICAgICQkOiAkJCxcbiAgICAgICAgaW5Ccm93c2VyOiBpbkJyb3dzZXIsXG4gICAgICAgIGlzUnRsOiBpc1J0bCxcbiAgICAgICAgaGFzVG91Y2g6IGhhc1RvdWNoLFxuICAgICAgICBwb2ludGVyRG93bjogcG9pbnRlckRvd24sXG4gICAgICAgIHBvaW50ZXJNb3ZlOiBwb2ludGVyTW92ZSxcbiAgICAgICAgcG9pbnRlclVwOiBwb2ludGVyVXAsXG4gICAgICAgIHBvaW50ZXJFbnRlcjogcG9pbnRlckVudGVyLFxuICAgICAgICBwb2ludGVyTGVhdmU6IHBvaW50ZXJMZWF2ZSxcbiAgICAgICAgcG9pbnRlckNhbmNlbDogcG9pbnRlckNhbmNlbCxcbiAgICAgICAgb246IG9uLFxuICAgICAgICBvZmY6IG9mZixcbiAgICAgICAgb25jZTogb25jZSxcbiAgICAgICAgdHJpZ2dlcjogdHJpZ2dlcixcbiAgICAgICAgY3JlYXRlRXZlbnQ6IGNyZWF0ZUV2ZW50LFxuICAgICAgICB0b0V2ZW50VGFyZ2V0czogdG9FdmVudFRhcmdldHMsXG4gICAgICAgIGlzVG91Y2g6IGlzVG91Y2gsXG4gICAgICAgIGdldEV2ZW50UG9zOiBnZXRFdmVudFBvcyxcbiAgICAgICAgZmFzdGRvbTogZmFzdGRvbSxcbiAgICAgICAgaXNWb2lkRWxlbWVudDogaXNWb2lkRWxlbWVudCxcbiAgICAgICAgaXNWaXNpYmxlOiBpc1Zpc2libGUsXG4gICAgICAgIHNlbElucHV0OiBzZWxJbnB1dCxcbiAgICAgICAgaXNJbnB1dDogaXNJbnB1dCxcbiAgICAgICAgc2VsRm9jdXNhYmxlOiBzZWxGb2N1c2FibGUsXG4gICAgICAgIGlzRm9jdXNhYmxlOiBpc0ZvY3VzYWJsZSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyJDEsXG4gICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gICAgICAgIHdpdGhpbjogd2l0aGluLFxuICAgICAgICBwYXJlbnRzOiBwYXJlbnRzLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgaGFzT3duOiBoYXNPd24sXG4gICAgICAgIGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuICAgICAgICBjYW1lbGl6ZTogY2FtZWxpemUsXG4gICAgICAgIHVjZmlyc3Q6IHVjZmlyc3QsXG4gICAgICAgIHN0YXJ0c1dpdGg6IHN0YXJ0c1dpdGgsXG4gICAgICAgIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgICAgICAgaW5jbHVkZXM6IGluY2x1ZGVzLFxuICAgICAgICBmaW5kSW5kZXg6IGZpbmRJbmRleCxcbiAgICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgICAgdG9BcnJheTogdG9BcnJheSxcbiAgICAgICAgYXNzaWduOiBhc3NpZ24sXG4gICAgICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICAgICAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgICAgICAgaXNXaW5kb3c6IGlzV2luZG93LFxuICAgICAgICBpc0RvY3VtZW50OiBpc0RvY3VtZW50LFxuICAgICAgICBpc05vZGU6IGlzTm9kZSxcbiAgICAgICAgaXNFbGVtZW50OiBpc0VsZW1lbnQsXG4gICAgICAgIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICAgICAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgICAgIGlzTnVtYmVyOiBpc051bWJlcixcbiAgICAgICAgaXNOdW1lcmljOiBpc051bWVyaWMsXG4gICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgICAgIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgICAgICAgdG9Cb29sZWFuOiB0b0Jvb2xlYW4sXG4gICAgICAgIHRvTnVtYmVyOiB0b051bWJlcixcbiAgICAgICAgdG9GbG9hdDogdG9GbG9hdCxcbiAgICAgICAgdG9Ob2RlOiB0b05vZGUsXG4gICAgICAgIHRvTm9kZXM6IHRvTm9kZXMsXG4gICAgICAgIHRvV2luZG93OiB0b1dpbmRvdyxcbiAgICAgICAgaXNFcXVhbDogaXNFcXVhbCxcbiAgICAgICAgc3dhcDogc3dhcCxcbiAgICAgICAgbGFzdDogbGFzdCxcbiAgICAgICAgZWFjaDogZWFjaCxcbiAgICAgICAgc29ydEJ5OiBzb3J0QnkkMSxcbiAgICAgICAgdW5pcXVlQnk6IHVuaXF1ZUJ5LFxuICAgICAgICBjbGFtcDogY2xhbXAsXG4gICAgICAgIG5vb3A6IG5vb3AsXG4gICAgICAgIGludGVyc2VjdFJlY3Q6IGludGVyc2VjdFJlY3QsXG4gICAgICAgIHBvaW50SW5SZWN0OiBwb2ludEluUmVjdCxcbiAgICAgICAgRGltZW5zaW9uczogRGltZW5zaW9ucyxcbiAgICAgICAgZ2V0SW5kZXg6IGdldEluZGV4LFxuICAgICAgICBtZW1vaXplOiBtZW1vaXplLFxuICAgICAgICBEZWZlcnJlZDogRGVmZXJyZWQsXG4gICAgICAgIE1vdXNlVHJhY2tlcjogTW91c2VUcmFja2VyLFxuICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uOiBvYnNlcnZlSW50ZXJzZWN0aW9uLFxuICAgICAgICBvYnNlcnZlUmVzaXplOiBvYnNlcnZlUmVzaXplLFxuICAgICAgICBvYnNlcnZlTXV0YXRpb246IG9ic2VydmVNdXRhdGlvbixcbiAgICAgICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgICAgIHBhcnNlT3B0aW9uczogcGFyc2VPcHRpb25zLFxuICAgICAgICBwbGF5OiBwbGF5LFxuICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgIG11dGU6IG11dGUsXG4gICAgICAgIGlzVmlkZW86IGlzVmlkZW8sXG4gICAgICAgIHBvc2l0aW9uQXQ6IHBvc2l0aW9uQXQsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgcXVlcnlBbGw6IHF1ZXJ5QWxsLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBmaW5kQWxsOiBmaW5kQWxsLFxuICAgICAgICBlc2NhcGU6IGVzY2FwZSxcbiAgICAgICAgY3NzOiBjc3MsXG4gICAgICAgIGdldENzc1ZhcjogZ2V0Q3NzVmFyLFxuICAgICAgICBwcm9wTmFtZTogcHJvcE5hbWUsXG4gICAgICAgIGlzSW5WaWV3OiBpc0luVmlldyxcbiAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3AsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBzY3JvbGxJbnRvVmlldyxcbiAgICAgICAgc2Nyb2xsZWRPdmVyOiBzY3JvbGxlZE92ZXIsXG4gICAgICAgIHNjcm9sbFBhcmVudHM6IHNjcm9sbFBhcmVudHMsXG4gICAgICAgIG9mZnNldFZpZXdwb3J0OiBvZmZzZXRWaWV3cG9ydFxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2xvYmFsQVBJIChVSWtpdCkge1xuICAgICAgY29uc3QgREFUQSA9IFVJa2l0LmRhdGE7XG5cbiAgICAgIFVJa2l0LnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwbHVnaW4uY2FsbChudWxsLCB0aGlzKTtcbiAgICAgICAgcGx1Z2luLmluc3RhbGxlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbiwgY29tcG9uZW50KSB7XG4gICAgICAgIGNvbXBvbmVudCA9IChpc1N0cmluZyhjb21wb25lbnQpID8gVUlraXQuY29tcG9uZW50KGNvbXBvbmVudCkgOiBjb21wb25lbnQpIHx8IHRoaXM7XG4gICAgICAgIGNvbXBvbmVudC5vcHRpb25zID0gbWVyZ2VPcHRpb25zKGNvbXBvbmVudC5vcHRpb25zLCBtaXhpbik7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5leHRlbmQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBjb25zdCBTdXBlciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IFN1YiA9IGZ1bmN0aW9uIFVJa2l0Q29tcG9uZW50KG9wdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFN1cGVyLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIFN1Yi5zdXBlciA9IFN1cGVyO1xuICAgICAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuXG4gICAgICAgIHJldHVybiBTdWI7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC51cGRhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgZSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudCA/IHRvTm9kZShlbGVtZW50KSA6IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgICAgZm9yIChjb25zdCBwYXJlbnRFbCBvZiBwYXJlbnRzKGVsZW1lbnQpLnJldmVyc2UoKSkge1xuICAgICAgICAgIHVwZGF0ZShwYXJlbnRFbFtEQVRBXSwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBseShlbGVtZW50LCAoZWxlbWVudCkgPT4gdXBkYXRlKGVsZW1lbnRbREFUQV0sIGUpKTtcbiAgICAgIH07XG5cbiAgICAgIGxldCBjb250YWluZXI7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVUlraXQsICdjb250YWluZXInLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgICBjb250YWluZXIgPSAkKGVsZW1lbnQpO1xuICAgICAgICB9IH0pO1xuXG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZShkYXRhLCBlKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKGRhdGFbbmFtZV0uX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgZGF0YVtuYW1lXS5fY2FsbFVwZGF0ZShlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBob29rc0FQSSAoVUlraXQpIHtcbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fY2FsbEhvb2sgPSBmdW5jdGlvbiAoaG9vaykge3ZhciBfdGhpcyQkb3B0aW9ucyRob29rO1xuICAgICAgICAoX3RoaXMkJG9wdGlvbnMkaG9vayA9IHRoaXMuJG9wdGlvbnNbaG9va10pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyQkb3B0aW9ucyRob29rLmZvckVhY2goKGhhbmRsZXIpID0+IGhhbmRsZXIuY2FsbCh0aGlzKSk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2NhbGxDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG4gICAgICAgIHRoaXMuX2NvbXB1dGVkID0ge307XG5cbiAgICAgICAgdGhpcy5faW5pdFByb3BzKCk7XG5cbiAgICAgICAgdGhpcy5fY2FsbEhvb2soJ2JlZm9yZUNvbm5lY3QnKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX2luaXRPYnNlcnZlcnMoKTtcblxuICAgICAgICB0aGlzLl9jYWxsSG9vaygnY29ubmVjdGVkJyk7XG4gICAgICAgIHRoaXMuX2NhbGxVcGRhdGUoKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fY2FsbERpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWxsSG9vaygnYmVmb3JlRGlzY29ubmVjdCcpO1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0T2JzZXJ2ZXJzKCk7XG4gICAgICAgIHRoaXMuX3VuYmluZEV2ZW50cygpO1xuICAgICAgICB0aGlzLl9jYWxsSG9vaygnZGlzY29ubmVjdGVkJyk7XG5cbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl93YXRjaDtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fY2FsbFVwZGF0ZSA9IGZ1bmN0aW9uIChlKSB7aWYgKGUgPT09IHZvaWQgMCkge2UgPSAndXBkYXRlJzt9XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUgPT09ICd1cGRhdGUnIHx8IGUgPT09ICdyZXNpemUnKSB7XG4gICAgICAgICAgdGhpcy5fY2FsbFdhdGNoZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy4kb3B0aW9ucy51cGRhdGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3VwZGF0ZXMpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGZhc3Rkb20ucmVhZCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIHJ1blVwZGF0ZXMuY2FsbCh0aGlzLCB0aGlzLl91cGRhdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlcy5hZGQoZS50eXBlIHx8IGUpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9jYWxsV2F0Y2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhdGNoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5pdGlhbCA9ICFoYXNPd24odGhpcywgJ193YXRjaCcpO1xuXG4gICAgICAgIHRoaXMuX3dhdGNoID0gZmFzdGRvbS5yZWFkKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBydW5XYXRjaGVzLmNhbGwodGhpcywgaW5pdGlhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3dhdGNoID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBydW5VcGRhdGVzKHR5cGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyByZWFkLCB3cml0ZSwgZXZlbnRzID0gW10gfSBvZiB0aGlzLiRvcHRpb25zLnVwZGF0ZSkge1xuICAgICAgICAgIGlmICghdHlwZXMuaGFzKCd1cGRhdGUnKSAmJiAhZXZlbnRzLnNvbWUoKHR5cGUpID0+IHR5cGVzLmhhcyh0eXBlKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgaWYgKHJlYWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlYWQuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLCB0eXBlcyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgaXNQbGFpbk9iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIGFzc2lnbih0aGlzLl9kYXRhLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3cml0ZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmYXN0ZG9tLndyaXRlKCgpID0+IHdyaXRlLmNhbGwodGhpcywgdGhpcy5fZGF0YSwgdHlwZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcnVuV2F0Y2hlcyhpbml0aWFsKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAkb3B0aW9uczogeyBjb21wdXRlZCB9IH0gPVxuICAgICAgICB0aGlzO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB7IC4uLnRoaXMuX2NvbXB1dGVkIH07XG4gICAgICAgIHRoaXMuX2NvbXB1dGVkID0ge307XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb25zdCB7IHdhdGNoLCBpbW1lZGlhdGUgfSA9IGNvbXB1dGVkW2tleV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIHdhdGNoICYmIChcbiAgICAgICAgICBpbml0aWFsICYmIGltbWVkaWF0ZSB8fFxuICAgICAgICAgIGhhc093bih2YWx1ZXMsIGtleSkgJiYgIWlzRXF1YWwodmFsdWVzW2tleV0sIHRoaXNba2V5XSkpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdhdGNoLmNhbGwodGhpcywgdGhpc1trZXldLCB2YWx1ZXNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhdGVBUEkgKFVJa2l0KSB7XG4gICAgICBsZXQgdWlkID0gMDtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuZGF0YSA9IG5vcm1hbGl6ZURhdGEob3B0aW9ucywgdGhpcy5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcblxuICAgICAgICB0aGlzLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucywgb3B0aW9ucywgdGhpcyk7XG4gICAgICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy4kcHJvcHMgPSB7fTtcblxuICAgICAgICB0aGlzLl91aWQgPSB1aWQrKztcbiAgICAgICAgdGhpcy5faW5pdERhdGEoKTtcbiAgICAgICAgdGhpcy5faW5pdE1ldGhvZHMoKTtcbiAgICAgICAgdGhpcy5faW5pdENvbXB1dGVkcygpO1xuICAgICAgICB0aGlzLl9jYWxsSG9vaygnY3JlYXRlZCcpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICAgICAgdGhpcy4kbW91bnQob3B0aW9ucy5lbCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5faW5pdERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSA9IHt9IH0gPSB0aGlzLiRvcHRpb25zO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICB0aGlzLiRwcm9wc1trZXldID0gdGhpc1trZXldID0gZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRNZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB7IG1ldGhvZHMgfSA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBtZXRob2RzW2tleV0uYmluZCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5faW5pdENvbXB1dGVkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgeyBjb21wdXRlZCB9ID0gdGhpcy4kb3B0aW9ucztcblxuICAgICAgICB0aGlzLl9jb21wdXRlZCA9IHt9O1xuXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZWdpc3RlckNvbXB1dGVkKHRoaXMsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICBsZXQga2V5O1xuXG4gICAgICAgIHByb3BzID0gcHJvcHMgfHwgZ2V0UHJvcHMkMSh0aGlzLiRvcHRpb25zLCB0aGlzLiRuYW1lKTtcblxuICAgICAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQocHJvcHNba2V5XSkpIHtcbiAgICAgICAgICAgIHRoaXMuJHByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGUgPSBbdGhpcy4kb3B0aW9ucy5jb21wdXRlZCwgdGhpcy4kb3B0aW9ucy5tZXRob2RzXTtcbiAgICAgICAgZm9yIChrZXkgaW4gdGhpcy4kcHJvcHMpIHtcbiAgICAgICAgICBpZiAoa2V5IGluIHByb3BzICYmIG5vdEluKGV4Y2x1ZGUsIGtleSkpIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHRoaXMuJHByb3BzW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuJG9wdGlvbnMuZXZlbnRzIHx8IFtdKSB7XG4gICAgICAgICAgaWYgKGhhc093bihldmVudCwgJ2hhbmRsZXInKSkge1xuICAgICAgICAgICAgcmVnaXN0ZXJFdmVudCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyRXZlbnQodGhpcywgZXZlbnRba2V5XSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS5fdW5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgodW5iaW5kKSA9PiB1bmJpbmQoKSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuX2luaXRPYnNlcnZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycyA9IFtpbml0UHJvcHNPYnNlcnZlcih0aGlzKV07XG5cbiAgICAgICAgaWYgKHRoaXMuJG9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoaW5pdENoaWxkTGlzdE9ic2VydmVyKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLnJlZ2lzdGVyT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLl9kaXNjb25uZWN0T2JzZXJ2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBvYnNlcnZlci5kaXNjb25uZWN0KCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcm9wcyQxKG9wdHMsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGRhdGEkMSA9IHt9O1xuICAgICAgY29uc3QgeyBhcmdzID0gW10sIHByb3BzID0ge30sIGVsIH0gPSBvcHRzO1xuXG4gICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHJldHVybiBkYXRhJDE7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgbGV0IHZhbHVlID0gZGF0YShlbCwgcHJvcCk7XG5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBwcm9wc1trZXldID09PSBCb29sZWFuICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiBjb2VyY2UkMShwcm9wc1trZXldLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHByb3AgPT09ICd0YXJnZXQnICYmICghdmFsdWUgfHwgc3RhcnRzV2l0aCh2YWx1ZSwgJ18nKSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEkMVtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMoZGF0YShlbCwgbmFtZSksIGFyZ3MpO1xuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICBpZiAocHJvcHNbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRhdGEkMVtwcm9wXSA9IGNvZXJjZSQxKHByb3BzW3Byb3BdLCBvcHRpb25zW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhJDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJDb21wdXRlZChjb21wb25lbnQsIGtleSwgY2IpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wb25lbnQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCB7IF9jb21wdXRlZCwgJHByb3BzLCAkZWwgfSA9IGNvbXBvbmVudDtcblxuICAgICAgICAgIGlmICghaGFzT3duKF9jb21wdXRlZCwga2V5KSkge1xuICAgICAgICAgICAgX2NvbXB1dGVkW2tleV0gPSAoY2IuZ2V0IHx8IGNiKS5jYWxsKGNvbXBvbmVudCwgJHByb3BzLCAkZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfY29tcHV0ZWRba2V5XTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB7IF9jb21wdXRlZCB9ID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgX2NvbXB1dGVkW2tleV0gPSBjYi5zZXQgPyBjYi5zZXQuY2FsbChjb21wb25lbnQsIHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKF9jb21wdXRlZFtrZXldKSkge1xuICAgICAgICAgICAgZGVsZXRlIF9jb21wdXRlZFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9KTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnQoY29tcG9uZW50LCBldmVudCwga2V5KSB7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50ID0geyBuYW1lOiBrZXksIGhhbmRsZXI6IGV2ZW50IH07XG4gICAgICB9XG5cbiAgICAgIGxldCB7IG5hbWUsIGVsLCBoYW5kbGVyLCBjYXB0dXJlLCBwYXNzaXZlLCBkZWxlZ2F0ZSwgZmlsdGVyLCBzZWxmIH0gPSBldmVudDtcbiAgICAgIGVsID0gaXNGdW5jdGlvbihlbCkgPyBlbC5jYWxsKGNvbXBvbmVudCkgOiBlbCB8fCBjb21wb25lbnQuJGVsO1xuXG4gICAgICBpZiAoaXNBcnJheShlbCkpIHtcbiAgICAgICAgZWwuZm9yRWFjaCgoZWwpID0+IHJlZ2lzdGVyRXZlbnQoY29tcG9uZW50LCB7IC4uLmV2ZW50LCBlbCB9LCBrZXkpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsIHx8IGZpbHRlciAmJiAhZmlsdGVyLmNhbGwoY29tcG9uZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudC5fZXZlbnRzLnB1c2goXG4gICAgICBvbihcbiAgICAgIGVsLFxuICAgICAgbmFtZSxcbiAgICAgIGRlbGVnYXRlID8gaXNTdHJpbmcoZGVsZWdhdGUpID8gZGVsZWdhdGUgOiBkZWxlZ2F0ZS5jYWxsKGNvbXBvbmVudCkgOiBudWxsLFxuICAgICAgaXNTdHJpbmcoaGFuZGxlcikgPyBjb21wb25lbnRbaGFuZGxlcl0gOiBoYW5kbGVyLmJpbmQoY29tcG9uZW50KSxcbiAgICAgIHsgcGFzc2l2ZSwgY2FwdHVyZSwgc2VsZiB9KSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vdEluKG9wdGlvbnMsIGtleSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoKGFycikgPT4gIWFyciB8fCAhaGFzT3duKGFyciwga2V5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29lcmNlJDEodHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlID09PSBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiB0b0Jvb2xlYW4odmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgIHJldHVybiB0b0xpc3QodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZSA/IHR5cGUodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9MaXN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgP1xuICAgICAgdmFsdWUgOlxuICAgICAgaXNTdHJpbmcodmFsdWUpID9cbiAgICAgIHZhbHVlLlxuICAgICAgc3BsaXQoLywoPyFbXihdKlxcKSkvKS5cbiAgICAgIG1hcCgodmFsdWUpID0+IGlzTnVtZXJpYyh2YWx1ZSkgPyB0b051bWJlcih2YWx1ZSkgOiB0b0Jvb2xlYW4odmFsdWUudHJpbSgpKSkgOlxuICAgICAgW3ZhbHVlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVEYXRhKF9yZWYsIF9yZWYyKSB7bGV0IHsgZGF0YSA9IHt9IH0gPSBfcmVmO2xldCB7IGFyZ3MgPSBbXSwgcHJvcHMgPSB7fSB9ID0gX3JlZjI7XG4gICAgICBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhID0gZGF0YS5zbGljZSgwLCBhcmdzLmxlbmd0aCkucmVkdWNlKChkYXRhLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGFzc2lnbihkYXRhLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFbYXJnc1tpbmRleF1dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzW2tleV0pIHtcbiAgICAgICAgICBkYXRhW2tleV0gPSBjb2VyY2UkMShwcm9wc1trZXldLCBkYXRhW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRDaGlsZExpc3RPYnNlcnZlcihjb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IHsgZWwgfSA9IGNvbXBvbmVudC4kb3B0aW9ucztcblxuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiBjb21wb25lbnQuJGVtaXQoKSk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGVsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSB9KTtcblxuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdFByb3BzT2JzZXJ2ZXIoY29tcG9uZW50KSB7XG4gICAgICBjb25zdCB7ICRuYW1lLCAkb3B0aW9ucywgJHByb3BzIH0gPSBjb21wb25lbnQ7XG4gICAgICBjb25zdCB7IGF0dHJzLCBwcm9wcywgZWwgfSA9ICRvcHRpb25zO1xuXG4gICAgICBpZiAoIXByb3BzIHx8IGF0dHJzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBpc0FycmF5KGF0dHJzKSA/IGF0dHJzIDogT2JqZWN0LmtleXMocHJvcHMpO1xuICAgICAgY29uc3QgZmlsdGVyID0gYXR0cmlidXRlcy5tYXAoKGtleSkgPT4gaHlwaGVuYXRlKGtleSkpLmNvbmNhdCgkbmFtZSk7XG5cbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldFByb3BzJDEoJG9wdGlvbnMsICRuYW1lKTtcbiAgICAgICAgaWYgKFxuICAgICAgICByZWNvcmRzLnNvbWUoKF9yZWYzKSA9PiB7bGV0IHsgYXR0cmlidXRlTmFtZSB9ID0gX3JlZjM7XG4gICAgICAgICAgY29uc3QgcHJvcCA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZSgnZGF0YS0nLCAnJyk7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBwcm9wID09PSAkbmFtZSA/IGF0dHJpYnV0ZXMgOiBbY2FtZWxpemUocHJvcCksIGNhbWVsaXplKGF0dHJpYnV0ZU5hbWUpXSkuXG4gICAgICAgICAgc29tZSgocHJvcCkgPT4gIWlzVW5kZWZpbmVkKGRhdGFbcHJvcF0pICYmIGRhdGFbcHJvcF0gIT09ICRwcm9wc1twcm9wXSk7XG4gICAgICAgIH0pKVxuICAgICAgICB7XG4gICAgICAgICAgY29tcG9uZW50LiRyZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IGZpbHRlci5jb25jYXQoZmlsdGVyLm1hcCgoa2V5KSA9PiBcImRhdGEtXCIgKyBrZXkpKSB9KTtcblxuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFuY2VBUEkgKFVJa2l0KSB7XG4gICAgICBjb25zdCBEQVRBID0gVUlraXQuZGF0YTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLiRjcmVhdGUgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBlbGVtZW50LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBVSWtpdFtjb21wb25lbnRdKGVsZW1lbnQsIGRhdGEpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHRoaXMuJG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKCFlbFtEQVRBXSkge1xuICAgICAgICAgIGVsW0RBVEFdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxbREFUQV1bbmFtZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbFtEQVRBXVtuYW1lXSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy4kZWwgPSB0aGlzLiRvcHRpb25zLmVsID0gdGhpcy4kb3B0aW9ucy5lbCB8fCBlbDtcblxuICAgICAgICBpZiAod2l0aGluKGVsLCBkb2N1bWVudCkpIHtcbiAgICAgICAgICB0aGlzLl9jYWxsQ29ubmVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxEaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgdGhpcy5fY2FsbENvbm5lY3RlZCgpO1xuICAgICAgfTtcblxuICAgICAgVUlraXQucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZUVsKSB7aWYgKHJlbW92ZUVsID09PSB2b2lkIDApIHtyZW1vdmVFbCA9IGZhbHNlO31cbiAgICAgICAgY29uc3QgeyBlbCwgbmFtZSB9ID0gdGhpcy4kb3B0aW9ucztcblxuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICB0aGlzLl9jYWxsRGlzY29ubmVjdGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWxsSG9vaygnZGVzdHJveScpO1xuXG4gICAgICAgIGlmICghKGVsICE9IG51bGwgJiYgZWxbREFUQV0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGVsW0RBVEFdW25hbWVdO1xuXG4gICAgICAgIGlmICghaXNFbXB0eShlbFtEQVRBXSkpIHtcbiAgICAgICAgICBkZWxldGUgZWxbREFUQV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVtb3ZlRWwpIHtcbiAgICAgICAgICByZW1vdmUkMSh0aGlzLiRlbCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX2NhbGxVcGRhdGUoZSk7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5wcm90b3R5cGUuJHVwZGF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBlKSB7aWYgKGVsZW1lbnQgPT09IHZvaWQgMCkge2VsZW1lbnQgPSB0aGlzLiRlbDt9XG4gICAgICAgIFVJa2l0LnVwZGF0ZShlbGVtZW50LCBlKTtcbiAgICAgIH07XG5cbiAgICAgIFVJa2l0LnByb3RvdHlwZS4kZ2V0Q29tcG9uZW50ID0gVUlraXQuZ2V0Q29tcG9uZW50O1xuXG4gICAgICBjb25zdCBjb21wb25lbnROYW1lID0gbWVtb2l6ZSgobmFtZSkgPT4gVUlraXQucHJlZml4ICsgaHlwaGVuYXRlKG5hbWUpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFVJa2l0LnByb3RvdHlwZSwge1xuICAgICAgICAkY29udGFpbmVyOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFVJa2l0LCAnY29udGFpbmVyJyksXG5cbiAgICAgICAgJG5hbWU6IHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50TmFtZSh0aGlzLiRvcHRpb25zLm5hbWUpO1xuICAgICAgICAgIH0gfSB9KTtcblxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcG9uZW50QVBJIChVSWtpdCkge1xuICAgICAgY29uc3QgREFUQSA9IFVJa2l0LmRhdGE7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB7fTtcblxuICAgICAgVUlraXQuY29tcG9uZW50ID0gZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaWQgPSBoeXBoZW5hdGUobmFtZSk7XG5cbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKGlkKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChjb21wb25lbnRzW25hbWVdKSkge1xuICAgICAgICAgICAgY29tcG9uZW50c1tuYW1lXSA9IFVJa2l0LmV4dGVuZChjb21wb25lbnRzW25hbWVdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50c1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIFVJa2l0W25hbWVdID0gZnVuY3Rpb24gKGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBVSWtpdC5jb21wb25lbnQobmFtZSk7XG5cbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCA/XG4gICAgICAgICAgbmV3IGNvbXBvbmVudCh7IGRhdGE6IGlzUGxhaW5PYmplY3QoZWxlbWVudCkgPyBlbGVtZW50IDogWy4uLmFyZ3VtZW50c10gfSkgOlxuICAgICAgICAgIGVsZW1lbnQgP1xuICAgICAgICAgICQkKGVsZW1lbnQpLm1hcChpbml0KVswXSA6XG4gICAgICAgICAgaW5pdCgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaW5pdChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IFVJa2l0LmdldENvbXBvbmVudChlbGVtZW50LCBuYW1lKTtcblxuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb21wb25lbnQoeyBlbDogZWxlbWVudCwgZGF0YSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb3B0ID0gaXNQbGFpbk9iamVjdChvcHRpb25zKSA/IHsgLi4ub3B0aW9ucyB9IDogb3B0aW9ucy5vcHRpb25zO1xuXG4gICAgICAgIG9wdC5uYW1lID0gbmFtZTtcblxuICAgICAgICBvcHQuaW5zdGFsbCA9PSBudWxsID8gdm9pZCAwIDogb3B0Lmluc3RhbGwoVUlraXQsIG9wdCwgbmFtZSk7XG5cbiAgICAgICAgaWYgKFVJa2l0Ll9pbml0aWFsaXplZCAmJiAhb3B0LmZ1bmN0aW9uYWwpIHtcbiAgICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4gVUlraXRbbmFtZV0oXCJbdWstXCIgKyBpZCArIFwiXSxbZGF0YS11ay1cIiArIGlkICsgXCJdXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRzW25hbWVdID0gaXNQbGFpbk9iamVjdChvcHRpb25zKSA/IG9wdCA6IG9wdGlvbnM7XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5nZXRDb21wb25lbnRzID0gKGVsZW1lbnQpID0+IChlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50W0RBVEFdKSB8fCB7fTtcbiAgICAgIFVJa2l0LmdldENvbXBvbmVudCA9IChlbGVtZW50LCBuYW1lKSA9PiBVSWtpdC5nZXRDb21wb25lbnRzKGVsZW1lbnQpW25hbWVdO1xuXG4gICAgICBVSWtpdC5jb25uZWN0ID0gKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKG5vZGVbREFUQV0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZVtEQVRBXSkge1xuICAgICAgICAgICAgbm9kZVtEQVRBXVtuYW1lXS5fY2FsbENvbm5lY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIG5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGF0dHJpYnV0ZS5uYW1lKTtcblxuICAgICAgICAgIGlmIChuYW1lICYmIG5hbWUgaW4gY29tcG9uZW50cykge1xuICAgICAgICAgICAgVUlraXRbbmFtZV0obm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBVSWtpdC5kaXNjb25uZWN0ID0gKG5vZGUpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG5vZGVbREFUQV0pIHtcbiAgICAgICAgICBub2RlW0RBVEFdW25hbWVdLl9jYWxsRGlzY29ubmVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0Q29tcG9uZW50TmFtZSA9IG1lbW9pemUoKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgcmV0dXJuIHN0YXJ0c1dpdGgoYXR0cmlidXRlLCAndWstJykgfHwgc3RhcnRzV2l0aChhdHRyaWJ1dGUsICdkYXRhLXVrLScpID9cbiAgICAgIGNhbWVsaXplKGF0dHJpYnV0ZS5yZXBsYWNlKCdkYXRhLXVrLScsICcnKS5yZXBsYWNlKCd1ay0nLCAnJykpIDpcbiAgICAgIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgVUlraXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgVUlraXQudXRpbCA9IHV0aWw7XG4gICAgVUlraXQuZGF0YSA9ICdfX3Vpa2l0X18nO1xuICAgIFVJa2l0LnByZWZpeCA9ICd1ay0nO1xuICAgIFVJa2l0Lm9wdGlvbnMgPSB7fTtcbiAgICBVSWtpdC52ZXJzaW9uID0gJzMuMTQuMSc7XG5cbiAgICBnbG9iYWxBUEkoVUlraXQpO1xuICAgIGhvb2tzQVBJKFVJa2l0KTtcbiAgICBzdGF0ZUFQSShVSWtpdCk7XG4gICAgY29tcG9uZW50QVBJKFVJa2l0KTtcbiAgICBpbnN0YW5jZUFQSShVSWtpdCk7XG5cbiAgICBmdW5jdGlvbiBib290IChVSWtpdCkge1xuICAgICAgY29uc3QgeyBjb25uZWN0LCBkaXNjb25uZWN0IH0gPSBVSWtpdDtcblxuICAgICAgaWYgKCFpbkJyb3dzZXIgfHwgIXdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmFzdGRvbS5yZWFkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICBhcHBseShkb2N1bWVudC5ib2R5LCBjb25uZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKChyZWNvcmRzKSA9PiByZWNvcmRzLmZvckVhY2goYXBwbHlDaGlsZExpc3RNdXRhdGlvbikpLm9ic2VydmUoXG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgIHN1YnRyZWU6IHRydWUgfSk7XG5cblxuXG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKChyZWNvcmRzKSA9PiByZWNvcmRzLmZvckVhY2goYXBwbHlBdHRyaWJ1dGVNdXRhdGlvbikpLm9ic2VydmUoXG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICB7XG4gICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICBzdWJ0cmVlOiB0cnVlIH0pO1xuXG5cblxuICAgICAgICBVSWtpdC5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFwcGx5Q2hpbGRMaXN0TXV0YXRpb24oX3JlZikge2xldCB7IGFkZGVkTm9kZXMsIHJlbW92ZWROb2RlcyB9ID0gX3JlZjtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICAgICAgICBhcHBseShub2RlLCBjb25uZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiByZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgICBhcHBseShub2RlLCBkaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhcHBseUF0dHJpYnV0ZU11dGF0aW9uKF9yZWYyKSB7dmFyIF9VSWtpdCRnZXRDb21wb25lbnQ7bGV0IHsgdGFyZ2V0LCBhdHRyaWJ1dGVOYW1lIH0gPSBfcmVmMjtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoYXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgaWYgKCFuYW1lIHx8ICEobmFtZSBpbiBVSWtpdCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzQXR0cih0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgVUlraXRbbmFtZV0odGFyZ2V0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAoX1VJa2l0JGdldENvbXBvbmVudCA9IFVJa2l0LmdldENvbXBvbmVudCh0YXJnZXQsIG5hbWUpKSA9PSBudWxsID8gdm9pZCAwIDogX1VJa2l0JGdldENvbXBvbmVudC4kZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBDbGFzcyA9IHtcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgIWhhc0NsYXNzKHRoaXMuJGVsLCB0aGlzLiRuYW1lKSAmJiBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy4kbmFtZSk7XG4gICAgICB9IH07XG5cbiAgICB2YXIgTGF6eWxvYWQgPSB7XG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGxhenlsb2FkKG9ic2VydmVUYXJnZXRzLCB0YXJnZXRzKSB7aWYgKG9ic2VydmVUYXJnZXRzID09PSB2b2lkIDApIHtvYnNlcnZlVGFyZ2V0cyA9IHRoaXMuJGVsO31pZiAodGFyZ2V0cyA9PT0gdm9pZCAwKSB7dGFyZ2V0cyA9IHRoaXMuJGVsO31cbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoXG4gICAgICAgICAgb2JzZXJ2ZUludGVyc2VjdGlvbihvYnNlcnZlVGFyZ2V0cywgKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRvTm9kZXMoaXNGdW5jdGlvbih0YXJnZXRzKSA/IHRhcmdldHMoKSA6IHRhcmdldHMpKSB7XG4gICAgICAgICAgICAgICQkKCdbbG9hZGluZz1cImxhenlcIl0nLCBlbCkuZm9yRWFjaCgoZWwpID0+IHJlbW92ZUF0dHIoZWwsICdsb2FkaW5nJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBlbnRyaWVzLlxuICAgICAgICAgICAgZmlsdGVyKChfcmVmKSA9PiB7bGV0IHsgaXNJbnRlcnNlY3RpbmcgfSA9IF9yZWY7cmV0dXJuIGlzSW50ZXJzZWN0aW5nO30pLlxuICAgICAgICAgICAgbWFwKChfcmVmMikgPT4ge2xldCB7IHRhcmdldCB9ID0gX3JlZjI7cmV0dXJuIHRhcmdldDt9KSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcblxuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBUb2dnbGFibGUgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBjbHM6IEJvb2xlYW4sXG4gICAgICAgIGFuaW1hdGlvbjogJ2xpc3QnLFxuICAgICAgICBkdXJhdGlvbjogTnVtYmVyLFxuICAgICAgICB2ZWxvY2l0eTogTnVtYmVyLFxuICAgICAgICBvcmlnaW46IFN0cmluZyxcbiAgICAgICAgdHJhbnNpdGlvbjogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjbHM6IGZhbHNlLFxuICAgICAgICBhbmltYXRpb246IFtmYWxzZV0sXG4gICAgICAgIGR1cmF0aW9uOiAyMDAsXG4gICAgICAgIHZlbG9jaXR5OiAwLjIsXG4gICAgICAgIG9yaWdpbjogZmFsc2UsXG4gICAgICAgIHRyYW5zaXRpb246ICdlYXNlJyxcbiAgICAgICAgY2xzRW50ZXI6ICd1ay10b2dnbGFiZS1lbnRlcicsXG4gICAgICAgIGNsc0xlYXZlOiAndWstdG9nZ2xhYmUtbGVhdmUnLFxuXG4gICAgICAgIGluaXRQcm9wczoge1xuICAgICAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgICAgICBoZWlnaHQ6ICcnLFxuICAgICAgICAgIHBhZGRpbmdUb3A6ICcnLFxuICAgICAgICAgIHBhZGRpbmdCb3R0b206ICcnLFxuICAgICAgICAgIG1hcmdpblRvcDogJycsXG4gICAgICAgICAgbWFyZ2luQm90dG9tOiAnJyxcbiAgICAgICAgICBib3hTaGFkb3c6ICcnIH0sXG5cblxuICAgICAgICBoaWRlUHJvcHM6IHtcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIHBhZGRpbmdUb3A6IDAsXG4gICAgICAgICAgcGFkZGluZ0JvdHRvbTogMCxcbiAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgbWFyZ2luQm90dG9tOiAwLFxuICAgICAgICAgIGJveFNoYWRvdzogJ25vbmUnIH0gfSxcblxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGhhc0FuaW1hdGlvbihfcmVmKSB7bGV0IHsgYW5pbWF0aW9uIH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAhIWFuaW1hdGlvblswXTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNUcmFuc2l0aW9uKF9yZWYyKSB7bGV0IHsgYW5pbWF0aW9uIH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBbmltYXRpb24gJiYgYW5pbWF0aW9uWzBdID09PSB0cnVlO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGVFbGVtZW50KHRhcmdldHMsIHRvZ2dsZSwgYW5pbWF0ZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICB0b05vZGVzKHRhcmdldHMpLm1hcCgoZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNob3cgPSBpc0Jvb2xlYW4odG9nZ2xlKSA/IHRvZ2dsZSA6ICF0aGlzLmlzVG9nZ2xlZChlbCk7XG5cbiAgICAgICAgICAgIGlmICghdHJpZ2dlcihlbCwgXCJiZWZvcmVcIiArIChzaG93ID8gJ3Nob3cnIDogJ2hpZGUnKSwgW3RoaXNdKSkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IChcbiAgICAgICAgICAgIGlzRnVuY3Rpb24oYW5pbWF0ZSkgP1xuICAgICAgICAgICAgYW5pbWF0ZSA6XG4gICAgICAgICAgICBhbmltYXRlID09PSBmYWxzZSB8fCAhdGhpcy5oYXNBbmltYXRpb24gP1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlIDpcbiAgICAgICAgICAgIHRoaXMuaGFzVHJhbnNpdGlvbiA/XG4gICAgICAgICAgICB0b2dnbGVIZWlnaHQodGhpcykgOlxuICAgICAgICAgICAgdG9nZ2xlQW5pbWF0aW9uKHRoaXMpKShcbiAgICAgICAgICAgIGVsLCBzaG93KTtcblxuICAgICAgICAgICAgY29uc3QgY2xzID0gc2hvdyA/IHRoaXMuY2xzRW50ZXIgOiB0aGlzLmNsc0xlYXZlO1xuXG4gICAgICAgICAgICBhZGRDbGFzcyhlbCwgY2xzKTtcblxuICAgICAgICAgICAgdHJpZ2dlcihlbCwgc2hvdyA/ICdzaG93JyA6ICdoaWRlJywgW3RoaXNdKTtcblxuICAgICAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG4gICAgICAgICAgICAgIHRyaWdnZXIoZWwsIHNob3cgPyAnc2hvd24nIDogJ2hpZGRlbicsIFt0aGlzXSk7XG4gICAgICAgICAgICAgIHRoaXMuJHVwZGF0ZShlbCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZSA/XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZG9uZSwgKCkgPT4ge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSkpLlxuICAgICAgICAgIHRoZW4ocmVzb2x2ZSwgbm9vcCkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNUb2dnbGVkKGVsKSB7aWYgKGVsID09PSB2b2lkIDApIHtlbCA9IHRoaXMuJGVsO31cbiAgICAgICAgICBbZWxdID0gdG9Ob2RlcyhlbCk7XG4gICAgICAgICAgcmV0dXJuIGhhc0NsYXNzKGVsLCB0aGlzLmNsc0VudGVyKSA/XG4gICAgICAgICAgdHJ1ZSA6XG4gICAgICAgICAgaGFzQ2xhc3MoZWwsIHRoaXMuY2xzTGVhdmUpID9cbiAgICAgICAgICBmYWxzZSA6XG4gICAgICAgICAgdGhpcy5jbHMgP1xuICAgICAgICAgIGhhc0NsYXNzKGVsLCB0aGlzLmNscy5zcGxpdCgnICcpWzBdKSA6XG4gICAgICAgICAgaXNWaXNpYmxlKGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdG9nZ2xlKGVsLCB0b2dnbGVkKSB7XG4gICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvZ2dsZWQgPSBCb29sZWFuKHRvZ2dsZWQpO1xuXG4gICAgICAgICAgbGV0IGNoYW5nZWQ7XG4gICAgICAgICAgaWYgKHRoaXMuY2xzKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gaW5jbHVkZXModGhpcy5jbHMsICcgJykgfHwgdG9nZ2xlZCAhPT0gaGFzQ2xhc3MoZWwsIHRoaXMuY2xzKTtcbiAgICAgICAgICAgIGNoYW5nZWQgJiYgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzLCBpbmNsdWRlcyh0aGlzLmNscywgJyAnKSA/IHVuZGVmaW5lZCA6IHRvZ2dsZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdG9nZ2xlZCA9PT0gZWwuaGlkZGVuO1xuICAgICAgICAgICAgY2hhbmdlZCAmJiAoZWwuaGlkZGVuID0gIXRvZ2dsZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICQkKCdbYXV0b2ZvY3VzXScsIGVsKS5zb21lKChlbCkgPT4gaXNWaXNpYmxlKGVsKSA/IGVsLmZvY3VzKCkgfHwgdHJ1ZSA6IGVsLmJsdXIoKSk7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ3RvZ2dsZWQnLCBbdG9nZ2xlZCwgdGhpc10pO1xuICAgICAgICAgICAgdGhpcy4kdXBkYXRlKGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZUhlaWdodChfcmVmMylcblxuXG5cblxuXG5cblxuICAgIHtsZXQgeyBpc1RvZ2dsZWQsIGR1cmF0aW9uLCB2ZWxvY2l0eSwgaW5pdFByb3BzLCBoaWRlUHJvcHMsIHRyYW5zaXRpb24sIF90b2dnbGUgfSA9IF9yZWYzO1xuICAgICAgcmV0dXJuIChlbCwgc2hvdykgPT4ge1xuICAgICAgICBjb25zdCBpblByb2dyZXNzID0gVHJhbnNpdGlvbi5pblByb2dyZXNzKGVsKTtcbiAgICAgICAgY29uc3QgaW5uZXIgPSBlbC5oYXNDaGlsZE5vZGVzKCkgP1xuICAgICAgICB0b0Zsb2F0KGNzcyhlbC5maXJzdEVsZW1lbnRDaGlsZCwgJ21hcmdpblRvcCcpKSArXG4gICAgICAgIHRvRmxvYXQoY3NzKGVsLmxhc3RFbGVtZW50Q2hpbGQsICdtYXJnaW5Cb3R0b20nKSkgOlxuICAgICAgICAwO1xuICAgICAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gaXNWaXNpYmxlKGVsKSA/IGhlaWdodChlbCkgKyAoaW5Qcm9ncmVzcyA/IDAgOiBpbm5lcikgOiAwO1xuXG4gICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKGVsKTtcblxuICAgICAgICBpZiAoIWlzVG9nZ2xlZChlbCkpIHtcbiAgICAgICAgICBfdG9nZ2xlKGVsLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlaWdodChlbCwgJycpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjaGlsZCBjb21wb25lbnRzIGZpcnN0XG4gICAgICAgIGZhc3Rkb20uZmx1c2goKTtcblxuICAgICAgICBjb25zdCBlbmRIZWlnaHQgPSBoZWlnaHQoZWwpICsgKGluUHJvZ3Jlc3MgPyAwIDogaW5uZXIpO1xuICAgICAgICBkdXJhdGlvbiA9IHZlbG9jaXR5ICogZWwub2Zmc2V0SGVpZ2h0ICsgZHVyYXRpb247XG5cbiAgICAgICAgaGVpZ2h0KGVsLCBjdXJyZW50SGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICBzaG93ID9cbiAgICAgICAgVHJhbnNpdGlvbi5zdGFydChcbiAgICAgICAgZWwsXG4gICAgICAgIHsgLi4uaW5pdFByb3BzLCBvdmVyZmxvdzogJ2hpZGRlbicsIGhlaWdodDogZW5kSGVpZ2h0IH0sXG4gICAgICAgIE1hdGgucm91bmQoZHVyYXRpb24gKiAoMSAtIGN1cnJlbnRIZWlnaHQgLyBlbmRIZWlnaHQpKSxcbiAgICAgICAgdHJhbnNpdGlvbikgOlxuXG4gICAgICAgIFRyYW5zaXRpb24uc3RhcnQoXG4gICAgICAgIGVsLFxuICAgICAgICBoaWRlUHJvcHMsXG4gICAgICAgIE1hdGgucm91bmQoZHVyYXRpb24gKiAoY3VycmVudEhlaWdodCAvIGVuZEhlaWdodCkpLFxuICAgICAgICB0cmFuc2l0aW9uKS5cbiAgICAgICAgdGhlbigoKSA9PiBfdG9nZ2xlKGVsLCBmYWxzZSkpKS5cbiAgICAgICAgdGhlbigoKSA9PiBjc3MoZWwsIGluaXRQcm9wcykpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVBbmltYXRpb24oY21wKSB7XG4gICAgICByZXR1cm4gKGVsLCBzaG93KSA9PiB7XG4gICAgICAgIEFuaW1hdGlvbi5jYW5jZWwoZWwpO1xuXG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBkdXJhdGlvbiwgX3RvZ2dsZSB9ID0gY21wO1xuXG4gICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgX3RvZ2dsZShlbCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIEFuaW1hdGlvbi5pbihlbCwgYW5pbWF0aW9uWzBdLCBkdXJhdGlvbiwgY21wLm9yaWdpbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uLm91dChlbCwgYW5pbWF0aW9uWzFdIHx8IGFuaW1hdGlvblswXSwgZHVyYXRpb24sIGNtcC5vcmlnaW4pLnRoZW4oKCkgPT5cbiAgICAgICAgX3RvZ2dsZShlbCwgZmFsc2UpKTtcblxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgQWNjb3JkaW9uID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIExhenlsb2FkLCBUb2dnbGFibGVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXRzOiBTdHJpbmcsXG4gICAgICAgIGFjdGl2ZTogbnVsbCxcbiAgICAgICAgY29sbGFwc2libGU6IEJvb2xlYW4sXG4gICAgICAgIG11bHRpcGxlOiBCb29sZWFuLFxuICAgICAgICB0b2dnbGU6IFN0cmluZyxcbiAgICAgICAgY29udGVudDogU3RyaW5nLFxuICAgICAgICBvZmZzZXQ6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0czogJz4gKicsXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvbjogW3RydWVdLFxuICAgICAgICBjb2xsYXBzaWJsZTogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgICBjbHNPcGVuOiAndWstb3BlbicsXG4gICAgICAgIHRvZ2dsZTogJz4gLnVrLWFjY29yZGlvbi10aXRsZScsXG4gICAgICAgIGNvbnRlbnQ6ICc+IC51ay1hY2NvcmRpb24tY29udGVudCcsXG4gICAgICAgIG9mZnNldDogMCB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgZ2V0KF9yZWYsICRlbCkge2xldCB7IHRhcmdldHMgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gJCQodGFyZ2V0cywgJGVsKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goaXRlbXMsIHByZXYpIHtcbiAgICAgICAgICAgIGlmIChwcmV2IHx8IGhhc0NsYXNzKGl0ZW1zLCB0aGlzLmNsc09wZW4pKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYWN0aXZlID1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlICE9PSBmYWxzZSAmJiBpdGVtc1tOdW1iZXIodGhpcy5hY3RpdmUpXSB8fFxuICAgICAgICAgICAgIXRoaXMuY29sbGFwc2libGUgJiYgaXRlbXNbMF07XG5cbiAgICAgICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGUoYWN0aXZlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgdG9nZ2xlcyhfcmVmMikge2xldCB7IHRvZ2dsZSB9ID0gX3JlZjI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubWFwKChpdGVtKSA9PiAkKHRvZ2dsZSwgaXRlbSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRlbnRzOiB7XG4gICAgICAgICAgZ2V0KF9yZWYzKSB7bGV0IHsgY29udGVudCB9ID0gX3JlZjM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoKGl0ZW0pID0+ICQoY29udGVudCwgaXRlbSkpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChpdGVtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBpdGVtcykge1xuICAgICAgICAgICAgICBoaWRlKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgIWhhc0NsYXNzKFxuICAgICAgICAgICAgICB0aGlzLml0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uY29udGFpbnMoZWwpKSxcbiAgICAgICAgICAgICAgdGhpcy5jbHNPcGVuKSk7XG5cblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSB9LFxuXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmxhenlsb2FkKCk7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRzICsgXCIgXCIgKyB0aGlzLiRwcm9wcy50b2dnbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMudG9nZ2xlKGluZGV4KHRoaXMudG9nZ2xlcywgZS5jdXJyZW50KSk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHRvZ2dsZShpdGVtLCBhbmltYXRlKSB7XG4gICAgICAgICAgbGV0IGl0ZW1zID0gW3RoaXMuaXRlbXNbZ2V0SW5kZXgoaXRlbSwgdGhpcy5pdGVtcyldXTtcbiAgICAgICAgICBjb25zdCBhY3RpdmVJdGVtcyA9IGZpbHRlciQxKHRoaXMuaXRlbXMsIFwiLlwiICsgdGhpcy5jbHNPcGVuKTtcblxuICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSAmJiAhaW5jbHVkZXMoYWN0aXZlSXRlbXMsIGl0ZW1zWzBdKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoYWN0aXZlSXRlbXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAhdGhpcy5jb2xsYXBzaWJsZSAmJlxuICAgICAgICAgIGFjdGl2ZUl0ZW1zLmxlbmd0aCA8IDIgJiZcbiAgICAgICAgICAhZmlsdGVyJDEoaXRlbXMsIFwiOm5vdCguXCIgKyB0aGlzLmNsc09wZW4gKyBcIilcIikubGVuZ3RoKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUVsZW1lbnQoZWwsICFoYXNDbGFzcyhlbCwgdGhpcy5jbHNPcGVuKSwgYXN5bmMgKGVsLCBzaG93KSA9PiB7XG4gICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLmNsc09wZW4sIHNob3cpO1xuICAgICAgICAgICAgICBhdHRyKCQodGhpcy4kcHJvcHMudG9nZ2xlLCBlbCksICdhcmlhLWV4cGFuZGVkJywgc2hvdyk7XG5cbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9ICQoXCJcIiArIChlbC5fd3JhcHBlciA/ICc+ICogJyA6ICcnKSArIHRoaXMuY29udGVudCwgZWwpO1xuXG4gICAgICAgICAgICAgIGlmIChhbmltYXRlID09PSBmYWxzZSB8fCAhdGhpcy5oYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgaGlkZShjb250ZW50LCAhc2hvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFlbC5fd3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGVsLl93cmFwcGVyID0gd3JhcEFsbChjb250ZW50LCBcIjxkaXZcIiArIChzaG93ID8gJyBoaWRkZW4nIDogJycpICsgXCI+XCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGlkZShjb250ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgIGF3YWl0IHRvZ2dsZUhlaWdodCh0aGlzKShlbC5fd3JhcHBlciwgc2hvdyk7XG4gICAgICAgICAgICAgIGhpZGUoY29udGVudCwgIXNob3cpO1xuXG4gICAgICAgICAgICAgIGRlbGV0ZSBlbC5fd3JhcHBlcjtcbiAgICAgICAgICAgICAgdW53cmFwKGNvbnRlbnQpO1xuXG4gICAgICAgICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9nZ2xlID0gJCh0aGlzLiRwcm9wcy50b2dnbGUsIGVsKTtcbiAgICAgICAgICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc0luVmlldyh0b2dnbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3KHRvZ2dsZSwgeyBvZmZzZXQ6IHRoaXMub2Zmc2V0IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGhpZGUoZWwsIGhpZGUpIHtcbiAgICAgIGVsICYmIChlbC5oaWRkZW4gPSBoaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWxlcnQgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgVG9nZ2xhYmxlXSxcblxuICAgICAgYXJnczogJ2FuaW1hdGlvbicsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsb3NlOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGFuaW1hdGlvbjogW3RydWVdLFxuICAgICAgICBzZWxDbG9zZTogJy51ay1hbGVydC1jbG9zZScsXG4gICAgICAgIGR1cmF0aW9uOiAxNTAsXG4gICAgICAgIGhpZGVQcm9wczogeyBvcGFjaXR5OiAwLCAuLi5Ub2dnbGFibGUuZGF0YS5oaWRlUHJvcHMgfSB9LFxuXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbENsb3NlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCk7XG4gICAgICAgICAgdGhpcy4kZGVzdHJveSh0cnVlKTtcbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgVmlkZW8gPSB7XG4gICAgICBhcmdzOiAnYXV0b3BsYXknLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBhdXRvbXV0ZTogQm9vbGVhbixcbiAgICAgICAgYXV0b3BsYXk6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGF1dG9tdXRlOiBmYWxzZSxcbiAgICAgICAgYXV0b3BsYXk6IHRydWUgfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdGhpcy5hdXRvcGxheSA9PT0gJ2ludmlldyc7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5WaWV3ICYmICFoYXNBdHRyKHRoaXMuJGVsLCAncHJlbG9hZCcpKSB7XG4gICAgICAgICAgdGhpcy4kZWwucHJlbG9hZCA9ICdub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmF1dG9tdXRlKSB7XG4gICAgICAgICAgbXV0ZSh0aGlzLiRlbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIob2JzZXJ2ZUludGVyc2VjdGlvbih0aGlzLiRlbCwgKCkgPT4gdGhpcy4kZW1pdCgpLCB7fSwgZmFsc2UpKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICghaXNWaWRlbyh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmlzaWJsZTogaXNWaXNpYmxlKHRoaXMuJGVsKSAmJiBjc3ModGhpcy4kZWwsICd2aXNpYmlsaXR5JykgIT09ICdoaWRkZW4nLFxuICAgICAgICAgICAgaW5WaWV3OiB0aGlzLmluVmlldyAmJiBpc0luVmlldyh0aGlzLiRlbCkgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYpIHtsZXQgeyB2aXNpYmxlLCBpblZpZXcgfSA9IF9yZWY7XG4gICAgICAgICAgaWYgKCF2aXNpYmxlIHx8IHRoaXMuaW5WaWV3ICYmICFpblZpZXcpIHtcbiAgICAgICAgICAgIHBhdXNlKHRoaXMuJGVsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b3BsYXkgPT09IHRydWUgfHwgdGhpcy5pblZpZXcgJiYgaW5WaWV3KSB7XG4gICAgICAgICAgICBwbGF5KHRoaXMuJGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIFJlc2l6ZSA9IHtcbiAgICAgIGNvbm5lY3RlZCgpIHt2YXIgX3RoaXMkJG9wdGlvbnMkcmVzaXplO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyT2JzZXJ2ZXIoXG4gICAgICAgIG9ic2VydmVSZXNpemUoKChfdGhpcyQkb3B0aW9ucyRyZXNpemUgPSB0aGlzLiRvcHRpb25zLnJlc2l6ZVRhcmdldHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyQkb3B0aW9ucyRyZXNpemUuY2FsbCh0aGlzKSkgfHwgdGhpcy4kZWwsICgpID0+XG4gICAgICAgIHRoaXMuJGVtaXQoJ3Jlc2l6ZScpKSk7XG5cblxuICAgICAgfSB9O1xuXG4gICAgdmFyIGNvdmVyID0ge1xuICAgICAgbWl4aW5zOiBbUmVzaXplLCBWaWRlb10sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHdpZHRoOiBOdW1iZXIsXG4gICAgICAgIGhlaWdodDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBhdXRvbXV0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICAnbG9hZCBsb2FkZWRtZXRhZGF0YScoKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgncmVzaXplJyk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuJGVsLCBwYXJlbnQodGhpcy4kZWwpXTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGNvbnN0IHsgcmF0aW8sIGNvdmVyIH0gPSBEaW1lbnNpb25zO1xuICAgICAgICAgIGNvbnN0IHsgJGVsLCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuXG4gICAgICAgICAgbGV0IGRpbSA9IHsgd2lkdGgsIGhlaWdodCB9O1xuXG4gICAgICAgICAgaWYgKCFkaW0ud2lkdGggfHwgIWRpbS5oZWlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGludHJpbnNpYyA9IHtcbiAgICAgICAgICAgICAgd2lkdGg6ICRlbC5uYXR1cmFsV2lkdGggfHwgJGVsLnZpZGVvV2lkdGggfHwgJGVsLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6ICRlbC5uYXR1cmFsSGVpZ2h0IHx8ICRlbC52aWRlb0hlaWdodCB8fCAkZWwuY2xpZW50SGVpZ2h0IH07XG5cblxuICAgICAgICAgICAgaWYgKGRpbS53aWR0aCkge1xuICAgICAgICAgICAgICBkaW0gPSByYXRpbyhpbnRyaW5zaWMsICd3aWR0aCcsIGRpbS53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgICBkaW0gPSByYXRpbyhpbnRyaW5zaWMsICdoZWlnaHQnLCBkaW0uaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRpbSA9IGludHJpbnNpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IG9mZnNldEhlaWdodDogY292ZXJIZWlnaHQsIG9mZnNldFdpZHRoOiBjb3ZlcldpZHRoIH0gPVxuICAgICAgICAgIGdldFBvc2l0aW9uZWRQYXJlbnQoJGVsKSB8fCBwYXJlbnQoJGVsKTtcbiAgICAgICAgICBjb25zdCBjb3ZlckRpbSA9IGNvdmVyKGRpbSwge1xuICAgICAgICAgICAgd2lkdGg6IGNvdmVyV2lkdGggKyAoY292ZXJXaWR0aCAlIDIgPyAxIDogMCksXG4gICAgICAgICAgICBoZWlnaHQ6IGNvdmVySGVpZ2h0ICsgKGNvdmVySGVpZ2h0ICUgMiA/IDEgOiAwKSB9KTtcblxuXG4gICAgICAgICAgaWYgKCFjb3ZlckRpbS53aWR0aCB8fCAhY292ZXJEaW0uaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvdmVyRGltO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYpIHtsZXQgeyBoZWlnaHQsIHdpZHRoIH0gPSBfcmVmO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgeyBoZWlnaHQsIHdpZHRoIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFBhcmVudChlbCkge1xuICAgICAgd2hpbGUgKGVsID0gcGFyZW50KGVsKSkge1xuICAgICAgICBpZiAoY3NzKGVsLCAncG9zaXRpb24nKSAhPT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgQ29udGFpbmVyID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29udGFpbmVyOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjb250YWluZXI6IHRydWUgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBjb250YWluZXIoX3JlZikge2xldCB7IGNvbnRhaW5lciB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyID09PSB0cnVlICYmIHRoaXMuJGNvbnRhaW5lciB8fCBjb250YWluZXIgJiYgJChjb250YWluZXIpO1xuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBQb3NpdGlvbiA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHBvczogU3RyaW5nLFxuICAgICAgICBvZmZzZXQ6IG51bGwsXG4gICAgICAgIGZsaXA6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBvczogXCJib3R0b20tXCIgKyAoaXNSdGwgPyAncmlnaHQnIDogJ2xlZnQnKSxcbiAgICAgICAgZmxpcDogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgdmlld3BvcnRQYWRkaW5nOiAxMCB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLiRwcm9wcy5wb3Muc3BsaXQoJy0nKS5jb25jYXQoJ2NlbnRlcicpLnNsaWNlKDAsIDIpO1xuICAgICAgICB0aGlzLmF4aXMgPSBpbmNsdWRlcyhbJ3RvcCcsICdib3R0b20nXSwgdGhpcy5wb3NbMF0pID8gJ3knIDogJ3gnO1xuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBwb3NpdGlvbkF0KGVsZW1lbnQsIHRhcmdldCwgYm91bmRhcnkpIHtcbiAgICAgICAgICBjb25zdCBbZGlyLCBhbGlnbl0gPSB0aGlzLnBvcztcblxuICAgICAgICAgIGxldCB7IG9mZnNldDogb2Zmc2V0JDEgfSA9IHRoaXM7XG4gICAgICAgICAgaWYgKCFpc051bWVyaWMob2Zmc2V0JDEpKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gJChvZmZzZXQkMSk7XG4gICAgICAgICAgICBvZmZzZXQkMSA9IG5vZGUgP1xuICAgICAgICAgICAgb2Zmc2V0KG5vZGUpW3RoaXMuYXhpcyA9PT0gJ3gnID8gJ2xlZnQnIDogJ3RvcCddIC1cbiAgICAgICAgICAgIG9mZnNldCh0YXJnZXQpW3RoaXMuYXhpcyA9PT0gJ3gnID8gJ3JpZ2h0JyA6ICdib3R0b20nXSA6XG4gICAgICAgICAgICAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQkMSA9IHRvUHgob2Zmc2V0JDEpICsgdG9QeChnZXRDc3NWYXIoJ3Bvc2l0aW9uLW9mZnNldCcsIGVsZW1lbnQpKTtcbiAgICAgICAgICBvZmZzZXQkMSA9IFtpbmNsdWRlcyhbJ2xlZnQnLCAndG9wJ10sIGRpcikgPyAtb2Zmc2V0JDEgOiArb2Zmc2V0JDEsIDBdO1xuXG4gICAgICAgICAgY29uc3QgYXR0YWNoID0ge1xuICAgICAgICAgICAgZWxlbWVudDogW2ZsaXBQb3NpdGlvbihkaXIpLCBhbGlnbl0sXG4gICAgICAgICAgICB0YXJnZXQ6IFtkaXIsIGFsaWduXSB9O1xuXG5cbiAgICAgICAgICBpZiAodGhpcy5heGlzID09PSAneScpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBhdHRhY2gpIHtcbiAgICAgICAgICAgICAgYXR0YWNoW3Byb3BdID0gYXR0YWNoW3Byb3BdLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCQxID0gb2Zmc2V0JDEucmV2ZXJzZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvc2l0aW9uQXQoZWxlbWVudCwgdGFyZ2V0LCB7XG4gICAgICAgICAgICBhdHRhY2gsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCQxLFxuICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICB2aWV3cG9ydFBhZGRpbmc6IHRoaXMuYm91bmRhcnlBbGlnbiA/IDAgOiB0aGlzLnZpZXdwb3J0UGFkZGluZyxcbiAgICAgICAgICAgIGZsaXA6IHRoaXMuZmxpcCB9KTtcblxuICAgICAgICB9IH0gfTtcblxuICAgIGxldCBhY3RpdmUkMTtcblxuICAgIHZhciBkcm9wID0ge1xuICAgICAgbWl4aW5zOiBbQ29udGFpbmVyLCBMYXp5bG9hZCwgUG9zaXRpb24sIFRvZ2dsYWJsZV0sXG5cbiAgICAgIGFyZ3M6ICdwb3MnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtb2RlOiAnbGlzdCcsXG4gICAgICAgIHRvZ2dsZTogQm9vbGVhbixcbiAgICAgICAgYm91bmRhcnk6IEJvb2xlYW4sXG4gICAgICAgIGJvdW5kYXJ5QWxpZ246IEJvb2xlYW4sXG4gICAgICAgIGRlbGF5U2hvdzogTnVtYmVyLFxuICAgICAgICBkZWxheUhpZGU6IE51bWJlcixcbiAgICAgICAgZGlzcGxheTogU3RyaW5nLFxuICAgICAgICBjbHNEcm9wOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1vZGU6IFsnY2xpY2snLCAnaG92ZXInXSxcbiAgICAgICAgdG9nZ2xlOiAnLSAqJyxcbiAgICAgICAgYm91bmRhcnk6IHRydWUsXG4gICAgICAgIGJvdW5kYXJ5QWxpZ246IGZhbHNlLFxuICAgICAgICBkZWxheVNob3c6IDAsXG4gICAgICAgIGRlbGF5SGlkZTogODAwLFxuICAgICAgICBkaXNwbGF5OiBudWxsLFxuICAgICAgICBjbHNEcm9wOiBmYWxzZSxcbiAgICAgICAgYW5pbWF0aW9uOiBbJ3VrLWFuaW1hdGlvbi1mYWRlJ10sXG4gICAgICAgIGNsczogJ3VrLW9wZW4nLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlIH0sXG5cblxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy50cmFja2VyID0gbmV3IE1vdXNlVHJhY2tlcigpO1xuICAgICAgfSxcblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbHNEcm9wID0gdGhpcy4kcHJvcHMuY2xzRHJvcCB8fCBcInVrLVwiICsgdGhpcy4kb3B0aW9ucy5uYW1lO1xuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcm9wKTtcblxuICAgICAgICBpZiAodGhpcy50b2dnbGUgJiYgIXRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLiRjcmVhdGUoJ3RvZ2dsZScsIHF1ZXJ5KHRoaXMudG9nZ2xlLCB0aGlzLiRlbCksIHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy4kZWwsXG4gICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUgfSkuXG4gICAgICAgICAgJGVsO1xuICAgICAgICAgIGF0dHIodGhpcy50YXJnZXQsICdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5sYXp5bG9hZCh0aGlzLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgIGFjdGl2ZSQxID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiLlwiICsgdGhpcy5jbHNEcm9wICsgXCItY2xvc2VcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gJ2FbaHJlZl49XCIjXCJdJztcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF9yZWYpIHtsZXQgeyBkZWZhdWx0UHJldmVudGVkLCBjdXJyZW50OiB7IGhhc2ggfSB9ID0gX3JlZjtcbiAgICAgICAgICBpZiAoIWRlZmF1bHRQcmV2ZW50ZWQgJiYgaGFzaCAmJiAhd2l0aGluKGhhc2gsIHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdiZWZvcmVzY3JvbGwnLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKGUsIHRvZ2dsZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3codG9nZ2xlID09IG51bGwgPyB2b2lkIDAgOiB0b2dnbGUuJGVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG9nZ2xlc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKGUsIHRvZ2dsZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNob3codG9nZ2xlID09IG51bGwgPyB2b2lkIDAgOiB0b2dnbGUuJGVsKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvZ2dsZWhpZGUnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmICghbWF0Y2hlcyh0aGlzLiRlbCwgJzpmb2N1cyw6aG92ZXInKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyRW50ZXIgKyBcIiBmb2N1c2luXCIsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdob3ZlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICghaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogcG9pbnRlckxlYXZlICsgXCIgZm9jdXNvdXRcIixcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ2hvdmVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKCFpc1RvdWNoKGUpICYmIGUucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG9nZ2xlZCcsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKGUsIHRvZ2dsZWQpIHtcbiAgICAgICAgICBpZiAoIXRvZ2dsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG4gICAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2hvdycsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGFjdGl2ZSQxID0gdGhpcztcblxuICAgICAgICAgIHRoaXMudHJhY2tlci5pbml0KCk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgW1xuICAgICAgICAgIG9uKFxuICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgIHBvaW50ZXJEb3duLFxuICAgICAgICAgIChfcmVmMikgPT4ge2xldCB7IHRhcmdldCB9ID0gX3JlZjI7cmV0dXJuIChcbiAgICAgICAgICAgICAgIXdpdGhpbih0YXJnZXQsIHRoaXMuJGVsKSAmJlxuICAgICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgICAgcG9pbnRlclVwICsgXCIgXCIgKyBwb2ludGVyQ2FuY2VsICsgXCIgc2Nyb2xsXCIsXG4gICAgICAgICAgICAgIChfcmVmMykgPT4ge2xldCB7IGRlZmF1bHRQcmV2ZW50ZWQsIHR5cGUsIHRhcmdldDogbmV3VGFyZ2V0IH0gPSBfcmVmMztcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIWRlZmF1bHRQcmV2ZW50ZWQgJiZcbiAgICAgICAgICAgICAgICB0eXBlID09PSBwb2ludGVyVXAgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXQgPT09IG5ld1RhcmdldCAmJlxuICAgICAgICAgICAgICAgICEodGhpcy50YXJnZXQgJiYgd2l0aGluKHRhcmdldCwgdGhpcy50YXJnZXQpKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdHJ1ZSkpO30pLFxuXG5cblxuICAgICAgICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgLi4uKHRoaXMuZGlzcGxheSA9PT0gJ3N0YXRpYycgP1xuICAgICAgICAgIFtdIDpcbiAgICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHRoaXMuJGVtaXQoKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvbih3aW5kb3csICdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgICAgICAgIG9uKGRvY3VtZW50LCAnc2Nyb2xsJywgaGFuZGxlciwgdHJ1ZSksXG4gICAgICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IG9ic2VydmVSZXNpemUoXG4gICAgICAgICAgICAgIHNjcm9sbFBhcmVudHModGhpcy4kZWwpLFxuICAgICAgICAgICAgICBoYW5kbGVyKTtcblxuICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfSkoKV07XG5cbiAgICAgICAgICB9KSgpKV0pXG4gICAgICAgICAge1xuICAgICAgICAgICAgb25jZSh0aGlzLiRlbCwgJ2hpZGUnLCBoYW5kbGVyLCB7IHNlbGY6IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3JlaGlkZScsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGUnLFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjQpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY0O1xuICAgICAgICAgIGlmICh0aGlzLiRlbCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBhY3RpdmUkMSA9XG4gICAgICAgICAgICBhY3RpdmUkMSA9PT0gbnVsbCAmJiB3aXRoaW4odGFyZ2V0LCB0aGlzLiRlbCkgJiYgdGhpcy5pc1RvZ2dsZWQoKSA/XG4gICAgICAgICAgICB0aGlzIDpcbiAgICAgICAgICAgIGFjdGl2ZSQxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFjdGl2ZSQxID0gdGhpcy5pc0FjdGl2ZSgpID8gbnVsbCA6IGFjdGl2ZSQxO1xuICAgICAgICAgIHRoaXMudHJhY2tlci5jYW5jZWwoKTtcbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSAmJiAhaGFzQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRW50ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzaG93KHRhcmdldCwgZGVsYXkpIHtpZiAodGFyZ2V0ID09PSB2b2lkIDApIHt0YXJnZXQgPSB0aGlzLnRhcmdldDt9aWYgKGRlbGF5ID09PSB2b2lkIDApIHtkZWxheSA9IHRydWU7fVxuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpICYmIHRhcmdldCAmJiB0aGlzLnRhcmdldCAmJiB0YXJnZXQgIT09IHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3RpdmUkMSkge1xuICAgICAgICAgICAgaWYgKGRlbGF5ICYmIGFjdGl2ZSQxLmlzRGVsYXlpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaG93VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IG1hdGNoZXModGFyZ2V0LCAnOmhvdmVyJykgJiYgdGhpcy5zaG93KCksIDEwKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgICAgIHdoaWxlIChhY3RpdmUkMSAmJiBwcmV2ICE9PSBhY3RpdmUkMSAmJiAhd2l0aGluKHRoaXMuJGVsLCBhY3RpdmUkMS4kZWwpKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBhY3RpdmUkMTtcbiAgICAgICAgICAgICAgYWN0aXZlJDEuaGlkZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyICYmIHBhcmVudCh0aGlzLiRlbCkgIT09IHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmQodGhpcy5jb250YWluZXIsIHRoaXMuJGVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4gdGhpcy50b2dnbGVFbGVtZW50KHRoaXMuJGVsLCB0cnVlKSxcbiAgICAgICAgICBkZWxheSAmJiB0aGlzLmRlbGF5U2hvdyB8fCAwKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGUoZGVsYXkpIHtpZiAoZGVsYXkgPT09IHZvaWQgMCkge2RlbGF5ID0gdHJ1ZTt9XG4gICAgICAgICAgY29uc3QgaGlkZSA9ICgpID0+IHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcblxuICAgICAgICAgIHRoaXMuaXNEZWxheWluZyA9IGdldFBvc2l0aW9uZWRFbGVtZW50cyh0aGlzLiRlbCkuc29tZSgoZWwpID0+XG4gICAgICAgICAgdGhpcy50cmFja2VyLm1vdmVzVG8oZWwpKTtcblxuXG4gICAgICAgICAgaWYgKGRlbGF5ICYmIHRoaXMuaXNEZWxheWluZykge1xuICAgICAgICAgICAgdGhpcy5oaWRlVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuaGlkZSwgNTApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVsYXkgJiYgdGhpcy5kZWxheUhpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZVRpbWVyID0gc2V0VGltZW91dChoaWRlLCB0aGlzLmRlbGF5SGlkZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJUaW1lcnMoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVyKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO1xuICAgICAgICAgIHRoaXMuc2hvd1RpbWVyID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmhpZGVUaW1lciA9IG51bGw7XG4gICAgICAgICAgdGhpcy5pc0RlbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNBY3RpdmUoKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZSQxID09PSB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvc2l0aW9uKCkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0Ryb3AgKyBcIi1zdGFja1wiKTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcm9wICsgXCItYm91bmRhcnlcIiwgdGhpcy5ib3VuZGFyeUFsaWduKTtcblxuICAgICAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gcXVlcnkodGhpcy5ib3VuZGFyeSwgdGhpcy4kZWwpO1xuICAgICAgICAgIGNvbnN0IFtzY3JvbGxQYXJlbnRdID0gc2Nyb2xsUGFyZW50cyh0aGlzLiRlbCk7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsUGFyZW50T2Zmc2V0ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsUGFyZW50KTtcbiAgICAgICAgICBjb25zdCBib3VuZGFyeU9mZnNldCA9IGJvdW5kYXJ5ID8gb2Zmc2V0KGJvdW5kYXJ5KSA6IHNjcm9sbFBhcmVudE9mZnNldDtcblxuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ21heFdpZHRoJywgJycpO1xuICAgICAgICAgIGNvbnN0IG1heFdpZHRoID1cbiAgICAgICAgICBzY3JvbGxQYXJlbnRPZmZzZXQud2lkdGggLSAodGhpcy5ib3VuZGFyeUFsaWduID8gMCA6IDIgKiB0aGlzLnZpZXdwb3J0UGFkZGluZyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5wb3NbMV0gPT09ICdqdXN0aWZ5Jykge1xuICAgICAgICAgICAgY29uc3QgcHJvcCA9IHRoaXMuYXhpcyA9PT0gJ3knID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0KHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGFsaWduVG8gPSB0aGlzLmJvdW5kYXJ5QWxpZ24gPyBib3VuZGFyeU9mZnNldCA6IHRhcmdldE9mZnNldDtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgcHJvcCwgYWxpZ25Ub1twcm9wXSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLiRlbC5vZmZzZXRXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcm9wICsgXCItc3RhY2tcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAnbWF4V2lkdGgnLCBtYXhXaWR0aCk7XG5cbiAgICAgICAgICB0aGlzLnBvc2l0aW9uQXQoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgYm91bmRhcnkgJiYgdGhpcy5ib3VuZGFyeUFsaWduID8gYm91bmRhcnkgOiB0aGlzLnRhcmdldCxcbiAgICAgICAgICBib3VuZGFyeSk7XG5cbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25lZEVsZW1lbnRzKGVsKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGFwcGx5KGVsLCAoZWwpID0+IGNzcyhlbCwgJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnICYmIHJlc3VsdC5wdXNoKGVsKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBmb3JtQ3VzdG9tID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3NdLFxuXG4gICAgICBhcmdzOiAndGFyZ2V0JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGFyZ2V0OiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXQ6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaW5wdXQoXywgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuICQoc2VsSW5wdXQsICRlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRhcmdldChfcmVmLCAkZWwpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRhcmdldCAmJiAoXG4gICAgICAgICAgICB0YXJnZXQgPT09IHRydWUgJiYgcGFyZW50KHRoaXMuaW5wdXQpID09PSAkZWwgJiYgdGhpcy5pbnB1dC5uZXh0RWxlbWVudFNpYmxpbmcgfHxcbiAgICAgICAgICAgICQodGFyZ2V0LCAkZWwpKSk7XG5cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHVwZGF0ZSgpIHt2YXIgX2lucHV0JGZpbGVzO1xuICAgICAgICBjb25zdCB7IHRhcmdldCwgaW5wdXQgfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3B0aW9uO1xuICAgICAgICBjb25zdCBwcm9wID0gaXNJbnB1dCh0YXJnZXQpID8gJ3ZhbHVlJyA6ICd0ZXh0Q29udGVudCc7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKF9pbnB1dCRmaWxlcyA9IGlucHV0LmZpbGVzKSAhPSBudWxsICYmIF9pbnB1dCRmaWxlc1swXSA/XG4gICAgICAgIGlucHV0LmZpbGVzWzBdLm5hbWUgOlxuICAgICAgICBtYXRjaGVzKGlucHV0LCAnc2VsZWN0JykgJiYgKFxuICAgICAgICBvcHRpb24gPSAkJCgnb3B0aW9uJywgaW5wdXQpLmZpbHRlcigoZWwpID0+IGVsLnNlbGVjdGVkKVswXSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICA/IG9wdGlvbi50ZXh0Q29udGVudCA6XG4gICAgICAgIGlucHV0LnZhbHVlO1xuXG4gICAgICAgIGlmIChwcmV2ICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NoYW5nZScsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdyZXNldCcsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb3Nlc3QodGhpcy4kZWwsICdmb3JtJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgIH0gfV0gfTtcblxuICAgIHZhciBNYXJnaW4gPSB7XG4gICAgICBtaXhpbnM6IFtSZXNpemVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtYXJnaW46IFN0cmluZyxcbiAgICAgICAgZmlyc3RDb2x1bW46IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1hcmdpbjogJ3VrLW1hcmdpbi1zbWFsbC10b3AnLFxuICAgICAgICBmaXJzdENvbHVtbjogJ3VrLWZpcnN0LWNvbHVtbicgfSxcblxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuJGVsLCAuLi50b0FycmF5KHRoaXMuJGVsLmNoaWxkcmVuKV07XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJPYnNlcnZlcihcbiAgICAgICAgb2JzZXJ2ZU11dGF0aW9uKHRoaXMuJGVsLCAoKSA9PiB0aGlzLiRyZXNldCgpLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlIH0pKTtcblxuXG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBjb25zdCByb3dzID0gZ2V0Um93cyh0aGlzLiRlbC5jaGlsZHJlbik7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93cyxcbiAgICAgICAgICAgIGNvbHVtbnM6IGdldENvbHVtbnMocm93cykgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYpIHtsZXQgeyBjb2x1bW5zLCByb3dzIH0gPSBfcmVmO1xuICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHJvdykge1xuICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhjb2x1bW4sIHRoaXMubWFyZ2luLCByb3dzWzBdICE9PSByb3cpO1xuICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhjb2x1bW4sIHRoaXMuZmlyc3RDb2x1bW4sIGNvbHVtbnNbMF0uaW5jbHVkZXMoY29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0Um93cyhpdGVtcykge1xuICAgICAgcmV0dXJuIHNvcnRCeShpdGVtcywgJ3RvcCcsICdib3R0b20nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb2x1bW5zKHJvd3MpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBjb25zdCBzb3J0ZWQgPSBzb3J0Qnkocm93LCAnbGVmdCcsICdyaWdodCcpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNvcnRlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbHVtbnNbal0gPSBjb2x1bW5zW2pdID8gY29sdW1uc1tqXS5jb25jYXQoc29ydGVkW2pdKSA6IHNvcnRlZFtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNSdGwgPyBjb2x1bW5zLnJldmVyc2UoKSA6IGNvbHVtbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEJ5KGl0ZW1zLCBzdGFydFByb3AsIGVuZFByb3ApIHtcbiAgICAgIGNvbnN0IHNvcnRlZCA9IFtbXV07XG5cbiAgICAgIGZvciAoY29uc3QgZWwgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKCFpc1Zpc2libGUoZWwpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGltID0gZ2V0T2Zmc2V0KGVsKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gc29ydGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudCA9IHNvcnRlZFtpXTtcblxuICAgICAgICAgIGlmICghY3VycmVudFswXSkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBzdGFydERpbTtcbiAgICAgICAgICBpZiAoY3VycmVudFswXS5vZmZzZXRQYXJlbnQgPT09IGVsLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgc3RhcnREaW0gPSBnZXRPZmZzZXQoY3VycmVudFswXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpbSA9IGdldE9mZnNldChlbCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFydERpbSA9IGdldE9mZnNldChjdXJyZW50WzBdLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGltW3N0YXJ0UHJvcF0gPj0gc3RhcnREaW1bZW5kUHJvcF0gLSAxICYmIGRpbVtzdGFydFByb3BdICE9PSBzdGFydERpbVtzdGFydFByb3BdKSB7XG4gICAgICAgICAgICBzb3J0ZWQucHVzaChbZWxdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaW1bZW5kUHJvcF0gLSAxID4gc3RhcnREaW1bc3RhcnRQcm9wXSB8fCBkaW1bc3RhcnRQcm9wXSA9PT0gc3RhcnREaW1bc3RhcnRQcm9wXSkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBzb3J0ZWQudW5zaGlmdChbZWxdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc29ydGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9mZnNldChlbGVtZW50LCBvZmZzZXQpIHtpZiAob2Zmc2V0ID09PSB2b2lkIDApIHtvZmZzZXQgPSBmYWxzZTt9XG4gICAgICBsZXQgeyBvZmZzZXRUb3AsIG9mZnNldExlZnQsIG9mZnNldEhlaWdodCwgb2Zmc2V0V2lkdGggfSA9IGVsZW1lbnQ7XG5cbiAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgW29mZnNldFRvcCwgb2Zmc2V0TGVmdF0gPSBvZmZzZXRQb3NpdGlvbihlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgIGxlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgIGJvdHRvbTogb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0LFxuICAgICAgICByaWdodDogb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoIH07XG5cbiAgICB9XG5cbiAgICB2YXIgU2Nyb2xsID0ge1xuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICByZWdpc3RlclNjcm9sbExpc3RlbmVyKHRoaXMuX3VpZCwgKCkgPT4gdGhpcy4kZW1pdCgnc2Nyb2xsJykpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB1bnJlZ2lzdGVyU2Nyb2xsTGlzdGVuZXIodGhpcy5fdWlkKTtcbiAgICAgIH0gfTtcblxuXG4gICAgY29uc3Qgc2Nyb2xsTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCB1bmJpbmRTY3JvbGxMaXN0ZW5lcjtcbiAgICBmdW5jdGlvbiByZWdpc3RlclNjcm9sbExpc3RlbmVyKGlkLCBsaXN0ZW5lcikge1xuICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgPVxuICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgfHxcbiAgICAgIG9uKHdpbmRvdywgJ3Njcm9sbCcsICgpID0+IHNjcm9sbExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSksIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSB9KTtcblxuXG4gICAgICBzY3JvbGxMaXN0ZW5lcnMuc2V0KGlkLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5yZWdpc3RlclNjcm9sbExpc3RlbmVyKGlkKSB7XG4gICAgICBzY3JvbGxMaXN0ZW5lcnMuZGVsZXRlKGlkKTtcbiAgICAgIGlmICh1bmJpbmRTY3JvbGxMaXN0ZW5lciAmJiAhc2Nyb2xsTGlzdGVuZXJzLnNpemUpIHtcbiAgICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgICAgdW5iaW5kU2Nyb2xsTGlzdGVuZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBncmlkID0ge1xuICAgICAgZXh0ZW5kczogTWFyZ2luLFxuXG4gICAgICBtaXhpbnM6IFtDbGFzcywgU2Nyb2xsXSxcblxuICAgICAgbmFtZTogJ2dyaWQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBtYXNvbnJ5OiBCb29sZWFuLFxuICAgICAgICBwYXJhbGxheDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBtYXJnaW46ICd1ay1ncmlkLW1hcmdpbicsXG4gICAgICAgIGNsc1N0YWNrOiAndWstZ3JpZC1zdGFjaycsXG4gICAgICAgIG1hc29ucnk6IGZhbHNlLFxuICAgICAgICBwYXJhbGxheDogMCB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5tYXNvbnJ5ICYmIGFkZENsYXNzKHRoaXMuJGVsLCAndWstZmxleC10b3AgdWstZmxleC13cmFwLXRvcCcpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiBbXG4gICAgICB7XG4gICAgICAgIHdyaXRlKF9yZWYpIHtsZXQgeyBjb2x1bW5zIH0gPSBfcmVmO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc1N0YWNrLCBjb2x1bW5zLmxlbmd0aCA8IDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgcmVhZChkYXRhKSB7XG4gICAgICAgICAgbGV0IHsgY29sdW1ucywgcm93cyB9ID0gZGF0YTtcblxuICAgICAgICAgIC8vIEZpbHRlciBjb21wb25lbnQgbWFrZXMgZWxlbWVudHMgcG9zaXRpb25lZCBhYnNvbHV0ZVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAhY29sdW1ucy5sZW5ndGggfHxcbiAgICAgICAgICAhdGhpcy5tYXNvbnJ5ICYmICF0aGlzLnBhcmFsbGF4IHx8XG4gICAgICAgICAgcG9zaXRpb25lZEFic29sdXRlKHRoaXMuJGVsKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXRhLnRyYW5zbGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdHJhbnNsYXRlcyA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbih0aGlzLiRlbCk7XG4gICAgICAgICAgY29uc3QgY29sdW1uSGVpZ2h0cyA9IGdldENvbHVtbkhlaWdodHMoY29sdW1ucyk7XG4gICAgICAgICAgY29uc3QgbWFyZ2luID0gZ2V0TWFyZ2luVG9wKG5vZGVzLCB0aGlzLm1hcmdpbikgKiAocm93cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICBjb25zdCBlbEhlaWdodCA9IE1hdGgubWF4KC4uLmNvbHVtbkhlaWdodHMpICsgbWFyZ2luO1xuXG4gICAgICAgICAgaWYgKHRoaXMubWFzb25yeSkge1xuICAgICAgICAgICAgY29sdW1ucyA9IGNvbHVtbnMubWFwKChjb2x1bW4pID0+IHNvcnRCeSQxKGNvbHVtbiwgJ29mZnNldFRvcCcpKTtcbiAgICAgICAgICAgIHRyYW5zbGF0ZXMgPSBnZXRUcmFuc2xhdGVzKHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBwYWRkaW5nID0gTWF0aC5hYnModGhpcy5wYXJhbGxheCk7XG4gICAgICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgICAgIHBhZGRpbmcgPSBjb2x1bW5IZWlnaHRzLnJlZHVjZShcbiAgICAgICAgICAgIChuZXdQYWRkaW5nLCBoZ3QsIGkpID0+XG4gICAgICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAgIG5ld1BhZGRpbmcsXG4gICAgICAgICAgICBoZ3QgKyBtYXJnaW4gKyAoaSAlIDIgPyBwYWRkaW5nIDogcGFkZGluZyAvIDgpIC0gZWxIZWlnaHQpLFxuXG4gICAgICAgICAgICAwKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IHBhZGRpbmcsIGNvbHVtbnMsIHRyYW5zbGF0ZXMsIGhlaWdodDogdHJhbnNsYXRlcyA/IGVsSGVpZ2h0IDogJycgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmMikge2xldCB7IGhlaWdodCwgcGFkZGluZyB9ID0gX3JlZjI7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAncGFkZGluZ0JvdHRvbScsIHBhZGRpbmcgfHwgJycpO1xuICAgICAgICAgIGhlaWdodCAhPT0gZmFsc2UgJiYgY3NzKHRoaXMuJGVsLCAnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMucGFyYWxsYXggJiYgcG9zaXRpb25lZEFic29sdXRlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY3JvbGxlZDogdGhpcy5wYXJhbGxheCA/XG4gICAgICAgICAgICBzY3JvbGxlZE92ZXIodGhpcy4kZWwpICogTWF0aC5hYnModGhpcy5wYXJhbGxheCkgOlxuICAgICAgICAgICAgZmFsc2UgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYzKSB7bGV0IHsgY29sdW1ucywgc2Nyb2xsZWQsIHRyYW5zbGF0ZXMgfSA9IF9yZWYzO1xuICAgICAgICAgIGlmIChzY3JvbGxlZCA9PT0gZmFsc2UgJiYgIXRyYW5zbGF0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbiwgaSkgPT5cbiAgICAgICAgICBjb2x1bW4uZm9yRWFjaCgoZWwsIGopID0+XG4gICAgICAgICAgY3NzKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICAgICFzY3JvbGxlZCAmJiAhdHJhbnNsYXRlcyA/XG4gICAgICAgICAgJycgOiBcInRyYW5zbGF0ZVkoXCIgKyAoXG5cbiAgICAgICAgICAodHJhbnNsYXRlcyAmJiAtdHJhbnNsYXRlc1tpXVtqXSkgKyAoXG4gICAgICAgICAgc2Nyb2xsZWQgPyBpICUgMiA/IHNjcm9sbGVkIDogc2Nyb2xsZWQgLyA4IDogMCkpICsgXCJweClcIikpKTtcblxuXG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydzY3JvbGwnLCAncmVzaXplJ10gfV0gfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uZWRBYnNvbHV0ZShlbCkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuKGVsKS5zb21lKChlbCkgPT4gY3NzKGVsLCAncG9zaXRpb24nKSA9PT0gJ2Fic29sdXRlJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNsYXRlcyhyb3dzLCBjb2x1bW5zKSB7XG4gICAgICBjb25zdCByb3dIZWlnaHRzID0gcm93cy5tYXAoKHJvdykgPT4gTWF0aC5tYXgoLi4ucm93Lm1hcCgoZWwpID0+IGVsLm9mZnNldEhlaWdodCkpKTtcblxuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKChlbGVtZW50cykgPT4ge1xuICAgICAgICBsZXQgcHJldiA9IDA7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5tYXAoXG4gICAgICAgIChlbGVtZW50LCByb3cpID0+XG4gICAgICAgIHByZXYgKz0gcm93ID8gcm93SGVpZ2h0c1tyb3cgLSAxXSAtIGVsZW1lbnRzW3JvdyAtIDFdLm9mZnNldEhlaWdodCA6IDApO1xuXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXJnaW5Ub3Aobm9kZXMsIGNscykge1xuICAgICAgY29uc3QgW25vZGVdID0gbm9kZXMuZmlsdGVyKChlbCkgPT4gaGFzQ2xhc3MoZWwsIGNscykpO1xuXG4gICAgICByZXR1cm4gdG9GbG9hdChub2RlID8gY3NzKG5vZGUsICdtYXJnaW5Ub3AnKSA6IGNzcyhub2Rlc1swXSwgJ3BhZGRpbmdMZWZ0JykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbHVtbkhlaWdodHMoY29sdW1ucykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKChjb2x1bW4pID0+IGNvbHVtbi5yZWR1Y2UoKHN1bSwgZWwpID0+IHN1bSArIGVsLm9mZnNldEhlaWdodCwgMCkpO1xuICAgIH1cblxuICAgIHZhciBoZWlnaHRNYXRjaCA9IHtcbiAgICAgIG1peGluczogW1Jlc2l6ZV0sXG5cbiAgICAgIGFyZ3M6ICd0YXJnZXQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICAgICAgcm93OiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXQ6ICc+IConLFxuICAgICAgICByb3c6IHRydWUgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgIGdldChfcmVmLCAkZWwpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gJCQodGFyZ2V0LCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIHRoaXMuJHJlc2V0KCk7XG4gICAgICAgICAgfSB9IH0sXG5cblxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuJGVsLCAuLi50aGlzLmVsZW1lbnRzXTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3dzOiAodGhpcy5yb3cgPyBnZXRSb3dzKHRoaXMuZWxlbWVudHMpIDogW3RoaXMuZWxlbWVudHNdKS5tYXAobWF0Y2gkMSkgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYyKSB7bGV0IHsgcm93cyB9ID0gX3JlZjI7XG4gICAgICAgICAgZm9yIChjb25zdCB7IGhlaWdodHMsIGVsZW1lbnRzIH0gb2Ygcm93cykge1xuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWwsIGkpID0+IGNzcyhlbCwgJ21pbkhlaWdodCcsIGhlaWdodHNbaV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBtYXRjaCQxKGVsZW1lbnRzKSB7XG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4geyBoZWlnaHRzOiBbJyddLCBlbGVtZW50cyB9O1xuICAgICAgfVxuXG4gICAgICBjc3MoZWxlbWVudHMsICdtaW5IZWlnaHQnLCAnJyk7XG4gICAgICBsZXQgaGVpZ2h0cyA9IGVsZW1lbnRzLm1hcChnZXRIZWlnaHQpO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4uaGVpZ2h0cyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodHM6IGVsZW1lbnRzLm1hcCgoZWwsIGkpID0+IGhlaWdodHNbaV0udG9GaXhlZCgyKSA9PT0gbWF4LnRvRml4ZWQoMikgPyAnJyA6IG1heCksXG4gICAgICAgIGVsZW1lbnRzIH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIZWlnaHQoZWxlbWVudCkge1xuICAgICAgbGV0IHN0eWxlID0gZmFsc2U7XG4gICAgICBpZiAoIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICBzdHlsZSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgY3NzKGVsZW1lbnQsICdkaXNwbGF5JywgJ2Jsb2NrJywgJ2ltcG9ydGFudCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoZWlnaHQgPSBkaW1lbnNpb25zJDEoZWxlbWVudCkuaGVpZ2h0IC0gYm94TW9kZWxBZGp1c3QoZWxlbWVudCwgJ2hlaWdodCcsICdjb250ZW50LWJveCcpO1xuXG4gICAgICBpZiAoc3R5bGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGNzcyhlbGVtZW50LCAnZGlzcGxheScsIHN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgaGVpZ2h0Vmlld3BvcnQgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgUmVzaXplXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZXhwYW5kOiBCb29sZWFuLFxuICAgICAgICBvZmZzZXRUb3A6IEJvb2xlYW4sXG4gICAgICAgIG9mZnNldEJvdHRvbTogQm9vbGVhbixcbiAgICAgICAgbWluSGVpZ2h0OiBOdW1iZXIgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGV4cGFuZDogZmFsc2UsXG4gICAgICAgIG9mZnNldFRvcDogZmFsc2UsXG4gICAgICAgIG9mZnNldEJvdHRvbTogZmFsc2UsXG4gICAgICAgIG1pbkhlaWdodDogMCB9LFxuXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBvZmZzZXRUb3AgY2hhbmdlXG4gICAgICAgIHJldHVybiBbdGhpcy4kZWwsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudF07XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZChfcmVmKSB7bGV0IHsgbWluSGVpZ2h0OiBwcmV2IH0gPSBfcmVmO1xuICAgICAgICAgIGlmICghaXNWaXNpYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBtaW5IZWlnaHQgPSAnJztcbiAgICAgICAgICBjb25zdCBib3ggPSBib3hNb2RlbEFkanVzdCh0aGlzLiRlbCwgJ2hlaWdodCcsICdjb250ZW50LWJveCcpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZXhwYW5kKSB7XG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBNYXRoLm1heChcbiAgICAgICAgICAgIGhlaWdodCh3aW5kb3cpIC0gKFxuICAgICAgICAgICAgZGltZW5zaW9ucyQxKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuaGVpZ2h0IC1cbiAgICAgICAgICAgIGRpbWVuc2lvbnMkMSh0aGlzLiRlbCkuaGVpZ2h0KSAtXG4gICAgICAgICAgICBib3gsXG4gICAgICAgICAgICAwKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvbiBtb2JpbGUgZGV2aWNlcyAoaU9TIGFuZCBBbmRyb2lkKSB3aW5kb3cuaW5uZXJIZWlnaHQgIT09IDEwMHZoXG4gICAgICAgICAgICBtaW5IZWlnaHQgPSAnY2FsYygxMDB2aCc7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldFRvcCkge1xuICAgICAgICAgICAgICBjb25zdCB7IHRvcCB9ID0gb2Zmc2V0KHRoaXMuJGVsKTtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IHRvcCA+IDAgJiYgdG9wIDwgaGVpZ2h0KHdpbmRvdykgLyAyID8gXCIgLSBcIiArIHRvcCArIFwicHhcIiA6ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vZmZzZXRCb3R0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IFwiIC0gXCIgKyBkaW1lbnNpb25zJDEodGhpcy4kZWwubmV4dEVsZW1lbnRTaWJsaW5nKS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTnVtZXJpYyh0aGlzLm9mZnNldEJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IFwiIC0gXCIgKyB0aGlzLm9mZnNldEJvdHRvbSArIFwidmhcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vZmZzZXRCb3R0b20gJiYgZW5kc1dpdGgodGhpcy5vZmZzZXRCb3R0b20sICdweCcpKSB7XG4gICAgICAgICAgICAgIG1pbkhlaWdodCArPSBcIiAtIFwiICsgdG9GbG9hdCh0aGlzLm9mZnNldEJvdHRvbSkgKyBcInB4XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHRoaXMub2Zmc2V0Qm90dG9tKSkge1xuICAgICAgICAgICAgICBtaW5IZWlnaHQgKz0gXCIgLSBcIiArIGRpbWVuc2lvbnMkMShxdWVyeSh0aGlzLm9mZnNldEJvdHRvbSwgdGhpcy4kZWwpKS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkhlaWdodCArPSAoYm94ID8gXCIgLSBcIiArIGJveCArIFwicHhcIiA6ICcnKSArIFwiKVwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IG1pbkhlaWdodCwgcHJldiB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYyKSB7bGV0IHsgbWluSGVpZ2h0IH0gPSBfcmVmMjtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsIHsgbWluSGVpZ2h0IH0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMubWluSGVpZ2h0ICYmIHRvRmxvYXQoY3NzKHRoaXMuJGVsLCAnbWluSGVpZ2h0JykpIDwgdGhpcy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ21pbkhlaWdodCcsIHRoaXMubWluSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuICAgIHZhciBTVkcgPSB7XG4gICAgICBhcmdzOiAnc3JjJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaWQ6IEJvb2xlYW4sXG4gICAgICAgIGljb246IFN0cmluZyxcbiAgICAgICAgc3JjOiBTdHJpbmcsXG4gICAgICAgIHN0eWxlOiBTdHJpbmcsXG4gICAgICAgIHdpZHRoOiBOdW1iZXIsXG4gICAgICAgIGhlaWdodDogTnVtYmVyLFxuICAgICAgICByYXRpbzogTnVtYmVyLFxuICAgICAgICBjbGFzczogU3RyaW5nLFxuICAgICAgICBzdHJva2VBbmltYXRpb246IEJvb2xlYW4sXG4gICAgICAgIGZvY3VzYWJsZTogQm9vbGVhbiwgLy8gSUUgMTFcbiAgICAgICAgYXR0cmlidXRlczogJ2xpc3QnIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICByYXRpbzogMSxcbiAgICAgICAgaW5jbHVkZTogWydzdHlsZScsICdjbGFzcycsICdmb2N1c2FibGUnXSxcbiAgICAgICAgY2xhc3M6ICcnLFxuICAgICAgICBzdHJva2VBbmltYXRpb246IGZhbHNlIH0sXG5cblxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbGFzcyArPSAnIHVrLXN2Zyc7XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pY29uICYmIGluY2x1ZGVzKHRoaXMuc3JjLCAnIycpKSB7XG4gICAgICAgICAgW3RoaXMuc3JjLCB0aGlzLmljb25dID0gdGhpcy5zcmMuc3BsaXQoJyMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ZnID0gdGhpcy5nZXRTdmcoKS50aGVuKChlbCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2ZyA9IGluc2VydFNWRyhlbCwgdGhpcy4kZWwpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdmdFbCAmJiBzdmcgIT09IHRoaXMuc3ZnRWwpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlJDEodGhpcy5zdmdFbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlBdHRyaWJ1dGVzKHN2ZywgZWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdmdFbCA9IHN2ZztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG5vb3ApO1xuXG4gICAgICAgIGlmICh0aGlzLnN0cm9rZUFuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuc3ZnLnRoZW4oKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIGFwcGx5QW5pbWF0aW9uKGVsKTtcbiAgICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKGVsLCAocmVjb3Jkcywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhcHBseUFuaW1hdGlvbihlbCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN2Zy50aGVuKChzdmcpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzVm9pZEVsZW1lbnQodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmUkMShzdmcpO1xuICAgICAgICAgIHRoaXMuc3ZnRWwgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN2ZyA9IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGdldFN2ZygpIHtcbiAgICAgICAgICBpZiAoaXNUYWcodGhpcy4kZWwsICdpbWcnKSAmJiAhdGhpcy4kZWwuY29tcGxldGUgJiYgdGhpcy4kZWwubG9hZGluZyA9PT0gJ2xhenknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICAgICAgICBvbmNlKHRoaXMuJGVsLCAnbG9hZCcsICgpID0+IHJlc29sdmUodGhpcy5nZXRTdmcoKSkpKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwYXJzZVNWRyhhd2FpdCBsb2FkU1ZHKHRoaXMuc3JjKSwgdGhpcy5pY29uKSB8fCBQcm9taXNlLnJlamVjdCgnU1ZHIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhcHBseUF0dHJpYnV0ZXMoZWwsIHJlZikge1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB0aGlzLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5pbmNsdWRlLCBwcm9wKSAmJiBwcm9wIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgYXR0cihlbCwgcHJvcCwgdGhpc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBbcHJvcCwgdmFsdWVdID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0uc3BsaXQoJzonLCAyKTtcbiAgICAgICAgICAgIGF0dHIoZWwsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHJlbW92ZUF0dHIoZWwsICdpZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByb3BzID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbiAgICAgICAgICBsZXQgZGltZW5zaW9ucyA9IHByb3BzLm1hcCgocHJvcCkgPT4gdGhpc1twcm9wXSk7XG5cbiAgICAgICAgICBpZiAoIWRpbWVuc2lvbnMuc29tZSgodmFsKSA9PiB2YWwpKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gcHJvcHMubWFwKChwcm9wKSA9PiBhdHRyKHJlZiwgcHJvcCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHZpZXdCb3ggPSBhdHRyKHJlZiwgJ3ZpZXdCb3gnKTtcbiAgICAgICAgICBpZiAodmlld0JveCAmJiAhZGltZW5zaW9ucy5zb21lKCh2YWwpID0+IHZhbCkpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB2aWV3Qm94LnNwbGl0KCcgJykuc2xpY2UoMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGltZW5zaW9ucy5mb3JFYWNoKCh2YWwsIGkpID0+IGF0dHIoZWwsIHByb3BzW2ldLCB0b0Zsb2F0KHZhbCkgKiB0aGlzLnJhdGlvIHx8IG51bGwpKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgY29uc3QgbG9hZFNWRyA9IG1lbW9pemUoYXN5bmMgKHNyYykgPT4ge1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBpZiAoc3RhcnRzV2l0aChzcmMsICdkYXRhOicpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzcmMuc3BsaXQoJywnKVsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChhd2FpdCBmZXRjaChzcmMpKS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTVkcoc3ZnLCBpY29uKSB7dmFyIF9zdmc7XG4gICAgICBpZiAoaWNvbiAmJiBpbmNsdWRlcyhzdmcsICc8c3ltYm9sJykpIHtcbiAgICAgICAgc3ZnID0gcGFyc2VTeW1ib2xzKHN2ZywgaWNvbikgfHwgc3ZnO1xuICAgICAgfVxuXG4gICAgICBzdmcgPSAkKHN2Zy5zdWJzdHIoc3ZnLmluZGV4T2YoJzxzdmcnKSkpO1xuICAgICAgcmV0dXJuICgoX3N2ZyA9IHN2ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdmcuaGFzQ2hpbGROb2RlcygpKSAmJiBzdmc7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ltYm9sUmUgPSAvPHN5bWJvbChbXl0qP2lkPShbJ1wiXSkoLis/KVxcMlteXSo/PFxcLylzeW1ib2w+L2c7XG4gICAgY29uc3Qgc3ltYm9scyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTeW1ib2xzKHN2ZywgaWNvbikge1xuICAgICAgaWYgKCFzeW1ib2xzW3N2Z10pIHtcbiAgICAgICAgc3ltYm9sc1tzdmddID0ge307XG5cbiAgICAgICAgc3ltYm9sUmUubGFzdEluZGV4ID0gMDtcblxuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHN5bWJvbFJlLmV4ZWMoc3ZnKSkge1xuICAgICAgICAgIHN5bWJvbHNbc3ZnXVttYXRjaFszXV0gPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlwiICsgbWF0Y2hbMV0gKyBcInN2Zz5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3ltYm9sc1tzdmddW2ljb25dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uKGVsKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBnZXRNYXhQYXRoTGVuZ3RoKGVsKTtcblxuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS11ay1hbmltYXRpb24tc3Ryb2tlJywgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXhQYXRoTGVuZ3RoKGVsKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKFxuICAgICAgTWF0aC5tYXgoXG4gICAgICAwLFxuICAgICAgLi4uJCQoJ1tzdHJva2VdJywgZWwpLm1hcCgoc3Ryb2tlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHN0cm9rZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0pKSk7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydFNWRyhlbCwgcm9vdCkge1xuICAgICAgaWYgKGlzVm9pZEVsZW1lbnQocm9vdCkgfHwgaXNUYWcocm9vdCwgJ2NhbnZhcycpKSB7XG4gICAgICAgIHJvb3QuaGlkZGVuID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBuZXh0ID0gcm9vdC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIHJldHVybiBlcXVhbHMoZWwsIG5leHQpID8gbmV4dCA6IGFmdGVyKHJvb3QsIGVsKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGFzdCA9IHJvb3QubGFzdEVsZW1lbnRDaGlsZDtcbiAgICAgIHJldHVybiBlcXVhbHMoZWwsIGxhc3QpID8gbGFzdCA6IGFwcGVuZChyb290LCBlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1YWxzKGVsLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGlzVGFnKGVsLCAnc3ZnJykgJiYgaXNUYWcob3RoZXIsICdzdmcnKSAmJiBpbm5lckhUTUwoZWwpID09PSBpbm5lckhUTUwob3RoZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlubmVySFRNTChlbCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgIGVsLmlubmVySFRNTCB8fFxuICAgICAgbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhlbCkucmVwbGFjZSgvPHN2Zy4qPz4oLio/KTxcXC9zdmc+L2csICckMScpKS5cbiAgICAgIHJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgfVxuXG4gICAgdmFyIGNsb3NlSWNvbiA9IFwiPHN2ZyB3aWR0aD1cXFwiMTRcXFwiIGhlaWdodD1cXFwiMTRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAxNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiMVxcXCIgeTE9XFxcIjFcXFwiIHgyPVxcXCIxM1xcXCIgeTI9XFxcIjEzXFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjEzXFxcIiB5MT1cXFwiMVxcXCIgeDI9XFxcIjFcXFwiIHkyPVxcXCIxM1xcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIGNsb3NlTGFyZ2UgPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgeDE9XFxcIjFcXFwiIHkxPVxcXCIxXFxcIiB4Mj1cXFwiMTlcXFwiIHkyPVxcXCIxOVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIHgxPVxcXCIxOVxcXCIgeTE9XFxcIjFcXFwiIHgyPVxcXCIxXFxcIiB5Mj1cXFwiMTlcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBtYXJrZXIgPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeD1cXFwiOVxcXCIgeT1cXFwiNFxcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMTFcXFwiLz48cmVjdCB4PVxcXCI0XFxcIiB5PVxcXCI5XFxcIiB3aWR0aD1cXFwiMTFcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG5hdmJhclRvZ2dsZUljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHJlY3QgeT1cXFwiOVxcXCIgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjJcXFwiLz48cmVjdCB5PVxcXCIzXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjxyZWN0IHk9XFxcIjE1XFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMlxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG92ZXJsYXlJY29uID0gXCI8c3ZnIHdpZHRoPVxcXCI0MFxcXCIgaGVpZ2h0PVxcXCI0MFxcXCIgdmlld0JveD1cXFwiMCAwIDQwIDQwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxyZWN0IHg9XFxcIjE5XFxcIiB5PVxcXCIwXFxcIiB3aWR0aD1cXFwiMVxcXCIgaGVpZ2h0PVxcXCI0MFxcXCIvPjxyZWN0IHg9XFxcIjBcXFwiIHk9XFxcIjE5XFxcIiB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiMVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHBhZ2luYXRpb25OZXh0ID0gXCI8c3ZnIHdpZHRoPVxcXCI3XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiB2aWV3Qm94PVxcXCIwIDAgNyAxMlxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgcG9pbnRzPVxcXCIxIDEgNiA2IDEgMTFcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBwYWdpbmF0aW9uUHJldmlvdXMgPSBcIjxzdmcgd2lkdGg9XFxcIjdcXFwiIGhlaWdodD1cXFwiMTJcXFwiIHZpZXdCb3g9XFxcIjAgMCA3IDEyXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4yXFxcIiBwb2ludHM9XFxcIjYgMSAxIDYgNiAxMVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNlYXJjaEljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiOVxcXCIgY3k9XFxcIjlcXFwiIHI9XFxcIjdcXFwiLz48cGF0aCBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBkPVxcXCJNMTQsMTQgTDE4LDE4IEwxNCwxNCBaXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2VhcmNoTGFyZ2UgPSBcIjxzdmcgd2lkdGg9XFxcIjQwXFxcIiBoZWlnaHQ9XFxcIjQwXFxcIiB2aWV3Qm94PVxcXCIwIDAgNDAgNDBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS44XFxcIiBjeD1cXFwiMTcuNVxcXCIgY3k9XFxcIjE3LjVcXFwiIHI9XFxcIjE2LjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS44XFxcIiB4MT1cXFwiMzhcXFwiIHkxPVxcXCIzOVxcXCIgeDI9XFxcIjI5XFxcIiB5Mj1cXFwiMzBcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzZWFyY2hOYXZiYXIgPSBcIjxzdmcgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBjeD1cXFwiMTAuNVxcXCIgY3k9XFxcIjEwLjVcXFwiIHI9XFxcIjkuNVxcXCIvPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHgxPVxcXCIyM1xcXCIgeTE9XFxcIjIzXFxcIiB4Mj1cXFwiMTdcXFwiIHkyPVxcXCIxN1xcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNsaWRlbmF2TmV4dCA9IFwiPHN2ZyB3aWR0aD1cXFwiMTRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgcG9pbnRzPVxcXCIxLjIyNSwyMyAxMi43NzUsMTIgMS4yMjUsMSBcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzbGlkZW5hdk5leHRMYXJnZSA9IFwiPHN2ZyB3aWR0aD1cXFwiMjVcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNSA0MFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjJcXFwiIHBvaW50cz1cXFwiNC4wMDIsMzguNTQ3IDIyLjUyNywyMC4wMjQgNCwxLjUgXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2xpZGVuYXZQcmV2aW91cyA9IFwiPHN2ZyB3aWR0aD1cXFwiMTRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgcG9pbnRzPVxcXCIxMi43NzUsMSAxLjIyNSwxMiAxMi43NzUsMjMgXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2xpZGVuYXZQcmV2aW91c0xhcmdlID0gXCI8c3ZnIHdpZHRoPVxcXCIyNVxcXCIgaGVpZ2h0PVxcXCI0MFxcXCIgdmlld0JveD1cXFwiMCAwIDI1IDQwXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMlxcXCIgcG9pbnRzPVxcXCIyMC41MjcsMS41IDIsMjAuMDI0IDIwLjUyNSwzOC41NDcgXFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc3Bpbm5lciA9IFwiPHN2ZyB3aWR0aD1cXFwiMzBcXFwiIGhlaWdodD1cXFwiMzBcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMCAzMFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgY3g9XFxcIjE1XFxcIiBjeT1cXFwiMTVcXFwiIHI9XFxcIjE0XFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgdG90b3AgPSBcIjxzdmcgd2lkdGg9XFxcIjE4XFxcIiBoZWlnaHQ9XFxcIjEwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTggMTBcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIHBvaW50cz1cXFwiMSA5IDkgMSAxNyA5IFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgY29uc3QgaWNvbnMgPSB7XG4gICAgICBzcGlubmVyLFxuICAgICAgdG90b3AsXG4gICAgICBtYXJrZXIsXG4gICAgICAnY2xvc2UtaWNvbic6IGNsb3NlSWNvbixcbiAgICAgICdjbG9zZS1sYXJnZSc6IGNsb3NlTGFyZ2UsXG4gICAgICAnbmF2YmFyLXRvZ2dsZS1pY29uJzogbmF2YmFyVG9nZ2xlSWNvbixcbiAgICAgICdvdmVybGF5LWljb24nOiBvdmVybGF5SWNvbixcbiAgICAgICdwYWdpbmF0aW9uLW5leHQnOiBwYWdpbmF0aW9uTmV4dCxcbiAgICAgICdwYWdpbmF0aW9uLXByZXZpb3VzJzogcGFnaW5hdGlvblByZXZpb3VzLFxuICAgICAgJ3NlYXJjaC1pY29uJzogc2VhcmNoSWNvbixcbiAgICAgICdzZWFyY2gtbGFyZ2UnOiBzZWFyY2hMYXJnZSxcbiAgICAgICdzZWFyY2gtbmF2YmFyJzogc2VhcmNoTmF2YmFyLFxuICAgICAgJ3NsaWRlbmF2LW5leHQnOiBzbGlkZW5hdk5leHQsXG4gICAgICAnc2xpZGVuYXYtbmV4dC1sYXJnZSc6IHNsaWRlbmF2TmV4dExhcmdlLFxuICAgICAgJ3NsaWRlbmF2LXByZXZpb3VzJzogc2xpZGVuYXZQcmV2aW91cyxcbiAgICAgICdzbGlkZW5hdi1wcmV2aW91cy1sYXJnZSc6IHNsaWRlbmF2UHJldmlvdXNMYXJnZSB9O1xuXG5cbiAgICBjb25zdCBJY29uID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCQzLFxuXG4gICAgICBleHRlbmRzOiBTVkcsXG5cbiAgICAgIGFyZ3M6ICdpY29uJyxcblxuICAgICAgcHJvcHM6IFsnaWNvbiddLFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGluY2x1ZGU6IFsnZm9jdXNhYmxlJ10gfSxcblxuXG4gICAgICBpc0ljb246IHRydWUsXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCAndWstaWNvbicpO1xuICAgICAgfSxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBnZXRTdmcoKSB7XG4gICAgICAgICAgY29uc3QgaWNvbiA9IGdldEljb24odGhpcy5pY29uKTtcblxuICAgICAgICAgIGlmICghaWNvbikge1xuICAgICAgICAgICAgdGhyb3cgJ0ljb24gbm90IGZvdW5kLic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgIH0gfSB9O1xuXG4gICAgY29uc3QgSWNvbkNvbXBvbmVudCA9IHtcbiAgICAgIGFyZ3M6IGZhbHNlLFxuXG4gICAgICBleHRlbmRzOiBJY29uLFxuXG4gICAgICBkYXRhOiAodm0pID0+ICh7XG4gICAgICAgIGljb246IGh5cGhlbmF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zLm5hbWUpIH0pLFxuXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLiRuYW1lKTtcbiAgICAgIH0gfTtcblxuXG4gICAgY29uc3QgU2xpZGVuYXYgPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLXNsaWRlbmF2Jyk7XG4gICAgICAgIGNvbnN0IGljb24gPSB0aGlzLiRwcm9wcy5pY29uO1xuICAgICAgICB0aGlzLmljb24gPSBoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLXNsaWRlbmF2LWxhcmdlJykgPyBpY29uICsgXCItbGFyZ2VcIiA6IGljb247XG4gICAgICB9IH07XG5cblxuICAgIGNvbnN0IFNlYXJjaCA9IHtcbiAgICAgIGV4dGVuZHM6IEljb25Db21wb25lbnQsXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuaWNvbiA9XG4gICAgICAgIGhhc0NsYXNzKHRoaXMuJGVsLCAndWstc2VhcmNoLWljb24nKSAmJiBwYXJlbnRzKHRoaXMuJGVsLCAnLnVrLXNlYXJjaC1sYXJnZScpLmxlbmd0aCA/XG4gICAgICAgICdzZWFyY2gtbGFyZ2UnIDpcbiAgICAgICAgcGFyZW50cyh0aGlzLiRlbCwgJy51ay1zZWFyY2gtbmF2YmFyJykubGVuZ3RoID9cbiAgICAgICAgJ3NlYXJjaC1uYXZiYXInIDpcbiAgICAgICAgdGhpcy4kcHJvcHMuaWNvbjtcbiAgICAgIH0gfTtcblxuXG4gICAgY29uc3QgQ2xvc2UgPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLmljb24gPSBcImNsb3NlLVwiICsgKGhhc0NsYXNzKHRoaXMuJGVsLCAndWstY2xvc2UtbGFyZ2UnKSA/ICdsYXJnZScgOiAnaWNvbicpO1xuICAgICAgfSB9O1xuXG5cbiAgICBjb25zdCBTcGlubmVyID0ge1xuICAgICAgZXh0ZW5kczogSWNvbkNvbXBvbmVudCxcblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBnZXRTdmcoKSB7XG4gICAgICAgICAgY29uc3QgaWNvbiA9IGF3YWl0IEljb24ubWV0aG9kcy5nZXRTdmcuY2FsbCh0aGlzKTtcblxuICAgICAgICAgIGlmICh0aGlzLnJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICBjc3MoJCgnY2lyY2xlJywgaWNvbiksICdzdHJva2VXaWR0aCcsIDEgLyB0aGlzLnJhdGlvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaWNvbjtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgY29uc3QgcGFyc2VkID0ge307XG4gICAgZnVuY3Rpb24gaW5zdGFsbCQzKFVJa2l0KSB7XG4gICAgICBVSWtpdC5pY29uLmFkZCA9IChuYW1lLCBzdmcpID0+IHtcbiAgICAgICAgY29uc3QgYWRkZWQgPSBpc1N0cmluZyhuYW1lKSA/IHsgW25hbWVdOiBzdmcgfSA6IG5hbWU7XG4gICAgICAgIGVhY2goYWRkZWQsIChzdmcsIG5hbWUpID0+IHtcbiAgICAgICAgICBpY29uc1tuYW1lXSA9IHN2ZztcbiAgICAgICAgICBkZWxldGUgcGFyc2VkW25hbWVdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoVUlraXQuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgYXBwbHkoZG9jdW1lbnQuYm9keSwgKGVsKSA9PlxuICAgICAgICAgIGVhY2goVUlraXQuZ2V0Q29tcG9uZW50cyhlbCksIChjbXApID0+IHtcbiAgICAgICAgICAgIGNtcC4kb3B0aW9ucy5pc0ljb24gJiYgY21wLmljb24gaW4gYWRkZWQgJiYgY21wLiRyZXNldCgpO1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEljb24oaWNvbikge1xuICAgICAgaWYgKCFpY29uc1tpY29uXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJzZWRbaWNvbl0pIHtcbiAgICAgICAgcGFyc2VkW2ljb25dID0gJCgoaWNvbnNbYXBwbHlSdGwoaWNvbildIHx8IGljb25zW2ljb25dKS50cmltKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VkW2ljb25dLmNsb25lTm9kZSh0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVJ0bChpY29uKSB7XG4gICAgICByZXR1cm4gaXNSdGwgPyBzd2FwKHN3YXAoaWNvbiwgJ2xlZnQnLCAncmlnaHQnKSwgJ3ByZXZpb3VzJywgJ25leHQnKSA6IGljb247XG4gICAgfVxuXG4gICAgY29uc3QgbmF0aXZlTGF6eUxvYWQgPSBpbkJyb3dzZXIgJiYgJ2xvYWRpbmcnIGluIEhUTUxJbWFnZUVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgdmFyIGltZyA9IHtcbiAgICAgIGFyZ3M6ICdkYXRhU3JjJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZGF0YVNyYzogU3RyaW5nLFxuICAgICAgICBzb3VyY2VzOiBTdHJpbmcsXG4gICAgICAgIG9mZnNldFRvcDogU3RyaW5nLFxuICAgICAgICBvZmZzZXRMZWZ0OiBTdHJpbmcsXG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICBsb2FkaW5nOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRhdGFTcmM6ICcnLFxuICAgICAgICBzb3VyY2VzOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0VG9wOiAnNTB2aCcsXG4gICAgICAgIG9mZnNldExlZnQ6ICc1MHZ3JyxcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgbG9hZGluZzogJ2xhenknIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5sb2FkaW5nICE9PSAnbGF6eScpIHtcbiAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXQgPSBbdGhpcy4kZWwsIC4uLnF1ZXJ5QWxsKHRoaXMuJHByb3BzLnRhcmdldCwgdGhpcy4kZWwpXTtcblxuICAgICAgICBpZiAobmF0aXZlTGF6eUxvYWQgJiYgaXNJbWcodGhpcy4kZWwpKSB7XG4gICAgICAgICAgdGhpcy4kZWwubG9hZGluZyA9ICdsYXp5JztcbiAgICAgICAgICBzZXRTcmNBdHRycyh0aGlzLiRlbCk7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVuc3VyZVNyY0F0dHJpYnV0ZSh0aGlzLiRlbCk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvb3RNYXJnaW46IHRvUHgodGhpcy5vZmZzZXRUb3AsICdoZWlnaHQnKSArIFwicHggXCIgKyB0b1B4KFxuICAgICAgICAgIHRoaXMub2Zmc2V0TGVmdCxcbiAgICAgICAgICAnd2lkdGgnKSArIFwicHhcIiB9KSk7XG5cblxuXG5cbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEuaW1hZ2UpIHtcbiAgICAgICAgICB0aGlzLl9kYXRhLmltYWdlLm9ubG9hZCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGxvYWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2RhdGEuaW1hZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmltYWdlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGltYWdlID0gaXNJbWcodGhpcy4kZWwpID9cbiAgICAgICAgICB0aGlzLiRlbCA6XG4gICAgICAgICAgZ2V0SW1hZ2VGcm9tRWxlbWVudCh0aGlzLiRlbCwgdGhpcy5kYXRhU3JjLCB0aGlzLnNvdXJjZXMpO1xuXG4gICAgICAgICAgcmVtb3ZlQXR0cihpbWFnZSwgJ2xvYWRpbmcnKTtcbiAgICAgICAgICBzZXRTcmNBdHRycyh0aGlzLiRlbCwgaW1hZ2UuY3VycmVudFNyYyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gc2V0U3JjQXR0cnMoZWwsIHNyYykge1xuICAgICAgaWYgKGlzSW1nKGVsKSkge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gcGFyZW50KGVsKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBpc1BpY3R1cmUocGFyZW50Tm9kZSkgPyBjaGlsZHJlbihwYXJlbnROb2RlKSA6IFtlbF07XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiBzZXRTb3VyY2VQcm9wcyhlbCwgZWwpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9ICFpbmNsdWRlcyhlbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UsIHNyYyk7XG4gICAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgICBjc3MoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnLCBcInVybChcIiArIGVzY2FwZShzcmMpICsgXCIpXCIpO1xuICAgICAgICAgIHRyaWdnZXIoZWwsIGNyZWF0ZUV2ZW50KCdsb2FkJywgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNyY1Byb3BzID0gWydkYXRhLXNyYycsICdkYXRhLXNyY3NldCcsICdzaXplcyddO1xuICAgIGZ1bmN0aW9uIHNldFNvdXJjZVByb3BzKHNvdXJjZUVsLCB0YXJnZXRFbCkge1xuICAgICAgc3JjUHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGEoc291cmNlRWwsIHByb3ApO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBhdHRyKHRhcmdldEVsLCBwcm9wLnJlcGxhY2UoL14oZGF0YS0pKy8sICcnKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbWFnZUZyb21FbGVtZW50KGVsLCBzcmMsIHNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICB3cmFwSW5QaWN0dXJlKGltZywgc291cmNlcyk7XG4gICAgICBzZXRTb3VyY2VQcm9wcyhlbCwgaW1nKTtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHNldFNyY0F0dHJzKGVsLCBpbWcuY3VycmVudFNyYyk7XG4gICAgICB9O1xuICAgICAgYXR0cihpbWcsICdzcmMnLCBzcmMpO1xuICAgICAgcmV0dXJuIGltZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwSW5QaWN0dXJlKGltZywgc291cmNlcykge1xuICAgICAgc291cmNlcyA9IHBhcnNlU291cmNlcyhzb3VyY2VzKTtcblxuICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBpY3R1cmUgPSBmcmFnbWVudCgnPHBpY3R1cmU+Jyk7XG4gICAgICAgIGZvciAoY29uc3QgYXR0cnMgb2Ygc291cmNlcykge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGZyYWdtZW50KCc8c291cmNlPicpO1xuICAgICAgICAgIGF0dHIoc291cmNlLCBhdHRycyk7XG4gICAgICAgICAgYXBwZW5kKHBpY3R1cmUsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKHBpY3R1cmUsIGltZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTb3VyY2VzKHNvdXJjZXMpIHtcbiAgICAgIGlmICghc291cmNlcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydHNXaXRoKHNvdXJjZXMsICdbJykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzb3VyY2VzID0gSlNPTi5wYXJzZShzb3VyY2VzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlcyA9IHBhcnNlT3B0aW9ucyhzb3VyY2VzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0FycmF5KHNvdXJjZXMpKSB7XG4gICAgICAgIHNvdXJjZXMgPSBbc291cmNlc107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3VyY2VzLmZpbHRlcigoc291cmNlKSA9PiAhaXNFbXB0eShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbnN1cmVTcmNBdHRyaWJ1dGUoZWwpIHtcbiAgICAgIGlmIChpc0ltZyhlbCkgJiYgIWhhc0F0dHIoZWwsICdzcmMnKSkge1xuICAgICAgICBhdHRyKGVsLCAnc3JjJywgJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjwvc3ZnPicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUGljdHVyZShlbCkge1xuICAgICAgcmV0dXJuIGlzVGFnKGVsLCAncGljdHVyZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW1nKGVsKSB7XG4gICAgICByZXR1cm4gaXNUYWcoZWwsICdpbWcnKTtcbiAgICB9XG5cbiAgICB2YXIgTWVkaWEgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBtZWRpYTogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWVkaWE6IGZhbHNlIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBjb25zdCBtZWRpYSA9IHRvTWVkaWEodGhpcy5tZWRpYSk7XG4gICAgICAgIHRoaXMubWF0Y2hNZWRpYSA9IHRydWU7XG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgIHRoaXMubWVkaWFPYmogPSB3aW5kb3cubWF0Y2hNZWRpYShtZWRpYSk7XG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hNZWRpYSA9IHRoaXMubWVkaWFPYmoubWF0Y2hlcztcbiAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsIGNyZWF0ZUV2ZW50KCdtZWRpYWNoYW5nZScsIGZhbHNlLCB0cnVlLCBbdGhpcy5tZWRpYU9ial0pKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMub2ZmTWVkaWFPYmogPSBvbih0aGlzLm1lZGlhT2JqLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgncmVzaXplJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7dmFyIF90aGlzJG9mZk1lZGlhT2JqO1xuICAgICAgICAoX3RoaXMkb2ZmTWVkaWFPYmogPSB0aGlzLm9mZk1lZGlhT2JqKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb2ZmTWVkaWFPYmouY2FsbCh0aGlzKTtcbiAgICAgIH0gfTtcblxuXG4gICAgZnVuY3Rpb24gdG9NZWRpYSh2YWx1ZSkge1xuICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBpZiAoc3RhcnRzV2l0aCh2YWx1ZSwgJ0AnKSkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBcImJyZWFrcG9pbnQtXCIgKyB2YWx1ZS5zdWJzdHIoMSk7XG4gICAgICAgICAgdmFsdWUgPSB0b0Zsb2F0KGdldENzc1ZhcihuYW1lKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZSAmJiBpc051bWVyaWModmFsdWUpID8gXCIobWluLXdpZHRoOiBcIiArIHZhbHVlICsgXCJweClcIiA6ICcnO1xuICAgIH1cblxuICAgIHZhciBsZWFkZXIgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgTWVkaWEsIFJlc2l6ZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGZpbGw6IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZmlsbDogJycsXG4gICAgICAgIGNsc1dyYXBwZXI6ICd1ay1sZWFkZXItZmlsbCcsXG4gICAgICAgIGNsc0hpZGU6ICd1ay1sZWFkZXItaGlkZScsXG4gICAgICAgIGF0dHJGaWxsOiAnZGF0YS1maWxsJyB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGZpbGwoX3JlZikge2xldCB7IGZpbGwgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIGZpbGwgfHwgZ2V0Q3NzVmFyKCdsZWFkZXItZmlsbC1jb250ZW50Jyk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIFt0aGlzLndyYXBwZXJdID0gd3JhcElubmVyKHRoaXMuJGVsLCBcIjxzcGFuIGNsYXNzPVxcXCJcIiArIHRoaXMuY2xzV3JhcHBlciArIFwiXFxcIj5cIik7XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHVud3JhcCh0aGlzLndyYXBwZXIuY2hpbGROb2Rlcyk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgudHJ1bmModGhpcy4kZWwub2Zmc2V0V2lkdGggLyAyKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGZpbGw6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgIGhpZGU6ICF0aGlzLm1hdGNoTWVkaWEgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYyKSB7bGV0IHsgd2lkdGgsIGZpbGwsIGhpZGUgfSA9IF9yZWYyO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMud3JhcHBlciwgdGhpcy5jbHNIaWRlLCBoaWRlKTtcbiAgICAgICAgICBhdHRyKHRoaXMud3JhcHBlciwgdGhpcy5hdHRyRmlsbCwgbmV3IEFycmF5KHdpZHRoKS5qb2luKGZpbGwpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSB9O1xuXG4gICAgY29uc3QgYWN0aXZlID0gW107XG5cbiAgICB2YXIgTW9kYWwgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgQ29udGFpbmVyLCBUb2dnbGFibGVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBzZWxQYW5lbDogU3RyaW5nLFxuICAgICAgICBzZWxDbG9zZTogU3RyaW5nLFxuICAgICAgICBlc2NDbG9zZTogQm9vbGVhbixcbiAgICAgICAgYmdDbG9zZTogQm9vbGVhbixcbiAgICAgICAgc3RhY2s6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNsczogJ3VrLW9wZW4nLFxuICAgICAgICBlc2NDbG9zZTogdHJ1ZSxcbiAgICAgICAgYmdDbG9zZTogdHJ1ZSxcbiAgICAgICAgb3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgc3RhY2s6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgcGFuZWwoX3JlZiwgJGVsKSB7bGV0IHsgc2VsUGFuZWwgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICQoc2VsUGFuZWwsICRlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvbkVsZW1lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFuZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmdDbG9zZShfcmVmMikge2xldCB7IGJnQ2xvc2UgfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiBiZ0Nsb3NlICYmIHRoaXMucGFuZWw7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBiZWZvcmVEaXNjb25uZWN0KCkge1xuICAgICAgICBpZiAoaW5jbHVkZXMoYWN0aXZlLCB0aGlzKSkge1xuICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsQ2xvc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG9nZ2xlJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSA9PT0gaW5jbHVkZXMoYWN0aXZlLCB0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdiZWZvcmVzaG93JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChpbmNsdWRlcyhhY3RpdmUsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLnN0YWNrICYmIGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGFjdGl2ZS5tYXAoKG1vZGFsKSA9PiBtb2RhbC5oaWRlKCkpKS50aGVuKHRoaXMuc2hvdyk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3cnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBjb25zdCBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgIGlmICh3aWR0aCh3aW5kb3cpID4gZG9jRWwuY2xpZW50V2lkdGggJiYgdGhpcy5vdmVybGF5KSB7XG4gICAgICAgICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ292ZXJmbG93WScsICdzY3JvbGwnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGFjaykge1xuICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCAnekluZGV4JywgdG9GbG9hdChjc3ModGhpcy4kZWwsICd6SW5kZXgnKSkgKyBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRDbGFzcyhkb2NFbCwgdGhpcy5jbHNQYWdlKTtcblxuICAgICAgICAgIGlmICh0aGlzLmJnQ2xvc2UpIHtcbiAgICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICAgICdoaWRlJyxcbiAgICAgICAgICAgIG9uKGRvY3VtZW50LCBwb2ludGVyRG93biwgKF9yZWYzKSA9PiB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmMztcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBsYXN0KGFjdGl2ZSkgIT09IHRoaXMgfHxcbiAgICAgICAgICAgICAgdGhpcy5vdmVybGF5ICYmICF3aXRoaW4odGFyZ2V0LCB0aGlzLiRlbCkgfHxcbiAgICAgICAgICAgICAgd2l0aGluKHRhcmdldCwgdGhpcy5wYW5lbCkpXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgICAgcG9pbnRlclVwICsgXCIgXCIgKyBwb2ludGVyQ2FuY2VsICsgXCIgc2Nyb2xsXCIsXG4gICAgICAgICAgICAgIChfcmVmNCkgPT4ge2xldCB7IGRlZmF1bHRQcmV2ZW50ZWQsIHR5cGUsIHRhcmdldDogbmV3VGFyZ2V0IH0gPSBfcmVmNDtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIWRlZmF1bHRQcmV2ZW50ZWQgJiZcbiAgICAgICAgICAgICAgICB0eXBlID09PSBwb2ludGVyVXAgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXQgPT09IG5ld1RhcmdldClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRydWUpO1xuXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmVzY0Nsb3NlKSB7XG4gICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgICAnaGlkZScsXG4gICAgICAgICAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNyAmJiBsYXN0KGFjdGl2ZSkgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7IHNlbGY6IHRydWUgfSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93bicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmICghaXNGb2N1c2FibGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICBhdHRyKHRoaXMuJGVsLCAndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoISQoJzpmb2N1cycsIHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgdGhpcy4kZWwuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRkZW4nLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBpZiAoaW5jbHVkZXMoYWN0aXZlLCB0aGlzKSkge1xuICAgICAgICAgICAgYWN0aXZlLnNwbGljZShhY3RpdmUuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ292ZXJmbG93WScsICcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjc3ModGhpcy4kZWwsICd6SW5kZXgnLCAnJyk7XG5cbiAgICAgICAgICBpZiAoIWFjdGl2ZS5zb21lKChtb2RhbCkgPT4gbW9kYWwuY2xzUGFnZSA9PT0gdGhpcy5jbHNQYWdlKSkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmNsc1BhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdG9nZ2xlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzVG9nZ2xlZCgpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93KCkge1xuICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lciAmJiBwYXJlbnQodGhpcy4kZWwpICE9PSB0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgYXBwZW5kKHRoaXMuY29udGFpbmVyLCB0aGlzLiRlbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5zaG93KCkudGhlbihyZXNvbHZlKSkpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgdHJ1ZSwgYW5pbWF0ZSh0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2dnbGVFbGVtZW50KHRoaXMuJGVsLCBmYWxzZSwgYW5pbWF0ZSh0aGlzKSk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGFuaW1hdGUoX3JlZjUpIHtsZXQgeyB0cmFuc2l0aW9uRWxlbWVudCwgX3RvZ2dsZSB9ID0gX3JlZjU7XG4gICAgICByZXR1cm4gKGVsLCBzaG93KSA9PlxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgIG9uY2UoZWwsICdzaG93IGhpZGUnLCAoKSA9PiB7XG4gICAgICAgIGVsLl9yZWplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLl9yZWplY3QoKTtcbiAgICAgICAgZWwuX3JlamVjdCA9IHJlamVjdDtcblxuICAgICAgICBfdG9nZ2xlKGVsLCBzaG93KTtcblxuICAgICAgICBjb25zdCBvZmYgPSBvbmNlKFxuICAgICAgICB0cmFuc2l0aW9uRWxlbWVudCxcbiAgICAgICAgJ3RyYW5zaXRpb25zdGFydCcsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBvbmNlKHRyYW5zaXRpb25FbGVtZW50LCAndHJhbnNpdGlvbmVuZCB0cmFuc2l0aW9uY2FuY2VsJywgcmVzb2x2ZSwge1xuICAgICAgICAgICAgc2VsZjogdHJ1ZSB9KTtcblxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0sXG4gICAgICAgIHsgc2VsZjogdHJ1ZSB9KTtcblxuXG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgb2ZmKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCB0b01zKGNzcyh0cmFuc2l0aW9uRWxlbWVudCwgJ3RyYW5zaXRpb25EdXJhdGlvbicpKSk7XG4gICAgICB9KSkuXG4gICAgICB0aGVuKCgpID0+IGRlbGV0ZSBlbC5fcmVqZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b01zKHRpbWUpIHtcbiAgICAgIHJldHVybiB0aW1lID8gZW5kc1dpdGgodGltZSwgJ21zJykgPyB0b0Zsb2F0KHRpbWUpIDogdG9GbG9hdCh0aW1lKSAqIDEwMDAgOiAwO1xuICAgIH1cblxuICAgIHZhciBtb2RhbCA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwkMixcblxuICAgICAgbWl4aW5zOiBbTW9kYWxdLFxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNsc1BhZ2U6ICd1ay1tb2RhbC1wYWdlJyxcbiAgICAgICAgc2VsUGFuZWw6ICcudWstbW9kYWwtZGlhbG9nJyxcbiAgICAgICAgc2VsQ2xvc2U6XG4gICAgICAgICcudWstbW9kYWwtY2xvc2UsIC51ay1tb2RhbC1jbG9zZS1kZWZhdWx0LCAudWstbW9kYWwtY2xvc2Utb3V0c2lkZSwgLnVrLW1vZGFsLWNsb3NlLWZ1bGwnIH0sXG5cblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKGhhc0NsYXNzKHRoaXMucGFuZWwsICd1ay1tYXJnaW4tYXV0by12ZXJ0aWNhbCcpKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLWZsZXgnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCAnZGlzcGxheScsICdibG9jaycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhlaWdodCh0aGlzLiRlbCk7IC8vIGZvcmNlIHJlZmxvd1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZGVuJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgJ3VrLWZsZXgnKTtcbiAgICAgICAgfSB9XSB9O1xuXG5cblxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCQyKF9yZWYpIHtsZXQgeyBtb2RhbCB9ID0gX3JlZjtcbiAgICAgIG1vZGFsLmRpYWxvZyA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRpYWxvZyA9IG1vZGFsKFwiPGRpdiBjbGFzcz1cXFwidWstbW9kYWxcXFwiPiA8ZGl2IGNsYXNzPVxcXCJ1ay1tb2RhbC1kaWFsb2dcXFwiPlwiICtcblxuICAgICAgICBjb250ZW50ICsgXCI8L2Rpdj4gPC9kaXY+XCIsXG5cbiAgICAgICAgb3B0aW9ucyk7XG5cblxuICAgICAgICBkaWFsb2cuc2hvdygpO1xuXG4gICAgICAgIG9uKFxuICAgICAgICBkaWFsb2cuJGVsLFxuICAgICAgICAnaGlkZGVuJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIGRpYWxvZy4kZGVzdHJveSh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBzZWxmOiB0cnVlIH0pO1xuXG5cbiAgICAgICAgcmV0dXJuIGRpYWxvZztcbiAgICAgIH07XG5cbiAgICAgIG1vZGFsLmFsZXJ0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wZW5EaWFsb2coXG4gICAgICAgIChfcmVmMikgPT4ge2xldCB7IGxhYmVscyB9ID0gX3JlZjI7cmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwidWstbW9kYWwtYm9keVxcXCI+XCIgKyAoXG4gICAgICAgICAgaXNTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogaHRtbChtZXNzYWdlKSkgKyBcIjwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJ1ay1tb2RhbC1mb290ZXIgdWstdGV4dC1yaWdodFxcXCI+IDxidXR0b24gY2xhc3M9XFxcInVrLWJ1dHRvbiB1ay1idXR0b24tcHJpbWFyeSB1ay1tb2RhbC1jbG9zZVxcXCIgYXV0b2ZvY3VzPlwiICtcblxuXG5cbiAgICAgICAgICBsYWJlbHMub2sgKyBcIjwvYnV0dG9uPiA8L2Rpdj5cIjt9LFxuXG5cbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKGRlZmVycmVkKSA9PiBkZWZlcnJlZC5yZXNvbHZlKCkpO1xuXG4gICAgICB9O1xuXG4gICAgICBtb2RhbC5jb25maXJtID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wZW5EaWFsb2coXG4gICAgICAgIChfcmVmMykgPT4ge2xldCB7IGxhYmVscyB9ID0gX3JlZjM7cmV0dXJuIFwiPGZvcm0+IDxkaXYgY2xhc3M9XFxcInVrLW1vZGFsLWJvZHlcXFwiPlwiICsgKFxuICAgICAgICAgIGlzU3RyaW5nKG1lc3NhZ2UpID8gbWVzc2FnZSA6IGh0bWwobWVzc2FnZSkpICsgXCI8L2Rpdj4gPGRpdiBjbGFzcz1cXFwidWstbW9kYWwtZm9vdGVyIHVrLXRleHQtcmlnaHRcXFwiPiA8YnV0dG9uIGNsYXNzPVxcXCJ1ay1idXR0b24gdWstYnV0dG9uLWRlZmF1bHQgdWstbW9kYWwtY2xvc2VcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCI+XCIgK1xuXG5cbiAgICAgICAgICBsYWJlbHMuY2FuY2VsICsgXCI8L2J1dHRvbj4gPGJ1dHRvbiBjbGFzcz1cXFwidWstYnV0dG9uIHVrLWJ1dHRvbi1wcmltYXJ5XFxcIiBhdXRvZm9jdXM+XCIgK1xuXG4gICAgICAgICAgbGFiZWxzLm9rICsgXCI8L2J1dHRvbj4gPC9kaXY+IDwvZm9ybT5cIjt9LFxuXG5cbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKGRlZmVycmVkKSA9PiBkZWZlcnJlZC5yZWplY3QoKSk7XG5cbiAgICAgIH07XG5cbiAgICAgIG1vZGFsLnByb21wdCA9IGZ1bmN0aW9uIChtZXNzYWdlLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3BlbkRpYWxvZyhcbiAgICAgICAgKF9yZWY0KSA9PiB7bGV0IHsgbGFiZWxzIH0gPSBfcmVmNDtyZXR1cm4gXCI8Zm9ybSBjbGFzcz1cXFwidWstZm9ybS1zdGFja2VkXFxcIj4gPGRpdiBjbGFzcz1cXFwidWstbW9kYWwtYm9keVxcXCI+IDxsYWJlbD5cIiArIChcblxuICAgICAgICAgIGlzU3RyaW5nKG1lc3NhZ2UpID8gbWVzc2FnZSA6IGh0bWwobWVzc2FnZSkpICsgXCI8L2xhYmVsPiA8aW5wdXQgY2xhc3M9XFxcInVrLWlucHV0XFxcIiB2YWx1ZT1cXFwiXCIgKyAoXG4gICAgICAgICAgdmFsdWUgfHwgJycpICsgXCJcXFwiIGF1dG9mb2N1cz4gPC9kaXY+IDxkaXYgY2xhc3M9XFxcInVrLW1vZGFsLWZvb3RlciB1ay10ZXh0LXJpZ2h0XFxcIj4gPGJ1dHRvbiBjbGFzcz1cXFwidWstYnV0dG9uIHVrLWJ1dHRvbi1kZWZhdWx0IHVrLW1vZGFsLWNsb3NlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPlwiICtcblxuXG5cbiAgICAgICAgICBsYWJlbHMuY2FuY2VsICsgXCI8L2J1dHRvbj4gPGJ1dHRvbiBjbGFzcz1cXFwidWstYnV0dG9uIHVrLWJ1dHRvbi1wcmltYXJ5XFxcIj5cIiArXG5cbiAgICAgICAgICBsYWJlbHMub2sgKyBcIjwvYnV0dG9uPiA8L2Rpdj4gPC9mb3JtPlwiO30sXG5cblxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAoZGVmZXJyZWQpID0+IGRlZmVycmVkLnJlc29sdmUobnVsbCksXG4gICAgICAgIChkaWFsb2cpID0+ICQoJ2lucHV0JywgZGlhbG9nLiRlbCkudmFsdWUpO1xuXG4gICAgICB9O1xuXG4gICAgICBtb2RhbC5sYWJlbHMgPSB7XG4gICAgICAgIG9rOiAnT2snLFxuICAgICAgICBjYW5jZWw6ICdDYW5jZWwnIH07XG5cblxuICAgICAgZnVuY3Rpb24gb3BlbkRpYWxvZyh0bXBsLCBvcHRpb25zLCBoaWRlRm4sIHN1Ym1pdEZuKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IGJnQ2xvc2U6IGZhbHNlLCBlc2NDbG9zZTogdHJ1ZSwgbGFiZWxzOiBtb2RhbC5sYWJlbHMsIC4uLm9wdGlvbnMgfTtcblxuICAgICAgICBjb25zdCBkaWFsb2cgPSBtb2RhbC5kaWFsb2codG1wbChvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG5cbiAgICAgICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG5cbiAgICAgICAgb24oZGlhbG9nLiRlbCwgJ3N1Ym1pdCcsICdmb3JtJywgKGUpID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzdWJtaXRGbiA9PSBudWxsID8gdm9pZCAwIDogc3VibWl0Rm4oZGlhbG9nKSk7XG4gICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgIGRpYWxvZy5oaWRlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9uKGRpYWxvZy4kZWwsICdoaWRlJywgKCkgPT4gIXJlc29sdmVkICYmIGhpZGVGbihkZWZlcnJlZCkpO1xuXG4gICAgICAgIGRlZmVycmVkLnByb21pc2UuZGlhbG9nID0gZGlhbG9nO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuYXYgPSB7XG4gICAgICBleHRlbmRzOiBBY2NvcmRpb24sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0czogJz4gLnVrLXBhcmVudCcsXG4gICAgICAgIHRvZ2dsZTogJz4gYScsXG4gICAgICAgIGNvbnRlbnQ6ICc+IHVsJyB9IH07XG5cbiAgICB2YXIgbmF2YmFyID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIENvbnRhaW5lcl0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRyb3Bkb3duOiBTdHJpbmcsXG4gICAgICAgIG1vZGU6ICdsaXN0JyxcbiAgICAgICAgYWxpZ246IFN0cmluZyxcbiAgICAgICAgb2Zmc2V0OiBOdW1iZXIsXG4gICAgICAgIGJvdW5kYXJ5OiBCb29sZWFuLFxuICAgICAgICBib3VuZGFyeUFsaWduOiBCb29sZWFuLFxuICAgICAgICBjbHNEcm9wOiBTdHJpbmcsXG4gICAgICAgIGRlbGF5U2hvdzogTnVtYmVyLFxuICAgICAgICBkZWxheUhpZGU6IE51bWJlcixcbiAgICAgICAgZHJvcGJhcjogQm9vbGVhbixcbiAgICAgICAgZHJvcGJhckFuY2hvcjogQm9vbGVhbixcbiAgICAgICAgZHVyYXRpb246IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZHJvcGRvd246ICcudWstbmF2YmFyLW5hdiA+IGxpID4gYSwgLnVrLW5hdmJhci1pdGVtLCAudWstbmF2YmFyLXRvZ2dsZScsXG4gICAgICAgIGFsaWduOiBpc1J0bCA/ICdyaWdodCcgOiAnbGVmdCcsXG4gICAgICAgIGNsc0Ryb3A6ICd1ay1uYXZiYXItZHJvcGRvd24nLFxuICAgICAgICBtb2RlOiB1bmRlZmluZWQsXG4gICAgICAgIG9mZnNldDogdW5kZWZpbmVkLFxuICAgICAgICBkZWxheVNob3c6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVsYXlIaWRlOiB1bmRlZmluZWQsXG4gICAgICAgIGJvdW5kYXJ5QWxpZ246IHVuZGVmaW5lZCxcbiAgICAgICAgZmxpcDogJ3gnLFxuICAgICAgICBib3VuZGFyeTogdHJ1ZSxcbiAgICAgICAgZHJvcGJhcjogZmFsc2UsXG4gICAgICAgIGRyb3BiYXJBbmNob3I6IGZhbHNlLFxuICAgICAgICBkdXJhdGlvbjogMjAwLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYm91bmRhcnkoX3JlZiwgJGVsKSB7bGV0IHsgYm91bmRhcnkgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIGJvdW5kYXJ5ID09PSB0cnVlID8gJGVsIDogYm91bmRhcnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJvcGJhckFuY2hvcihfcmVmMiwgJGVsKSB7bGV0IHsgZHJvcGJhckFuY2hvciB9ID0gX3JlZjI7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5KGRyb3BiYXJBbmNob3IsICRlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zKF9yZWYzKSB7bGV0IHsgYWxpZ24gfSA9IF9yZWYzO1xuICAgICAgICAgIHJldHVybiBcImJvdHRvbS1cIiArIGFsaWduO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyb3BiYXI6IHtcbiAgICAgICAgICBnZXQoX3JlZjQpIHtsZXQgeyBkcm9wYmFyIH0gPSBfcmVmNDtcbiAgICAgICAgICAgIGlmICghZHJvcGJhcikge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHJvcGJhciA9XG4gICAgICAgICAgICB0aGlzLl9kcm9wYmFyIHx8XG4gICAgICAgICAgICBxdWVyeShkcm9wYmFyLCB0aGlzLiRlbCkgfHxcbiAgICAgICAgICAgICQoJysgLnVrLW5hdmJhci1kcm9wYmFyJywgdGhpcy4kZWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gZHJvcGJhciA/IGRyb3BiYXIgOiB0aGlzLl9kcm9wYmFyID0gJCgnPGRpdj48L2Rpdj4nKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goZHJvcGJhcikge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZHJvcGJhciwgJ3VrLW5hdmJhci1kcm9wYmFyJyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgZHJvcENvbnRhaW5lcihfLCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIgfHwgJGVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyb3Bkb3duczoge1xuICAgICAgICAgIGdldChfcmVmNSwgJGVsKSB7bGV0IHsgY2xzRHJvcCB9ID0gX3JlZjU7XG4gICAgICAgICAgICBjb25zdCBkcm9wZG93bnMgPSAkJChcIi5cIiArIGNsc0Ryb3AsICRlbCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRyb3BDb250YWluZXIgIT09ICRlbCkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mICQkKFwiLlwiICsgY2xzRHJvcCwgdGhpcy5kcm9wQ29udGFpbmVyKSkge3ZhciBfdGhpcyRnZXREcm9wZG93bjtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoX3RoaXMkZ2V0RHJvcGRvd24gPSB0aGlzLmdldERyb3Bkb3duKGVsKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGdldERyb3Bkb3duLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVzKGRyb3Bkb3ducywgZWwpICYmIHRhcmdldCAmJiB3aXRoaW4odGFyZ2V0LCB0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgICAgICAgIGRyb3Bkb3ducy5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRyb3Bkb3ducztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goZHJvcGRvd25zKSB7XG4gICAgICAgICAgICB0aGlzLiRjcmVhdGUoXG4gICAgICAgICAgICAnZHJvcCcsXG4gICAgICAgICAgICBkcm9wZG93bnMuZmlsdGVyKChlbCkgPT4gIXRoaXMuZ2V0RHJvcGRvd24oZWwpKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4udGhpcy4kcHJvcHMsXG4gICAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLmJvdW5kYXJ5LFxuICAgICAgICAgICAgICBwb3M6IHRoaXMucG9zLFxuICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuZHJvcGJhciB8fCB0aGlzLm9mZnNldCB9KTtcblxuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgdG9nZ2xlczoge1xuICAgICAgICAgIGdldChfcmVmNiwgJGVsKSB7bGV0IHsgZHJvcGRvd24gfSA9IF9yZWY2O1xuICAgICAgICAgICAgcmV0dXJuICQkKGRyb3Bkb3duLCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGp1c3RpZnkgPSBoYXNDbGFzcyh0aGlzLiRlbCwgJ3VrLW5hdmJhci1qdXN0aWZ5Jyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiAkJChcbiAgICAgICAgICAgICcudWstbmF2YmFyLW5hdiwgLnVrLW5hdmJhci1sZWZ0LCAudWstbmF2YmFyLXJpZ2h0JyxcbiAgICAgICAgICAgIHRoaXMuJGVsKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY3NzKGNvbnRhaW5lciwgJ2ZsZXhHcm93JywganVzdGlmeSA/ICQkKHRoaXMuZHJvcGRvd24sIGNvbnRhaW5lcikubGVuZ3RoIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSB9LFxuXG5cblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmRyb3BiYXIgJiYgcmVtb3ZlJDEodGhpcy5kcm9wYmFyKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Ryb3BiYXI7XG4gICAgICB9LFxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ21vdXNlb3ZlciBmb2N1c2luJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF9yZWY3KSB7bGV0IHsgY3VycmVudCB9ID0gX3JlZjc7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgYWN0aXZlICYmXG4gICAgICAgICAgaW5jbHVkZXMoYWN0aXZlLm1vZGUsICdob3ZlcicpICYmXG4gICAgICAgICAgYWN0aXZlLnRhcmdldCAmJlxuICAgICAgICAgICF3aXRoaW4oYWN0aXZlLnRhcmdldCwgY3VycmVudCkgJiZcbiAgICAgICAgICAhYWN0aXZlLmlzRGVsYXlpbmcpXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWN0aXZlLmhpZGUoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2tleWRvd24nLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3duO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGNvbnN0IHsgY3VycmVudCwga2V5Q29kZSB9ID0gZTtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuXG4gICAgICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5ET1dOICYmIGhhc0F0dHIoY3VycmVudCwgJ2FyaWEtZXhwYW5kZWQnKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZSB8fCBhY3RpdmUudGFyZ2V0ICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQuY2xpY2soKTtcbiAgICAgICAgICAgICAgb25jZSh0aGlzLmRyb3BDb250YWluZXIsICdzaG93JywgKF9yZWY4KSA9PiB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmODtyZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQodGFyZ2V0KSk7fSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvY3VzRmlyc3RGb2N1c2FibGVFbGVtZW50KGFjdGl2ZS4kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZU5hdkl0ZW1OYXZpZ2F0aW9uKGUsIHRoaXMudG9nZ2xlcywgYWN0aXZlKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2tleWRvd24nLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BDb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiLlwiICsgdGhpcy5jbHNEcm9wO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGNvbnN0IHsgY3VycmVudCwga2V5Q29kZSB9ID0gZTtcblxuICAgICAgICAgIGlmICghaW5jbHVkZXModGhpcy5kcm9wZG93bnMsIGN1cnJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcbiAgICAgICAgICBjb25zdCBlbGVtZW50cyA9ICQkKHNlbEZvY3VzYWJsZSwgY3VycmVudCk7XG4gICAgICAgICAgY29uc3QgaSA9IGZpbmRJbmRleChlbGVtZW50cywgKGVsKSA9PiBtYXRjaGVzKGVsLCAnOmZvY3VzJykpO1xuXG4gICAgICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5VUCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzW2kgLSAxXS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuRE9XTikge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGkgPCBlbGVtZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzW2kgKyAxXS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuRVNDKSB7dmFyIF9hY3RpdmUkdGFyZ2V0O1xuICAgICAgICAgICAgYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiAoX2FjdGl2ZSR0YXJnZXQgPSBhY3RpdmUudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2FjdGl2ZSR0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVOYXZJdGVtTmF2aWdhdGlvbihlLCB0aGlzLnRvZ2dsZXMsIGFjdGl2ZSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdtb3VzZWxlYXZlJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICBhY3RpdmUgJiZcbiAgICAgICAgICBpbmNsdWRlcyhhY3RpdmUubW9kZSwgJ2hvdmVyJykgJiZcbiAgICAgICAgICAhdGhpcy5kcm9wZG93bnMuc29tZSgoZWwpID0+IG1hdGNoZXMoZWwsICc6aG92ZXInKSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWN0aXZlLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdiZWZvcmVzaG93JyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoXywgX3JlZjkpIHtsZXQgeyAkZWwgfSA9IF9yZWY5O1xuICAgICAgICAgIGlmICghaGFzQ2xhc3MoJGVsLCB0aGlzLmNsc0Ryb3ApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFwYXJlbnQodGhpcy5kcm9wYmFyKSkge1xuICAgICAgICAgICAgYWZ0ZXIodGhpcy5kcm9wYmFyQW5jaG9yIHx8IHRoaXMuJGVsLCB0aGlzLmRyb3BiYXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFkZENsYXNzKCRlbCwgdGhpcy5jbHNEcm9wICsgXCItZHJvcGJhclwiKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3Nob3cnLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BDb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihfLCBfcmVmMTApIHtsZXQgeyAkZWwsIHBvczogW2Rpcl0gPSBbXSB9ID0gX3JlZjEwO1xuICAgICAgICAgIGlmICghaGFzQ2xhc3MoJGVsLCB0aGlzLmNsc0Ryb3ApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpciA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvKFxuICAgICAgICAgICAgb2Zmc2V0KCRlbCkuYm90dG9tIC1cbiAgICAgICAgICAgIG9mZnNldCh0aGlzLmRyb3BiYXIpLnRvcCArXG4gICAgICAgICAgICB0b0Zsb2F0KGNzcygkZWwsICdtYXJnaW5Cb3R0b20nKSksXG4gICAgICAgICAgICAkZWwpO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3JlaGlkZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUsIF9yZWYxMSkge2xldCB7ICRlbCB9ID0gX3JlZjExO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgbWF0Y2hlcyh0aGlzLmRyb3BiYXIsICc6aG92ZXInKSAmJlxuICAgICAgICAgIChhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS4kZWwpID09PSAkZWwgJiZcbiAgICAgICAgICAhdGhpcy50b2dnbGVzLnNvbWUoKGVsKSA9PiBhY3RpdmUudGFyZ2V0ICE9PSBlbCAmJiBtYXRjaGVzKGVsLCAnOmZvY3VzJykpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRlJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoXywgX3JlZjEyKSB7bGV0IHsgJGVsIH0gPSBfcmVmMTI7XG4gICAgICAgICAgaWYgKCFoYXNDbGFzcygkZWwsIHRoaXMuY2xzRHJvcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuXG4gICAgICAgICAgaWYgKCFhY3RpdmUgfHwgKGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLiRlbCkgPT09ICRlbCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBnZXRBY3RpdmUoKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZSQxICYmIHdpdGhpbihhY3RpdmUkMS50YXJnZXQsIHRoaXMuJGVsKSAmJiBhY3RpdmUkMTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2l0aW9uVG8obmV3SGVpZ2h0LCBlbCkge1xuICAgICAgICAgIGNvbnN0IHsgZHJvcGJhciB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCBvbGRIZWlnaHQgPSBpc1Zpc2libGUoZHJvcGJhcikgPyBoZWlnaHQoZHJvcGJhcikgOiAwO1xuXG4gICAgICAgICAgZWwgPSBvbGRIZWlnaHQgPCBuZXdIZWlnaHQgJiYgZWw7XG5cbiAgICAgICAgICBjc3MoZWwsICdjbGlwJywgXCJyZWN0KDAsXCIgKyBlbC5vZmZzZXRXaWR0aCArIFwicHgsXCIgKyBvbGRIZWlnaHQgKyBcInB4LDApXCIpO1xuXG4gICAgICAgICAgaGVpZ2h0KGRyb3BiYXIsIG9sZEhlaWdodCk7XG5cbiAgICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbChbZWwsIGRyb3BiYXJdKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQoZHJvcGJhciwgeyBoZWlnaHQ6IG5ld0hlaWdodCB9LCB0aGlzLmR1cmF0aW9uKSxcbiAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIHsgY2xpcDogXCJyZWN0KDAsXCIgKyBlbC5vZmZzZXRXaWR0aCArIFwicHgsXCIgKyBuZXdIZWlnaHQgKyBcInB4LDApXCIgfSxcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uKV0pLlxuXG5cbiAgICAgICAgICBjYXRjaChub29wKS5cbiAgICAgICAgICB0aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNzcyhlbCwgeyBjbGlwOiAnJyB9KTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZShkcm9wYmFyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREcm9wZG93bihlbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRnZXRDb21wb25lbnQoZWwsICdkcm9wJykgfHwgdGhpcy4kZ2V0Q29tcG9uZW50KGVsLCAnZHJvcGRvd24nKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gaGFuZGxlTmF2SXRlbU5hdmlnYXRpb24oZSwgdG9nZ2xlcywgYWN0aXZlKSB7XG4gICAgICBjb25zdCB7IGN1cnJlbnQsIGtleUNvZGUgfSA9IGU7XG4gICAgICBjb25zdCB0YXJnZXQgPSAoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUudGFyZ2V0KSB8fCBjdXJyZW50O1xuICAgICAgY29uc3QgaSA9IHRvZ2dsZXMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgICAvLyBMZWZ0XG4gICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLkxFRlQgJiYgaSA+IDApIHtcbiAgICAgICAgYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaGlkZShmYWxzZSk7XG4gICAgICAgIHRvZ2dsZXNbaSAtIDFdLmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJpZ2h0XG4gICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLlJJR0hUICYmIGkgPCB0b2dnbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaGlkZShmYWxzZSk7XG4gICAgICAgIHRvZ2dsZXNbaSArIDFdLmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuVEFCKSB7XG4gICAgICAgIHRhcmdldC5mb2N1cygpO1xuICAgICAgICBhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5oaWRlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudChlbCkge1xuICAgICAgaWYgKCEkKCc6Zm9jdXMnLCBlbCkpIHt2YXIgXyQ7XG4gICAgICAgIChfJCA9ICQoc2VsRm9jdXNhYmxlLCBlbCkpID09IG51bGwgPyB2b2lkIDAgOiBfJC5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGtleU1hcCA9IHtcbiAgICAgIFRBQjogOSxcbiAgICAgIEVTQzogMjcsXG4gICAgICBMRUZUOiAzNyxcbiAgICAgIFVQOiAzOCxcbiAgICAgIFJJR0hUOiAzOSxcbiAgICAgIERPV046IDQwIH07XG5cbiAgICB2YXIgU3dpcGUgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBzd2lwaW5nOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBzd2lwaW5nOiB0cnVlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc3dpcGVUYXJnZXQocHJvcHMsICRlbCkge1xuICAgICAgICAgIHJldHVybiAkZWw7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zd2lwaW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJFdmVudCh0aGlzLCB7XG4gICAgICAgICAgZWw6IHRoaXMuc3dpcGVUYXJnZXQsXG4gICAgICAgICAgbmFtZTogcG9pbnRlckRvd24sXG4gICAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGlmICghaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBTd2lwZSBHZXN0dXJlXG4gICAgICAgICAgICBjb25zdCBwb3MgPSBnZXRFdmVudFBvcyhlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9ICd0YWdOYW1lJyBpbiBlLnRhcmdldCA/IGUudGFyZ2V0IDogcGFyZW50KGUudGFyZ2V0KTtcbiAgICAgICAgICAgIG9uY2UoZG9jdW1lbnQsIHBvaW50ZXJVcCArIFwiIFwiICsgcG9pbnRlckNhbmNlbCArIFwiIHNjcm9sbFwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zKGUpO1xuXG4gICAgICAgICAgICAgIC8vIHN3aXBlXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZS50eXBlICE9PSAnc2Nyb2xsJyAmJiB0YXJnZXQgJiYgeCAmJiBNYXRoLmFicyhwb3MueCAtIHgpID4gMTAwIHx8XG4gICAgICAgICAgICAgIHkgJiYgTWF0aC5hYnMocG9zLnkgLSB5KSA+IDEwMClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsICdzd2lwZScpO1xuICAgICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic3dpcGVcIiArIHN3aXBlRGlyZWN0aW9uKHBvcy54LCBwb3MueSwgeCwgeSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IH0pO1xuXG4gICAgICB9IH07XG5cblxuICAgIGZ1bmN0aW9uIHN3aXBlRGlyZWN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoeDEgLSB4MikgPj0gTWF0aC5hYnMoeTEgLSB5MikgP1xuICAgICAgeDEgLSB4MiA+IDAgP1xuICAgICAgJ0xlZnQnIDpcbiAgICAgICdSaWdodCcgOlxuICAgICAgeTEgLSB5MiA+IDAgP1xuICAgICAgJ1VwJyA6XG4gICAgICAnRG93bic7XG4gICAgfVxuXG4gICAgdmFyIG9mZmNhbnZhcyA9IHtcbiAgICAgIG1peGluczogW01vZGFsLCBTd2lwZV0sXG5cbiAgICAgIGFyZ3M6ICdtb2RlJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbW9kZTogU3RyaW5nLFxuICAgICAgICBmbGlwOiBCb29sZWFuLFxuICAgICAgICBvdmVybGF5OiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBtb2RlOiAnc2xpZGUnLFxuICAgICAgICBmbGlwOiBmYWxzZSxcbiAgICAgICAgb3ZlcmxheTogZmFsc2UsXG4gICAgICAgIGNsc1BhZ2U6ICd1ay1vZmZjYW52YXMtcGFnZScsXG4gICAgICAgIGNsc0NvbnRhaW5lcjogJ3VrLW9mZmNhbnZhcy1jb250YWluZXInLFxuICAgICAgICBzZWxQYW5lbDogJy51ay1vZmZjYW52YXMtYmFyJyxcbiAgICAgICAgY2xzRmxpcDogJ3VrLW9mZmNhbnZhcy1mbGlwJyxcbiAgICAgICAgY2xzQ29udGFpbmVyQW5pbWF0aW9uOiAndWstb2ZmY2FudmFzLWNvbnRhaW5lci1hbmltYXRpb24nLFxuICAgICAgICBjbHNTaWRlYmFyQW5pbWF0aW9uOiAndWstb2ZmY2FudmFzLWJhci1hbmltYXRpb24nLFxuICAgICAgICBjbHNNb2RlOiAndWstb2ZmY2FudmFzJyxcbiAgICAgICAgY2xzT3ZlcmxheTogJ3VrLW9mZmNhbnZhcy1vdmVybGF5JyxcbiAgICAgICAgc2VsQ2xvc2U6ICcudWstb2ZmY2FudmFzLWNsb3NlJyxcbiAgICAgICAgY29udGFpbmVyOiBmYWxzZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsc0ZsaXAoX3JlZikge2xldCB7IGZsaXAsIGNsc0ZsaXAgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIGZsaXAgPyBjbHNGbGlwIDogJyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xzT3ZlcmxheShfcmVmMikge2xldCB7IG92ZXJsYXksIGNsc092ZXJsYXkgfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiBvdmVybGF5ID8gY2xzT3ZlcmxheSA6ICcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsc01vZGUoX3JlZjMpIHtsZXQgeyBtb2RlLCBjbHNNb2RlIH0gPSBfcmVmMztcbiAgICAgICAgICByZXR1cm4gY2xzTW9kZSArIFwiLVwiICsgbW9kZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbHNTaWRlYmFyQW5pbWF0aW9uKF9yZWY0KSB7bGV0IHsgbW9kZSwgY2xzU2lkZWJhckFuaW1hdGlvbiB9ID0gX3JlZjQ7XG4gICAgICAgICAgcmV0dXJuIG1vZGUgPT09ICdub25lJyB8fCBtb2RlID09PSAncmV2ZWFsJyA/ICcnIDogY2xzU2lkZWJhckFuaW1hdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBjbHNDb250YWluZXJBbmltYXRpb24oX3JlZjUpIHtsZXQgeyBtb2RlLCBjbHNDb250YWluZXJBbmltYXRpb24gfSA9IF9yZWY1O1xuICAgICAgICAgIHJldHVybiBtb2RlICE9PSAncHVzaCcgJiYgbW9kZSAhPT0gJ3JldmVhbCcgPyAnJyA6IGNsc0NvbnRhaW5lckFuaW1hdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2l0aW9uRWxlbWVudChfcmVmNikge2xldCB7IG1vZGUgfSA9IF9yZWY2O1xuICAgICAgICAgIHJldHVybiBtb2RlID09PSAncmV2ZWFsJyA/IHBhcmVudCh0aGlzLnBhbmVsKSA6IHRoaXMucGFuZWw7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSAmJiAhaXNWaXNpYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9LFxuXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiAnYVtocmVmXj1cIiNcIl0nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjcpIHtsZXQgeyBjdXJyZW50OiB7IGhhc2ggfSwgZGVmYXVsdFByZXZlbnRlZCB9ID0gX3JlZjc7XG4gICAgICAgICAgaWYgKCFkZWZhdWx0UHJldmVudGVkICYmIGhhc2ggJiYgJChoYXNoLCBkb2N1bWVudC5ib2R5KSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG91Y2hzdGFydCcsXG5cbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYW5lbDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF9yZWY4KSB7bGV0IHsgdGFyZ2V0VG91Y2hlcyB9ID0gX3JlZjg7XG4gICAgICAgICAgaWYgKHRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudFkgPSB0YXJnZXRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG91Y2htb3ZlJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLmNhbmNlbGFibGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG91Y2htb3ZlJyxcblxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYW5lbDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGNsaWVudFkgPSBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WSAtIHRoaXMuY2xpZW50WTtcbiAgICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQgfSA9IHRoaXMucGFuZWw7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgY2xpZW50SGVpZ2h0ID49IHNjcm9sbEhlaWdodCB8fFxuICAgICAgICAgIHNjcm9sbFRvcCA9PT0gMCAmJiBjbGllbnRZID4gMCB8fFxuICAgICAgICAgIHNjcm9sbEhlaWdodCAtIHNjcm9sbFRvcCA8PSBjbGllbnRIZWlnaHQgJiYgY2xpZW50WSA8IDApXG4gICAgICAgICAge1xuICAgICAgICAgICAgZS5jYW5jZWxhYmxlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93JyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ3JldmVhbCcgJiYgIWhhc0NsYXNzKHBhcmVudCh0aGlzLnBhbmVsKSwgdGhpcy5jbHNNb2RlKSkge1xuICAgICAgICAgICAgd3JhcEFsbCh0aGlzLnBhbmVsLCAnPGRpdj4nKTtcbiAgICAgICAgICAgIGFkZENsYXNzKHBhcmVudCh0aGlzLnBhbmVsKSwgdGhpcy5jbHNNb2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnb3ZlcmZsb3dZJywgdGhpcy5vdmVybGF5ID8gJ2hpZGRlbicgOiAnJyk7XG4gICAgICAgICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgdGhpcy5jbHNDb250YWluZXIsIHRoaXMuY2xzRmxpcCk7XG4gICAgICAgICAgY3NzKGRvY3VtZW50LmJvZHksICd0b3VjaC1hY3Rpb24nLCAncGFuLXkgcGluY2gtem9vbScpO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNPdmVybGF5KTtcbiAgICAgICAgICBhZGRDbGFzcyhcbiAgICAgICAgICB0aGlzLnBhbmVsLFxuICAgICAgICAgIHRoaXMuY2xzU2lkZWJhckFuaW1hdGlvbixcbiAgICAgICAgICB0aGlzLm1vZGUgIT09ICdyZXZlYWwnID8gdGhpcy5jbHNNb2RlIDogJycpO1xuXG5cbiAgICAgICAgICBoZWlnaHQoZG9jdW1lbnQuYm9keSk7IC8vIGZvcmNlIHJlZmxvd1xuICAgICAgICAgIGFkZENsYXNzKGRvY3VtZW50LmJvZHksIHRoaXMuY2xzQ29udGFpbmVyQW5pbWF0aW9uKTtcblxuICAgICAgICAgIHRoaXMuY2xzQ29udGFpbmVyQW5pbWF0aW9uICYmIHN1cHByZXNzVXNlclNjYWxlKCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRlJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgdGhpcy5jbHNDb250YWluZXJBbmltYXRpb24pO1xuICAgICAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndG91Y2gtYWN0aW9uJywgJycpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaGlkZGVuJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5jbHNDb250YWluZXJBbmltYXRpb24gJiYgcmVzdW1lVXNlclNjYWxlKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5tb2RlID09PSAncmV2ZWFsJykge1xuICAgICAgICAgICAgdW53cmFwKHRoaXMucGFuZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMucGFuZWwsIHRoaXMuY2xzU2lkZWJhckFuaW1hdGlvbiwgdGhpcy5jbHNNb2RlKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNPdmVybGF5KTtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsICdkaXNwbGF5JywgJycpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIHRoaXMuY2xzQ29udGFpbmVyLCB0aGlzLmNsc0ZsaXApO1xuXG4gICAgICAgICAgY3NzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ292ZXJmbG93WScsICcnKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3N3aXBlTGVmdCBzd2lwZVJpZ2h0JyxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSAmJiBlbmRzV2l0aChlLnR5cGUsICdMZWZ0JykgXiB0aGlzLmZsaXApIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XSB9O1xuXG5cblxuXG4gICAgLy8gQ2hyb21lIGluIHJlc3BvbnNpdmUgbW9kZSB6b29tcyBwYWdlIHVwb24gb3BlbmluZyBvZmZjYW52YXNcbiAgICBmdW5jdGlvbiBzdXBwcmVzc1VzZXJTY2FsZSgpIHtcbiAgICAgIGdldFZpZXdwb3J0KCkuY29udGVudCArPSAnLHVzZXItc2NhbGFibGU9MCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdW1lVXNlclNjYWxlKCkge1xuICAgICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydCgpO1xuICAgICAgdmlld3BvcnQuY29udGVudCA9IHZpZXdwb3J0LmNvbnRlbnQucmVwbGFjZSgvLHVzZXItc2NhbGFibGU9MCQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Vmlld3BvcnQoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAkKCdtZXRhW25hbWU9XCJ2aWV3cG9ydFwiXScsIGRvY3VtZW50LmhlYWQpIHx8IGFwcGVuZChkb2N1bWVudC5oZWFkLCAnPG1ldGEgbmFtZT1cInZpZXdwb3J0XCI+JykpO1xuXG4gICAgfVxuXG4gICAgdmFyIG92ZXJmbG93QXV0byA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBSZXNpemVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBzZWxDb250YWluZXI6IFN0cmluZyxcbiAgICAgICAgc2VsQ29udGVudDogU3RyaW5nLFxuICAgICAgICBtaW5IZWlnaHQ6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2VsQ29udGFpbmVyOiAnLnVrLW1vZGFsJyxcbiAgICAgICAgc2VsQ29udGVudDogJy51ay1tb2RhbC1kaWFsb2cnLFxuICAgICAgICBtaW5IZWlnaHQ6IDE1MCB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvbnRhaW5lcihfcmVmLCAkZWwpIHtsZXQgeyBzZWxDb250YWluZXIgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIGNsb3Nlc3QoJGVsLCBzZWxDb250YWluZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRlbnQoX3JlZjIsICRlbCkge2xldCB7IHNlbENvbnRlbnQgfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiBjbG9zZXN0KCRlbCwgc2VsQ29udGVudCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICByZXNpemVUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuY29udGFpbmVyLCB0aGlzLmNvbnRlbnRdO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQgfHwgIXRoaXMuY29udGFpbmVyIHx8ICFpc1Zpc2libGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1heDogTWF0aC5tYXgoXG4gICAgICAgICAgICB0aGlzLm1pbkhlaWdodCxcbiAgICAgICAgICAgIGhlaWdodCh0aGlzLmNvbnRhaW5lcikgLSAoZGltZW5zaW9ucyQxKHRoaXMuY29udGVudCkuaGVpZ2h0IC0gaGVpZ2h0KHRoaXMuJGVsKSkpIH07XG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYzKSB7bGV0IHsgbWF4IH0gPSBfcmVmMztcbiAgICAgICAgICBjc3ModGhpcy4kZWwsIHsgbWluSGVpZ2h0OiB0aGlzLm1pbkhlaWdodCwgbWF4SGVpZ2h0OiBtYXggfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuICAgIHZhciByZXNwb25zaXZlID0ge1xuICAgICAgbWl4aW5zOiBbUmVzaXplXSxcblxuICAgICAgcHJvcHM6IFsnd2lkdGgnLCAnaGVpZ2h0J10sXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy4kZWwsIHBhcmVudCh0aGlzLiRlbCldO1xuICAgICAgfSxcblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLXJlc3BvbnNpdmUtd2lkdGgnKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIHJldHVybiBpc1Zpc2libGUodGhpcy4kZWwpICYmIHRoaXMud2lkdGggJiYgdGhpcy5oZWlnaHQgP1xuICAgICAgICAgIHsgd2lkdGg6IHdpZHRoKHBhcmVudCh0aGlzLiRlbCkpLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH0gOlxuICAgICAgICAgIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKGRpbSkge1xuICAgICAgICAgIGhlaWdodChcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICBEaW1lbnNpb25zLmNvbnRhaW4oXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoIH0sXG5cbiAgICAgICAgICBkaW0pLlxuICAgICAgICAgIGhlaWdodCk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSB9O1xuXG4gICAgdmFyIHNjcm9sbCA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG9mZnNldDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBvZmZzZXQ6IDAgfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIHNjcm9sbFRvKGVsKSB7XG4gICAgICAgICAgZWwgPSBlbCAmJiAkKGVsKSB8fCBkb2N1bWVudC5ib2R5O1xuXG4gICAgICAgICAgaWYgKHRyaWdnZXIodGhpcy4kZWwsICdiZWZvcmVzY3JvbGwnLCBbdGhpcywgZWxdKSkge1xuICAgICAgICAgICAgYXdhaXQgc2Nyb2xsSW50b1ZpZXcoZWwsIHsgb2Zmc2V0OiB0aGlzLm9mZnNldCB9KTtcbiAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdzY3JvbGxlZCcsIFt0aGlzLCBlbF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBjbGljayhlKSB7XG4gICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvKGdldFRhcmdldEVsZW1lbnQodGhpcy4kZWwpKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gZ2V0VGFyZ2V0RWxlbWVudChlbCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRlY29kZVVSSUNvbXBvbmVudChlbC5oYXNoKS5zdWJzdHJpbmcoMSkpO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxzcHkgPSB7XG4gICAgICBtaXhpbnM6IFtTY3JvbGxdLFxuXG4gICAgICBhcmdzOiAnY2xzJyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xzOiBTdHJpbmcsXG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICBoaWRkZW46IEJvb2xlYW4sXG4gICAgICAgIG9mZnNldFRvcDogTnVtYmVyLFxuICAgICAgICBvZmZzZXRMZWZ0OiBOdW1iZXIsXG4gICAgICAgIHJlcGVhdDogQm9vbGVhbixcbiAgICAgICAgZGVsYXk6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6ICgpID0+ICh7XG4gICAgICAgIGNsczogJycsXG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0VG9wOiAwLFxuICAgICAgICBvZmZzZXRMZWZ0OiAwLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgaW5WaWV3Q2xhc3M6ICd1ay1zY3JvbGxzcHktaW52aWV3JyB9KSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgIGdldChfcmVmLCAkZWwpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0ID8gJCQodGFyZ2V0LCAkZWwpIDogWyRlbF07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGVsZW1lbnRzLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgY3NzKGZpbHRlciQxKGVsZW1lbnRzLCBcIjpub3QoLlwiICsgdGhpcy5pblZpZXdDbGFzcyArIFwiKVwiKSwgJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNFcXVhbChlbGVtZW50cywgcHJldikpIHtcbiAgICAgICAgICAgICAgdGhpcy4kcmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0gfSxcblxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5fZGF0YS5lbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck9ic2VydmVyKFxuICAgICAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKFxuICAgICAgICB0aGlzLmVsZW1lbnRzLFxuICAgICAgICAocmVjb3JkcykgPT4ge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fZGF0YS5lbGVtZW50cztcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0OiBlbCwgaXNJbnRlcnNlY3RpbmcgfSBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRzLmhhcyhlbCkpIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMuc2V0KGVsLCB7XG4gICAgICAgICAgICAgICAgY2xzOiBkYXRhKGVsLCAndWstc2Nyb2xsc3B5LWNsYXNzJykgfHwgdGhpcy5jbHMgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlbGVtZW50cy5nZXQoZWwpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcGVhdCAmJiBzdGF0ZS5zaG93KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5zaG93ID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcm9vdE1hcmdpbjogdG9QeCh0aGlzLm9mZnNldFRvcCwgJ2hlaWdodCcpIC0gMSArIFwicHggXCIgKyAoXG4gICAgICAgICAgdG9QeCh0aGlzLm9mZnNldExlZnQsICd3aWR0aCcpIC0gMSkgKyBcInB4XCIgfSxcblxuXG4gICAgICAgIGZhbHNlKSk7XG5cblxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtlbCwgc3RhdGVdIG9mIHRoaXMuX2RhdGEuZWxlbWVudHMuZW50cmllcygpKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIHRoaXMuaW5WaWV3Q2xhc3MsIChzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuY2xzKSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogW1xuICAgICAge1xuICAgICAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZWwsIHN0YXRlXSBvZiBkYXRhLmVsZW1lbnRzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNob3cgJiYgIXN0YXRlLmludmlldyAmJiAhc3RhdGUucXVldWVkKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnF1ZXVlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZGF0YS5wcm9taXNlID0gKGRhdGEucHJvbWlzZSB8fCBQcm9taXNlLnJlc29sdmUoKSkuXG4gICAgICAgICAgICAgIHRoZW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGhpcy5kZWxheSkpKS5cbiAgICAgICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGUoZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgc3RhdGUucXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5zaG93ICYmIHN0YXRlLmludmlldyAmJiAhc3RhdGUucXVldWVkICYmIHRoaXMucmVwZWF0KSB7XG4gICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGVsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGUoZWwsIGludmlldykge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fZGF0YS5lbGVtZW50cy5nZXQoZWwpO1xuXG4gICAgICAgICAgc3RhdGUub2ZmID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5vZmYoKTtcblxuICAgICAgICAgIGNzcyhlbCwgJ3Zpc2liaWxpdHknLCAhaW52aWV3ICYmIHRoaXMuaGlkZGVuID8gJ2hpZGRlbicgOiAnJyk7XG5cbiAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcy5pblZpZXdDbGFzcywgaW52aWV3KTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgc3RhdGUuY2xzKTtcblxuICAgICAgICAgIGlmICgvXFxidWstYW5pbWF0aW9uLS8udGVzdChzdGF0ZS5jbHMpKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVBbmltYXRpb25DbGFzc2VzID0gKCkgPT4gcmVtb3ZlQ2xhc3NlcyhlbCwgJ3VrLWFuaW1hdGlvbi1bXFxcXHctXSsnKTtcbiAgICAgICAgICAgIGlmIChpbnZpZXcpIHtcbiAgICAgICAgICAgICAgc3RhdGUub2ZmID0gb25jZShlbCwgJ2FuaW1hdGlvbmNhbmNlbCBhbmltYXRpb25lbmQnLCByZW1vdmVBbmltYXRpb25DbGFzc2VzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbW92ZUFuaW1hdGlvbkNsYXNzZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmlnZ2VyKGVsLCBpbnZpZXcgPyAnaW52aWV3JyA6ICdvdXR2aWV3Jyk7XG5cbiAgICAgICAgICBzdGF0ZS5pbnZpZXcgPSBpbnZpZXc7XG5cbiAgICAgICAgICB0aGlzLiR1cGRhdGUoZWwpO1xuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBzY3JvbGxzcHlOYXYgPSB7XG4gICAgICBtaXhpbnM6IFtTY3JvbGxdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbHM6IFN0cmluZyxcbiAgICAgICAgY2xvc2VzdDogU3RyaW5nLFxuICAgICAgICBzY3JvbGw6IEJvb2xlYW4sXG4gICAgICAgIG92ZXJmbG93OiBCb29sZWFuLFxuICAgICAgICBvZmZzZXQ6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY2xzOiAndWstYWN0aXZlJyxcbiAgICAgICAgY2xvc2VzdDogZmFsc2UsXG4gICAgICAgIHNjcm9sbDogZmFsc2UsXG4gICAgICAgIG92ZXJmbG93OiB0cnVlLFxuICAgICAgICBvZmZzZXQ6IDAgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBsaW5rczoge1xuICAgICAgICAgIGdldChfLCAkZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkJCgnYVtocmVmXj1cIiNcIl0nLCAkZWwpLmZpbHRlcigoZWwpID0+IGVsLmhhc2gpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChsaW5rcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsKSB7XG4gICAgICAgICAgICAgIHRoaXMuJGNyZWF0ZSgnc2Nyb2xsJywgbGlua3MsIHsgb2Zmc2V0OiB0aGlzLm9mZnNldCB8fCAwIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIGVsZW1lbnRzKF9yZWYpIHtsZXQgeyBjbG9zZXN0OiBzZWxlY3RvciB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdCh0aGlzLmxpbmtzLCBzZWxlY3RvciB8fCAnKicpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgdXBkYXRlOiBbXG4gICAgICB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0cyA9IHRoaXMubGlua3MubWFwKGdldFRhcmdldEVsZW1lbnQpLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB0YXJnZXRzO1xuXG4gICAgICAgICAgaWYgKCFsZW5ndGggfHwgIWlzVmlzaWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBbc2Nyb2xsRWxlbWVudF0gPSBzY3JvbGxQYXJlbnRzKHRhcmdldHMsIC9hdXRvfHNjcm9sbC8sIHRydWUpO1xuICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQgfSA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBvZmZzZXRWaWV3cG9ydChzY3JvbGxFbGVtZW50KTtcbiAgICAgICAgICBjb25zdCBtYXggPSBzY3JvbGxIZWlnaHQgLSB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgbGV0IGFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbFRvcCA9PT0gbWF4KSB7XG4gICAgICAgICAgICBhY3RpdmUgPSBsZW5ndGggLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKG9mZnNldCh0YXJnZXRzW2ldKS50b3AgLSB2aWV3cG9ydC50b3AgLSB0aGlzLm9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhY3RpdmUgPSAraTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5vdmVyZmxvdykge1xuICAgICAgICAgICAgICBhY3RpdmUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IGFjdGl2ZSB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyaXRlKF9yZWYyKSB7bGV0IHsgYWN0aXZlIH0gPSBfcmVmMjtcbiAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gYWN0aXZlICE9PSBmYWxzZSAmJiAhaGFzQ2xhc3ModGhpcy5lbGVtZW50c1thY3RpdmVdLCB0aGlzLmNscyk7XG5cbiAgICAgICAgICB0aGlzLmxpbmtzLmZvckVhY2goKGVsKSA9PiBlbC5ibHVyKCkpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy5lbGVtZW50c1tpXSwgdGhpcy5jbHMsICtpID09PSBhY3RpdmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnYWN0aXZlJywgW2FjdGl2ZSwgdGhpcy5lbGVtZW50c1thY3RpdmVdXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydzY3JvbGwnLCAncmVzaXplJ10gfV0gfTtcblxuICAgIHZhciBzdGlja3kgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgTWVkaWEsIFJlc2l6ZSwgU2Nyb2xsXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcG9zaXRpb246IFN0cmluZyxcbiAgICAgICAgdG9wOiBudWxsLFxuICAgICAgICBib3R0b206IG51bGwsXG4gICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgIG9mZnNldDogU3RyaW5nLFxuICAgICAgICBvdmVyZmxvd0ZsaXA6IEJvb2xlYW4sXG4gICAgICAgIGFuaW1hdGlvbjogU3RyaW5nLFxuICAgICAgICBjbHNBY3RpdmU6IFN0cmluZyxcbiAgICAgICAgY2xzSW5hY3RpdmU6IFN0cmluZyxcbiAgICAgICAgY2xzRml4ZWQ6IFN0cmluZyxcbiAgICAgICAgY2xzQmVsb3c6IFN0cmluZyxcbiAgICAgICAgc2VsVGFyZ2V0OiBTdHJpbmcsXG4gICAgICAgIHNob3dPblVwOiBCb29sZWFuLFxuICAgICAgICB0YXJnZXRPZmZzZXQ6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICB0b3A6IGZhbHNlLFxuICAgICAgICBib3R0b206IGZhbHNlLFxuICAgICAgICBzdGFydDogZmFsc2UsXG4gICAgICAgIGVuZDogZmFsc2UsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgb3ZlcmZsb3dGbGlwOiBmYWxzZSxcbiAgICAgICAgYW5pbWF0aW9uOiAnJyxcbiAgICAgICAgY2xzQWN0aXZlOiAndWstYWN0aXZlJyxcbiAgICAgICAgY2xzSW5hY3RpdmU6ICcnLFxuICAgICAgICBjbHNGaXhlZDogJ3VrLXN0aWNreS1maXhlZCcsXG4gICAgICAgIGNsc0JlbG93OiAndWstc3RpY2t5LWJlbG93JyxcbiAgICAgICAgc2VsVGFyZ2V0OiAnJyxcbiAgICAgICAgc2hvd09uVXA6IGZhbHNlLFxuICAgICAgICB0YXJnZXRPZmZzZXQ6IGZhbHNlIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2VsVGFyZ2V0KF9yZWYsICRlbCkge2xldCB7IHNlbFRhcmdldCB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gc2VsVGFyZ2V0ICYmICQoc2VsVGFyZ2V0LCAkZWwpIHx8ICRlbDtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHJlc2l6ZVRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9LFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBjb2VyY2UodGhpcy5zdGFydCB8fCB0aGlzLnRvcCk7XG4gICAgICAgIHRoaXMuZW5kID0gY29lcmNlKHRoaXMuZW5kIHx8IHRoaXMuYm90dG9tKTtcblxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID1cbiAgICAgICAgJCgnKyAudWstc3RpY2t5LXBsYWNlaG9sZGVyJywgdGhpcy4kZWwpIHx8XG4gICAgICAgICQoJzxkaXYgY2xhc3M9XCJ1ay1zdGlja3ktcGxhY2Vob2xkZXJcIj48L2Rpdj4nKTtcbiAgICAgICAgdGhpcy5pc0ZpeGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKGZhbHNlKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaXhlZCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuc2VsVGFyZ2V0LCB0aGlzLmNsc0luYWN0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZSQxKHRoaXMucGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAncmVzaXplJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgncmVzaXplJyk7XG4gICAgICAgIH0gfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnbG9hZCBoYXNoY2hhbmdlIHBvcHN0YXRlJyxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRPZmZzZXQgIT09IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKCFsb2NhdGlvbi5oYXNoIHx8IHNjcm9sbFRvcCh3aW5kb3cpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRPZmZzZXQgPSBvZmZzZXQoJChsb2NhdGlvbi5oYXNoKSk7XG4gICAgICAgICAgICBjb25zdCBlbE9mZnNldCA9IG9mZnNldCh0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRml4ZWQgJiYgaW50ZXJzZWN0UmVjdCh0YXJnZXRPZmZzZXQsIGVsT2Zmc2V0KSkge1xuICAgICAgICAgICAgICBzY3JvbGxUb3AoXG4gICAgICAgICAgICAgIHdpbmRvdyxcbiAgICAgICAgICAgICAgdGFyZ2V0T2Zmc2V0LnRvcCAtXG4gICAgICAgICAgICAgIGVsT2Zmc2V0LmhlaWdodCAtXG4gICAgICAgICAgICAgIHRvUHgodGhpcy50YXJnZXRPZmZzZXQsICdoZWlnaHQnLCB0aGlzLnBsYWNlaG9sZGVyKSAtXG4gICAgICAgICAgICAgIHRvUHgodGhpcy5vZmZzZXQsICdoZWlnaHQnLCB0aGlzLnBsYWNlaG9sZGVyKSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIHVwZGF0ZTogW1xuICAgICAge1xuICAgICAgICByZWFkKF9yZWYyLCB0eXBlcykge2xldCB7IGhlaWdodDogaGVpZ2h0JDEsIG1hcmdpbiB9ID0gX3JlZjI7XG4gICAgICAgICAgdGhpcy5pbmFjdGl2ZSA9ICF0aGlzLm1hdGNoTWVkaWEgfHwgIWlzVmlzaWJsZSh0aGlzLiRlbCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pbmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGhpZGUgPSB0aGlzLmFjdGl2ZSAmJiB0eXBlcy5oYXMoJ3Jlc2l6ZScpO1xuICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICBjc3ModGhpcy5zZWxUYXJnZXQsICd0cmFuc2l0aW9uJywgJzBzJyk7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBoZWlnaHQkMSA9IG9mZnNldCh0aGlzLiRlbCkuaGVpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luID0gY3NzKHRoaXMuJGVsLCAnbWFyZ2luJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNzcyh0aGlzLnNlbFRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLmlzRml4ZWQgPyB0aGlzLnBsYWNlaG9sZGVyIDogdGhpcy4kZWw7XG4gICAgICAgICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gaGVpZ2h0KHdpbmRvdyk7XG5cbiAgICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgIGlmICh0aGlzLm92ZXJmbG93RmxpcCAmJiBoZWlnaHQkMSA+IHdpbmRvd0hlaWdodCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBvZmZzZXQkMSA9IHRvUHgodGhpcy5vZmZzZXQsICdoZWlnaHQnLCByZWZlcmVuY2VFbGVtZW50KTtcbiAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nICYmIChoZWlnaHQkMSA8IHdpbmRvd0hlaWdodCB8fCB0aGlzLm92ZXJmbG93RmxpcCkpIHtcbiAgICAgICAgICAgIG9mZnNldCQxICs9IHdpbmRvd0hlaWdodCAtIGhlaWdodCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gdGhpcy5vdmVyZmxvd0ZsaXAgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIE1hdGgubWF4KDAsIGhlaWdodCQxICsgb2Zmc2V0JDEgLSB3aW5kb3dIZWlnaHQpO1xuICAgICAgICAgIGNvbnN0IHRvcE9mZnNldCA9IG9mZnNldChyZWZlcmVuY2VFbGVtZW50KS50b3A7XG5cbiAgICAgICAgICBjb25zdCBzdGFydCA9XG4gICAgICAgICAgKHRoaXMuc3RhcnQgPT09IGZhbHNlID9cbiAgICAgICAgICB0b3BPZmZzZXQgOlxuICAgICAgICAgIHBhcnNlUHJvcCh0aGlzLnN0YXJ0LCB0aGlzLiRlbCwgdG9wT2Zmc2V0KSkgLSBvZmZzZXQkMTtcbiAgICAgICAgICBjb25zdCBlbmQgPVxuICAgICAgICAgIHRoaXMuZW5kID09PSBmYWxzZSA/XG4gICAgICAgICAgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQgLSB3aW5kb3dIZWlnaHQgOlxuICAgICAgICAgIHBhcnNlUHJvcCh0aGlzLmVuZCwgdGhpcy4kZWwsIHRvcE9mZnNldCArIGhlaWdodCQxLCB0cnVlKSAtXG4gICAgICAgICAgb2Zmc2V0KHRoaXMuJGVsKS5oZWlnaHQgK1xuICAgICAgICAgIG92ZXJmbG93IC1cbiAgICAgICAgICBvZmZzZXQkMTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0JDEsXG4gICAgICAgICAgICBvdmVyZmxvdyxcbiAgICAgICAgICAgIHRvcE9mZnNldCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0JDEsXG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICB3aWR0aDogZGltZW5zaW9ucyQxKHJlZmVyZW5jZUVsZW1lbnQpLndpZHRoLFxuICAgICAgICAgICAgdG9wOiBvZmZzZXRQb3NpdGlvbihyZWZlcmVuY2VFbGVtZW50KVswXSB9O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGUoX3JlZjMpIHtsZXQgeyBoZWlnaHQsIG1hcmdpbiB9ID0gX3JlZjM7XG4gICAgICAgICAgY29uc3QgeyBwbGFjZWhvbGRlciB9ID0gdGhpcztcblxuICAgICAgICAgIGNzcyhwbGFjZWhvbGRlciwgeyBoZWlnaHQsIG1hcmdpbiB9KTtcblxuICAgICAgICAgIGlmICghd2l0aGluKHBsYWNlaG9sZGVyLCBkb2N1bWVudCkpIHtcbiAgICAgICAgICAgIGFmdGVyKHRoaXMuJGVsLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICBwbGFjZWhvbGRlci5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBldmVudHM6IFsncmVzaXplJ10gfSxcblxuXG4gICAgICB7XG4gICAgICAgIHJlYWQoX3JlZjQpXG5cblxuXG5cblxuXG4gICAgICAgIHtsZXQgeyBzY3JvbGw6IHByZXZTY3JvbGwgPSAwLCBkaXI6IHByZXZEaXIgPSAnZG93bicsIG92ZXJmbG93LCBvdmVyZmxvd1Njcm9sbCA9IDAsIHN0YXJ0LCBlbmQgfSA9IF9yZWY0O1xuICAgICAgICAgIGNvbnN0IHNjcm9sbCA9IHNjcm9sbFRvcCh3aW5kb3cpO1xuICAgICAgICAgIGNvbnN0IGRpciA9IHByZXZTY3JvbGwgPD0gc2Nyb2xsID8gJ2Rvd24nIDogJ3VwJztcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICBwcmV2RGlyLFxuICAgICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgICAgcHJldlNjcm9sbCxcbiAgICAgICAgICAgIG9mZnNldFBhcmVudFRvcDogb2Zmc2V0KFxuICAgICAgICAgICAgKHRoaXMuaXNGaXhlZCA/IHRoaXMucGxhY2Vob2xkZXIgOiB0aGlzLiRlbCkub2Zmc2V0UGFyZW50KS5cbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIG92ZXJmbG93U2Nyb2xsOiBjbGFtcChcbiAgICAgICAgICAgIG92ZXJmbG93U2Nyb2xsICsgY2xhbXAoc2Nyb2xsLCBzdGFydCwgZW5kKSAtIGNsYW1wKHByZXZTY3JvbGwsIHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIG92ZXJmbG93KSB9O1xuXG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShkYXRhLCB0eXBlcykge1xuICAgICAgICAgIGNvbnN0IGlzU2Nyb2xsVXBkYXRlID0gdHlwZXMuaGFzKCdzY3JvbGwnKTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbml0VGltZXN0YW1wID0gMCxcbiAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgIHByZXZEaXIsXG4gICAgICAgICAgICBzY3JvbGwsXG4gICAgICAgICAgICBwcmV2U2Nyb2xsID0gMCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgdG9wT2Zmc2V0LFxuICAgICAgICAgICAgaGVpZ2h0IH0gPVxuICAgICAgICAgIGRhdGE7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgc2Nyb2xsIDwgMCB8fFxuICAgICAgICAgIHNjcm9sbCA9PT0gcHJldlNjcm9sbCAmJiBpc1Njcm9sbFVwZGF0ZSB8fFxuICAgICAgICAgIHRoaXMuc2hvd09uVXAgJiYgIWlzU2Nyb2xsVXBkYXRlICYmICF0aGlzLmlzRml4ZWQpXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgaWYgKG5vdyAtIGluaXRUaW1lc3RhbXAgPiAzMDAgfHwgZGlyICE9PSBwcmV2RGlyKSB7XG4gICAgICAgICAgICBkYXRhLmluaXRTY3JvbGwgPSBzY3JvbGw7XG4gICAgICAgICAgICBkYXRhLmluaXRUaW1lc3RhbXAgPSBub3c7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuc2hvd09uVXAgJiZcbiAgICAgICAgICAhdGhpcy5pc0ZpeGVkICYmXG4gICAgICAgICAgTWF0aC5hYnMoZGF0YS5pbml0U2Nyb2xsIC0gc2Nyb2xsKSA8PSAzMCAmJlxuICAgICAgICAgIE1hdGguYWJzKHByZXZTY3JvbGwgLSBzY3JvbGwpIDw9IDEwKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5pbmFjdGl2ZSB8fFxuICAgICAgICAgIHNjcm9sbCA8IHN0YXJ0IHx8XG4gICAgICAgICAgdGhpcy5zaG93T25VcCAmJiAoXG4gICAgICAgICAgc2Nyb2xsIDw9IHN0YXJ0IHx8XG4gICAgICAgICAgZGlyID09PSAnZG93bicgJiYgaXNTY3JvbGxVcGRhdGUgfHxcbiAgICAgICAgICBkaXIgPT09ICd1cCcgJiYgIXRoaXMuaXNGaXhlZCAmJiBzY3JvbGwgPD0gdG9wT2Zmc2V0ICsgaGVpZ2h0KSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGaXhlZCkge1xuICAgICAgICAgICAgICBpZiAoQW5pbWF0aW9uLmluUHJvZ3Jlc3ModGhpcy4kZWwpICYmIHRvcCA+IHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi5jYW5jZWwodGhpcy4kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlzRml4ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uICYmIHNjcm9sbCA+IHRvcE9mZnNldCkge1xuICAgICAgICAgICAgICBBbmltYXRpb24uY2FuY2VsKHRoaXMuJGVsKTtcbiAgICAgICAgICAgICAgQW5pbWF0aW9uLm91dCh0aGlzLiRlbCwgdGhpcy5hbmltYXRpb24pLnRoZW4oKCkgPT4gdGhpcy5oaWRlKCksIG5vb3ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFuaW1hdGlvbiAmJiBzY3JvbGwgPiB0b3BPZmZzZXQpIHtcbiAgICAgICAgICAgIEFuaW1hdGlvbi5jYW5jZWwodGhpcy4kZWwpO1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICBBbmltYXRpb24uaW4odGhpcy4kZWwsIHRoaXMuYW5pbWF0aW9uKS5jYXRjaChub29wKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnLCAnc2Nyb2xsJ10gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgdGhpcy5pc0ZpeGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZSgpIHtcbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRml4ZWQsIHRoaXMuY2xzQmVsb3cpO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgeyBwb3NpdGlvbjogJycsIHRvcDogJycsIHdpZHRoOiAnJyB9KTtcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlKCkge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIHNjcm9sbCA9IDAsXG4gICAgICAgICAgICBvdmVyZmxvdyxcbiAgICAgICAgICAgIG92ZXJmbG93U2Nyb2xsID0gMCxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgdG9wT2Zmc2V0LFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50VG9wIH0gPVxuICAgICAgICAgIHRoaXMuX2RhdGE7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gc3RhcnQgIT09IDAgfHwgc2Nyb2xsID4gc3RhcnQ7XG4gICAgICAgICAgbGV0IHBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgICAgICAgIGlmIChzY3JvbGwgPiBlbmQpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBlbmQgLSBvZmZzZXRQYXJlbnRUb3A7XG4gICAgICAgICAgICBwb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG92ZXJmbG93KSB7XG4gICAgICAgICAgICBvZmZzZXQgLT0gb3ZlcmZsb3dTY3JvbGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCB7XG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHRvcDogb2Zmc2V0ICsgXCJweFwiLFxuICAgICAgICAgICAgd2lkdGggfSk7XG5cblxuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKGFjdGl2ZSk7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzQmVsb3csIHNjcm9sbCA+IHRvcE9mZnNldCArIGhlaWdodCk7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRml4ZWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEFjdGl2ZShhY3RpdmUpIHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5hY3RpdmU7XG4gICAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgcmVwbGFjZUNsYXNzKHRoaXMuc2VsVGFyZ2V0LCB0aGlzLmNsc0luYWN0aXZlLCB0aGlzLmNsc0FjdGl2ZSk7XG4gICAgICAgICAgICBwcmV2ICE9PSBhY3RpdmUgJiYgdHJpZ2dlcih0aGlzLiRlbCwgJ2FjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlQ2xhc3ModGhpcy5zZWxUYXJnZXQsIHRoaXMuY2xzQWN0aXZlLCB0aGlzLmNsc0luYWN0aXZlKTtcbiAgICAgICAgICAgIHByZXYgIT09IGFjdGl2ZSAmJiB0cmlnZ2VyKHRoaXMuJGVsLCAnaW5hY3RpdmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcCh2YWx1ZSwgZWwsIHByb3BPZmZzZXQsIHBhZGRpbmcpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc051bWVyaWModmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5tYXRjaCgvXi0/XFxkLykpIHtcbiAgICAgICAgcmV0dXJuIHByb3BPZmZzZXQgKyB0b1B4KHZhbHVlLCAnaGVpZ2h0JywgZWwsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVmRWxlbWVudCA9IHZhbHVlID09PSB0cnVlID8gcGFyZW50KGVsKSA6IHF1ZXJ5KHZhbHVlLCBlbCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgb2Zmc2V0KHJlZkVsZW1lbnQpLmJvdHRvbSAtIChcbiAgICAgICAgICBwYWRkaW5nICYmIHJlZkVsZW1lbnQgJiYgd2l0aGluKGVsLCByZWZFbGVtZW50KSA/XG4gICAgICAgICAgdG9GbG9hdChjc3MocmVmRWxlbWVudCwgJ3BhZGRpbmdCb3R0b20nKSkgOlxuICAgICAgICAgIDApKTtcblxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvZXJjZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgU3dpdGNoZXIgPSB7XG4gICAgICBtaXhpbnM6IFtMYXp5bG9hZCwgU3dpcGUsIFRvZ2dsYWJsZV0sXG5cbiAgICAgIGFyZ3M6ICdjb25uZWN0JyxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29ubmVjdDogU3RyaW5nLFxuICAgICAgICB0b2dnbGU6IFN0cmluZyxcbiAgICAgICAgaXRlbU5hdjogU3RyaW5nLFxuICAgICAgICBhY3RpdmU6IE51bWJlciB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29ubmVjdDogJ34udWstc3dpdGNoZXInLFxuICAgICAgICB0b2dnbGU6ICc+ICogPiA6Zmlyc3QtY2hpbGQnLFxuICAgICAgICBpdGVtTmF2OiBmYWxzZSxcbiAgICAgICAgYWN0aXZlOiAwLFxuICAgICAgICBjbHM6ICd1ay1hY3RpdmUnLFxuICAgICAgICBhdHRySXRlbTogJ3VrLXN3aXRjaGVyLWl0ZW0nIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29ubmVjdHM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgY29ubmVjdCB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUFsbChjb25uZWN0LCAkZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaChjb25uZWN0cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3dpcGluZykge1xuICAgICAgICAgICAgICBjc3MoY29ubmVjdHMsICd0b3VjaC1hY3Rpb24nLCAncGFuLXkgcGluY2gtem9vbScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdHMuZm9yRWFjaCgoZWwpID0+XG4gICAgICAgICAgICBjaGlsZHJlbihlbCkuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHRvZ2dsZUNsYXNzKGNoaWxkLCB0aGlzLmNscywgaSA9PT0gaW5kZXgpKSk7XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0sXG5cblxuICAgICAgICB0b2dnbGVzOiB7XG4gICAgICAgICAgZ2V0KF9yZWYyLCAkZWwpIHtsZXQgeyB0b2dnbGUgfSA9IF9yZWYyO1xuICAgICAgICAgICAgcmV0dXJuICQkKHRvZ2dsZSwgJGVsKS5maWx0ZXIoXG4gICAgICAgICAgICAoZWwpID0+ICFtYXRjaGVzKGVsLCAnLnVrLWRpc2FibGVkICosIC51ay1kaXNhYmxlZCwgW2Rpc2FibGVkXScpKTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCh0b2dnbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmluZGV4KCk7XG4gICAgICAgICAgICB0aGlzLnNob3cofmFjdGl2ZSA/IGFjdGl2ZSA6IHRvZ2dsZXNbdGhpcy5hY3RpdmVdIHx8IHRvZ2dsZXNbMF0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWUgfSxcblxuXG4gICAgICAgIGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbih0aGlzLiRlbCkuZmlsdGVyKChjaGlsZCkgPT5cbiAgICAgICAgICB0aGlzLnRvZ2dsZXMuc29tZSgodG9nZ2xlKSA9PiB3aXRoaW4odG9nZ2xlLCBjaGlsZCkpKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHN3aXBlVGFyZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RzO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmxhenlsb2FkKHRoaXMuJGVsLCB0aGlzLmNvbm5lY3RzKTtcblxuICAgICAgICAvLyBjaGVjayBmb3IgY29ubmVjdHNcbiAgICAgICAgcmVhZHkoKCkgPT4gdGhpcy4kZW1pdCgpKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93KGUuY3VycmVudCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdHMuY29uY2F0KHRoaXMuaXRlbU5hdiA/IHF1ZXJ5QWxsKHRoaXMuaXRlbU5hdiwgdGhpcy4kZWwpIDogW10pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiBcIltcIiArIHRoaXMuYXR0ckl0ZW0gKyBcIl0sW2RhdGEtXCIgKyB0aGlzLmF0dHJJdGVtICsgXCJdXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvdyhkYXRhKGUuY3VycmVudCwgdGhpcy5hdHRySXRlbSkpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnc3dpcGVSaWdodCBzd2lwZUxlZnQnLFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zd2lwaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjMpIHtsZXQgeyB0eXBlIH0gPSBfcmVmMztcbiAgICAgICAgICB0aGlzLnNob3coZW5kc1dpdGgodHlwZSwgJ0xlZnQnKSA/ICduZXh0JyA6ICdwcmV2aW91cycpO1xuICAgICAgICB9IH1dLFxuXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBpbmRleCgpIHtcbiAgICAgICAgICByZXR1cm4gZmluZEluZGV4KHRoaXMuY2hpbGRyZW4sIChlbCkgPT4gaGFzQ2xhc3MoZWwsIHRoaXMuY2xzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvdyhpdGVtKSB7XG4gICAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gZ2V0SW5kZXgoaXRlbSwgdGhpcy50b2dnbGVzLCBwcmV2KTtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSBnZXRJbmRleCh0aGlzLmNoaWxkcmVuW25leHRdLCBjaGlsZHJlbih0aGlzLiRlbCkpO1xuICAgICAgICAgIGNoaWxkcmVuKHRoaXMuJGVsKS5mb3JFYWNoKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY2hpbGQsIHRoaXMuY2xzLCBhY3RpdmUgPT09IGkpO1xuICAgICAgICAgICAgYXR0cih0aGlzLnRvZ2dsZXNbaV0sICdhcmlhLWV4cGFuZGVkJywgYWN0aXZlID09PSBpKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IGFuaW1hdGUgPSBwcmV2ID49IDAgJiYgcHJldiAhPT0gbmV4dDtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RzLmZvckVhY2goYXN5bmMgKF9yZWY0KSA9PiB7bGV0IHsgY2hpbGRyZW4gfSA9IF9yZWY0O1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50b2dnbGVFbGVtZW50KFxuICAgICAgICAgICAgdG9Ob2RlcyhjaGlsZHJlbikuZmlsdGVyKChjaGlsZCkgPT4gaGFzQ2xhc3MoY2hpbGQsIHRoaXMuY2xzKSksXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGFuaW1hdGUpO1xuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQoY2hpbGRyZW5bYWN0aXZlXSwgdHJ1ZSwgYW5pbWF0ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIHRhYiA9IHtcbiAgICAgIG1peGluczogW0NsYXNzXSxcblxuICAgICAgZXh0ZW5kczogU3dpdGNoZXIsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG1lZGlhOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBtZWRpYTogOTYwLFxuICAgICAgICBhdHRySXRlbTogJ3VrLXRhYi1pdGVtJyB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgY29uc3QgY2xzID0gaGFzQ2xhc3ModGhpcy4kZWwsICd1ay10YWItbGVmdCcpID9cbiAgICAgICAgJ3VrLXRhYi1sZWZ0JyA6XG4gICAgICAgIGhhc0NsYXNzKHRoaXMuJGVsLCAndWstdGFiLXJpZ2h0JykgP1xuICAgICAgICAndWstdGFiLXJpZ2h0JyA6XG4gICAgICAgIGZhbHNlO1xuXG4gICAgICAgIGlmIChjbHMpIHtcbiAgICAgICAgICB0aGlzLiRjcmVhdGUoJ3RvZ2dsZScsIHRoaXMuJGVsLCB7IGNscywgbW9kZTogJ21lZGlhJywgbWVkaWE6IHRoaXMubWVkaWEgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gfTtcblxuICAgIGNvbnN0IEtFWV9TUEFDRSA9IDMyO1xuXG4gICAgdmFyIHRvZ2dsZSA9IHtcbiAgICAgIG1peGluczogW0xhenlsb2FkLCBNZWRpYSwgVG9nZ2xhYmxlXSxcblxuICAgICAgYXJnczogJ3RhcmdldCcsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGhyZWY6IFN0cmluZyxcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICBtb2RlOiAnbGlzdCcsXG4gICAgICAgIHF1ZXVlZDogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaHJlZjogZmFsc2UsXG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIG1vZGU6ICdjbGljaycsXG4gICAgICAgIHF1ZXVlZDogdHJ1ZSB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgIGdldChfcmVmLCAkZWwpIHtsZXQgeyBocmVmLCB0YXJnZXQgfSA9IF9yZWY7XG4gICAgICAgICAgICB0YXJnZXQgPSBxdWVyeUFsbCh0YXJnZXQgfHwgaHJlZiwgJGVsKTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQubGVuZ3RoICYmIHRhcmdldCB8fCBbJGVsXTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFyaWEoKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW1tZWRpYXRlOiB0cnVlIH0gfSxcblxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKCFpbmNsdWRlcyh0aGlzLm1vZGUsICdtZWRpYScpICYmICFpc0ZvY3VzYWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICBhdHRyKHRoaXMuJGVsLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXp5bG9hZCh0aGlzLiRlbCwgdGhpcy50YXJnZXQpO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciB0YXJnZXRcbiAgICAgICAgcmVhZHkoKCkgPT4gdGhpcy4kZW1pdCgpKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyRG93bixcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ2hvdmVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKCFpc1RvdWNoKGUpIHx8IHRoaXMuX3Nob3dTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENsaWNraW5nIGEgYnV0dG9uIGRvZXMgbm90IGdpdmUgaXQgZm9jdXMgb24gYWxsIGJyb3dzZXJzIGFuZCBwbGF0Zm9ybXNcbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvYnV0dG9uI2NsaWNraW5nX2FuZF9mb2N1c1xuICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdmb2N1cycpO1xuICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgcG9pbnRlckRvd24sXG4gICAgICAgICAgKCkgPT4gdHJpZ2dlcih0aGlzLiRlbCwgJ2JsdXInKSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIChlKSA9PiAhd2l0aGluKGUudGFyZ2V0LCB0aGlzLiRlbCkpO1xuXG5cbiAgICAgICAgICAvLyBQcmV2ZW50IGluaXRpYWwgY2xpY2sgdG8gcHJldmVudCBkb3VibGUgdG9nZ2xlIHRocm91Z2ggZm9jdXMgKyBjbGlja1xuICAgICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLm1vZGUsICdjbGljaycpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50Q2xpY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogcG9pbnRlckVudGVyICsgXCIgXCIgKyBwb2ludGVyTGVhdmUgKyBcIiBmb2N1cyBibHVyXCIsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdob3ZlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmIChpc1RvdWNoKGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc2hvdyA9IGluY2x1ZGVzKFtwb2ludGVyRW50ZXIsICdmb2N1cyddLCBlLnR5cGUpO1xuICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gYXR0cih0aGlzLiRlbCwgJ2FyaWEtZXhwYW5kZWQnKTtcblxuICAgICAgICAgIC8vIFNraXAgaGlkZSBpZiBzdGlsbCBob3ZlcmVkIG9yIGZvY3VzZWRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXNob3cgJiYgKFxuICAgICAgICAgIGUudHlwZSA9PT0gcG9pbnRlckxlYXZlICYmIG1hdGNoZXModGhpcy4kZWwsICc6Zm9jdXMnKSB8fFxuICAgICAgICAgIGUudHlwZSA9PT0gJ2JsdXInICYmIG1hdGNoZXModGhpcy4kZWwsICc6aG92ZXInKSkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNraXAgaWYgc3RhdGUgZG9lcyBub3QgY2hhbmdlIGUuZy4gaG92ZXIgKyBmb2N1cyByZWNlaXZlZFxuICAgICAgICAgIGlmICh0aGlzLl9zaG93U3RhdGUgJiYgc2hvdyAmJiBleHBhbmRlZCAhPT0gdGhpcy5fc2hvd1N0YXRlKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgcmVzZXQgaWYgc3RhdGUgaGFzIGNoYW5nZWQgdGhyb3VnaCBjbGlja1xuICAgICAgICAgICAgaWYgKCFzaG93KSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Nob3dTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc2hvd1N0YXRlID0gc2hvdyA/IGV4cGFuZGVkIDogbnVsbDtcblxuICAgICAgICAgIHRoaXMudG9nZ2xlKFwidG9nZ2xlXCIgKyAoc2hvdyA/ICdzaG93JyA6ICdoaWRlJykpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAna2V5ZG93bicsXG5cbiAgICAgICAgZmlsdGVyKCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLm1vZGUsICdjbGljaycpICYmICFpc1RhZyh0aGlzLiRlbCwgJ2lucHV0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZX1NQQUNFKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLiRlbC5jbGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBsZXQgbGluaztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgY2xvc2VzdChlLnRhcmdldCwgJ2FbaHJlZj1cIiNcIl0sIGFbaHJlZj1cIlwiXScpIHx8XG4gICAgICAgICAgKGxpbmsgPSBjbG9zZXN0KGUudGFyZ2V0LCAnYVtocmVmXScpKSAmJiAoXG4gICAgICAgICAgYXR0cih0aGlzLiRlbCwgJ2FyaWEtZXhwYW5kZWQnKSAhPT0gJ3RydWUnIHx8XG4gICAgICAgICAgbGluay5oYXNoICYmIG1hdGNoZXModGhpcy50YXJnZXQsIGxpbmsuaGFzaCkpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5fcHJldmVudENsaWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJldmVudENsaWNrID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzKHRoaXMubW9kZSwgJ2NsaWNrJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAndG9nZ2xlZCcsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlLCB0b2dnbGVkKSB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLnRhcmdldFswXSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBcmlhKHRvZ2dsZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ21lZGlhY2hhbmdlJyxcblxuICAgICAgICBmaWx0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMubW9kZSwgJ21lZGlhJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSwgbWVkaWFPYmopIHtcbiAgICAgICAgICBpZiAobWVkaWFPYmoubWF0Y2hlcyBeIHRoaXMuaXNUb2dnbGVkKHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIHRvZ2dsZSh0eXBlKSB7XG4gICAgICAgICAgaWYgKCF0cmlnZ2VyKHRoaXMudGFyZ2V0LCB0eXBlIHx8ICd0b2dnbGUnLCBbdGhpc10pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLnRhcmdldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbGVhdmluZyA9IHRoaXMudGFyZ2V0LmZpbHRlcigoZWwpID0+IGhhc0NsYXNzKGVsLCB0aGlzLmNsc0xlYXZlKSk7XG5cbiAgICAgICAgICBpZiAobGVhdmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgaXNMZWF2aW5nID0gaW5jbHVkZXMobGVhdmluZywgZWwpO1xuICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUVsZW1lbnQoZWwsIGlzTGVhdmluZywgaXNMZWF2aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0b2dnbGVkID0gdGhpcy50YXJnZXQuZmlsdGVyKHRoaXMuaXNUb2dnbGVkKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQodG9nZ2xlZCwgZmFsc2UpO1xuICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudChcbiAgICAgICAgICB0aGlzLnRhcmdldC5maWx0ZXIoKGVsKSA9PiAhaW5jbHVkZXModG9nZ2xlZCwgZWwpKSxcbiAgICAgICAgICB0cnVlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUFyaWEodG9nZ2xlZCkge1xuICAgICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLm1vZGUsICdtZWRpYScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0cihcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCcsXG4gICAgICAgICAgaXNCb29sZWFuKHRvZ2dsZWQpID8gdG9nZ2xlZCA6IHRoaXMuaXNUb2dnbGVkKHRoaXMudGFyZ2V0KSk7XG5cbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgY29tcG9uZW50cyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIEFjY29yZGlvbjogQWNjb3JkaW9uLFxuICAgICAgICBBbGVydDogYWxlcnQsXG4gICAgICAgIENvdmVyOiBjb3ZlcixcbiAgICAgICAgRHJvcDogZHJvcCxcbiAgICAgICAgRHJvcGRvd246IGRyb3AsXG4gICAgICAgIEZvcm1DdXN0b206IGZvcm1DdXN0b20sXG4gICAgICAgIEdyaWQ6IGdyaWQsXG4gICAgICAgIEhlaWdodE1hdGNoOiBoZWlnaHRNYXRjaCxcbiAgICAgICAgSGVpZ2h0Vmlld3BvcnQ6IGhlaWdodFZpZXdwb3J0LFxuICAgICAgICBJY29uOiBJY29uLFxuICAgICAgICBJbWc6IGltZyxcbiAgICAgICAgTGVhZGVyOiBsZWFkZXIsXG4gICAgICAgIE1hcmdpbjogTWFyZ2luLFxuICAgICAgICBNb2RhbDogbW9kYWwsXG4gICAgICAgIE5hdjogbmF2LFxuICAgICAgICBOYXZiYXI6IG5hdmJhcixcbiAgICAgICAgT2ZmY2FudmFzOiBvZmZjYW52YXMsXG4gICAgICAgIE92ZXJmbG93QXV0bzogb3ZlcmZsb3dBdXRvLFxuICAgICAgICBSZXNwb25zaXZlOiByZXNwb25zaXZlLFxuICAgICAgICBTY3JvbGw6IHNjcm9sbCxcbiAgICAgICAgU2Nyb2xsc3B5OiBzY3JvbGxzcHksXG4gICAgICAgIFNjcm9sbHNweU5hdjogc2Nyb2xsc3B5TmF2LFxuICAgICAgICBTdGlja3k6IHN0aWNreSxcbiAgICAgICAgU3ZnOiBTVkcsXG4gICAgICAgIFN3aXRjaGVyOiBTd2l0Y2hlcixcbiAgICAgICAgVGFiOiB0YWIsXG4gICAgICAgIFRvZ2dsZTogdG9nZ2xlLFxuICAgICAgICBWaWRlbzogVmlkZW8sXG4gICAgICAgIENsb3NlOiBDbG9zZSxcbiAgICAgICAgU3Bpbm5lcjogU3Bpbm5lcixcbiAgICAgICAgU2xpZGVuYXZOZXh0OiBTbGlkZW5hdixcbiAgICAgICAgU2xpZGVuYXZQcmV2aW91czogU2xpZGVuYXYsXG4gICAgICAgIFNlYXJjaEljb246IFNlYXJjaCxcbiAgICAgICAgTWFya2VyOiBJY29uQ29tcG9uZW50LFxuICAgICAgICBOYXZiYXJUb2dnbGVJY29uOiBJY29uQ29tcG9uZW50LFxuICAgICAgICBPdmVybGF5SWNvbjogSWNvbkNvbXBvbmVudCxcbiAgICAgICAgUGFnaW5hdGlvbk5leHQ6IEljb25Db21wb25lbnQsXG4gICAgICAgIFBhZ2luYXRpb25QcmV2aW91czogSWNvbkNvbXBvbmVudCxcbiAgICAgICAgVG90b3A6IEljb25Db21wb25lbnRcbiAgICB9KTtcblxuICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudHNcbiAgICBlYWNoKGNvbXBvbmVudHMkMSwgKGNvbXBvbmVudCwgbmFtZSkgPT4gVUlraXQuY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkpO1xuXG4gICAgYm9vdChVSWtpdCk7XG5cbiAgICBjb25zdCB1bml0cyA9IFsnZGF5cycsICdob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXTtcblxuICAgIHZhciBjb3VudGRvd24gPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzc10sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRhdGU6IFN0cmluZyxcbiAgICAgICAgY2xzV3JhcHBlcjogU3RyaW5nIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRlOiAnJyxcbiAgICAgICAgY2xzV3JhcHBlcjogJy51ay1jb3VudGRvd24tJXVuaXQlJyB9LFxuXG5cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5kYXRlID0gRGF0ZS5wYXJzZSh0aGlzLiRwcm9wcy5kYXRlKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAndmlzaWJpbGl0eWNoYW5nZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMudXBkYXRlLCAxMDAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdG9wKCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlKCkge1xuICAgICAgICAgIGNvbnN0IHRpbWVzcGFuID0gZ2V0VGltZVNwYW4odGhpcy5kYXRlKTtcblxuICAgICAgICAgIGlmICghdGhpcy5kYXRlIHx8IHRpbWVzcGFuLnRvdGFsIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgICAgICB0aW1lc3Bhbi5kYXlzID0gdGltZXNwYW4uaG91cnMgPSB0aW1lc3Bhbi5taW51dGVzID0gdGltZXNwYW4uc2Vjb25kcyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChjb25zdCB1bml0IG9mIHVuaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9ICQodGhpcy5jbHNXcmFwcGVyLnJlcGxhY2UoJyV1bml0JScsIHVuaXQpLCB0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBkaWdpdHMgPSBTdHJpbmcoTWF0aC50cnVuYyh0aW1lc3Bhblt1bml0XSkpO1xuXG4gICAgICAgICAgICBkaWdpdHMgPSBkaWdpdHMubGVuZ3RoIDwgMiA/IFwiMFwiICsgZGlnaXRzIDogZGlnaXRzO1xuXG4gICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IGRpZ2l0cykge1xuICAgICAgICAgICAgICBkaWdpdHMgPSBkaWdpdHMuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgIGlmIChkaWdpdHMubGVuZ3RoICE9PSBlbC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBodG1sKGVsLCBkaWdpdHMubWFwKCgpID0+ICc8c3Bhbj48L3NwYW4+Jykuam9pbignJykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGlnaXRzLmZvckVhY2goKGRpZ2l0LCBpKSA9PiBlbC5jaGlsZHJlbltpXS50ZXh0Q29udGVudCA9IGRpZ2l0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldFRpbWVTcGFuKGRhdGUpIHtcbiAgICAgIGNvbnN0IHRvdGFsID0gZGF0ZSAtIERhdGUubm93KCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvdGFsLFxuICAgICAgICBzZWNvbmRzOiB0b3RhbCAvIDEwMDAgJSA2MCxcbiAgICAgICAgbWludXRlczogdG90YWwgLyAxMDAwIC8gNjAgJSA2MCxcbiAgICAgICAgaG91cnM6IHRvdGFsIC8gMTAwMCAvIDYwIC8gNjAgJSAyNCxcbiAgICAgICAgZGF5czogdG90YWwgLyAxMDAwIC8gNjAgLyA2MCAvIDI0IH07XG5cbiAgICB9XG5cbiAgICBjb25zdCBjbHNMZWF2ZSA9ICd1ay10cmFuc2l0aW9uLWxlYXZlJztcbiAgICBjb25zdCBjbHNFbnRlciA9ICd1ay10cmFuc2l0aW9uLWVudGVyJztcblxuICAgIGZ1bmN0aW9uIGZhZGUoYWN0aW9uLCB0YXJnZXQsIGR1cmF0aW9uLCBzdGFnZ2VyKSB7aWYgKHN0YWdnZXIgPT09IHZvaWQgMCkge3N0YWdnZXIgPSAwO31cbiAgICAgIGNvbnN0IGluZGV4ID0gdHJhbnNpdGlvbkluZGV4KHRhcmdldCwgdHJ1ZSk7XG4gICAgICBjb25zdCBwcm9wc0luID0geyBvcGFjaXR5OiAxIH07XG4gICAgICBjb25zdCBwcm9wc091dCA9IHsgb3BhY2l0eTogMCB9O1xuXG4gICAgICBjb25zdCB3cmFwSW5kZXhGbiA9IChmbikgPT4gKCkgPT4gaW5kZXggPT09IHRyYW5zaXRpb25JbmRleCh0YXJnZXQpID8gZm4oKSA6IFByb21pc2UucmVqZWN0KCk7XG5cbiAgICAgIGNvbnN0IGxlYXZlRm4gPSB3cmFwSW5kZXhGbigoKSA9PiB7XG4gICAgICAgIGFkZENsYXNzKHRhcmdldCwgY2xzTGVhdmUpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgZ2V0VHJhbnNpdGlvbk5vZGVzKHRhcmdldCkubWFwKFxuICAgICAgICAoY2hpbGQsIGkpID0+XG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PlxuICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PlxuICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KGNoaWxkLCBwcm9wc091dCwgZHVyYXRpb24gLyAyLCAnZWFzZScpLnRoZW4oXG4gICAgICAgIHJlc29sdmUpLFxuXG4gICAgICAgIGkgKiBzdGFnZ2VyKSkpKS5cblxuXG5cbiAgICAgICAgdGhlbigoKSA9PiByZW1vdmVDbGFzcyh0YXJnZXQsIGNsc0xlYXZlKSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZW50ZXJGbiA9IHdyYXBJbmRleEZuKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gaGVpZ2h0KHRhcmdldCk7XG5cbiAgICAgICAgYWRkQ2xhc3ModGFyZ2V0LCBjbHNFbnRlcik7XG4gICAgICAgIGFjdGlvbigpO1xuXG4gICAgICAgIGNzcyhjaGlsZHJlbih0YXJnZXQpLCB7IG9wYWNpdHk6IDAgfSk7XG5cbiAgICAgICAgLy8gRW5zdXJlIFVJa2l0IHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlcyA9IGNoaWxkcmVuKHRhcmdldCk7XG4gICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gaGVpZ2h0KHRhcmdldCk7XG5cbiAgICAgICAgICAvLyBFbnN1cmUgR3JpZCBjZWxscyBkbyBub3Qgc3RyZXRjaCB3aGVuIGhlaWdodCBpcyBhcHBsaWVkXG4gICAgICAgICAgY3NzKHRhcmdldCwgJ2FsaWduQ29udGVudCcsICdmbGV4LXN0YXJ0Jyk7XG4gICAgICAgICAgaGVpZ2h0KHRhcmdldCwgb2xkSGVpZ2h0KTtcblxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25Ob2RlcyA9IGdldFRyYW5zaXRpb25Ob2Rlcyh0YXJnZXQpO1xuICAgICAgICAgIGNzcyhub2RlcywgcHJvcHNPdXQpO1xuXG4gICAgICAgICAgY29uc3QgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uTm9kZXMubWFwKFxuICAgICAgICAgIChjaGlsZCwgaSkgPT5cbiAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICgpID0+XG4gICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChjaGlsZCwgcHJvcHNJbiwgZHVyYXRpb24gLyAyLCAnZWFzZScpLnRoZW4oXG4gICAgICAgICAgcmVzb2x2ZSksXG5cbiAgICAgICAgICBpICogc3RhZ2dlcikpKTtcblxuXG5cblxuICAgICAgICAgIGlmIChvbGRIZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnMucHVzaChcbiAgICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB7IGhlaWdodDogbmV3SGVpZ2h0IH0sXG4gICAgICAgICAgICBkdXJhdGlvbiAvIDIgKyB0cmFuc2l0aW9uTm9kZXMubGVuZ3RoICogc3RhZ2dlcixcbiAgICAgICAgICAgICdlYXNlJykpO1xuXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBQcm9taXNlLmFsbCh0cmFuc2l0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyh0YXJnZXQsIGNsc0VudGVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdHJhbnNpdGlvbkluZGV4KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgY3NzKHRhcmdldCwgeyBoZWlnaHQ6ICcnLCBhbGlnbkNvbnRlbnQ6ICcnIH0pO1xuICAgICAgICAgICAgICBjc3Mobm9kZXMsIHsgb3BhY2l0eTogJycgfSk7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQuZGF0YXNldC50cmFuc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaGFzQ2xhc3ModGFyZ2V0LCBjbHNMZWF2ZSkgP1xuICAgICAgd2FpdFRyYW5zaXRpb25lbmQodGFyZ2V0KS50aGVuKGVudGVyRm4pIDpcbiAgICAgIGhhc0NsYXNzKHRhcmdldCwgY2xzRW50ZXIpID9cbiAgICAgIHdhaXRUcmFuc2l0aW9uZW5kKHRhcmdldCkudGhlbihsZWF2ZUZuKS50aGVuKGVudGVyRm4pIDpcbiAgICAgIGxlYXZlRm4oKS50aGVuKGVudGVyRm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25JbmRleCh0YXJnZXQsIG5leHQpIHtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIHRhcmdldC5kYXRhc2V0LnRyYW5zaXRpb24gPSAxICsgdHJhbnNpdGlvbkluZGV4KHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b051bWJlcih0YXJnZXQuZGF0YXNldC50cmFuc2l0aW9uKSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhaXRUcmFuc2l0aW9uZW5kKHRhcmdldCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgY2hpbGRyZW4odGFyZ2V0KS5cbiAgICAgIGZpbHRlcihUcmFuc2l0aW9uLmluUHJvZ3Jlc3MpLlxuICAgICAgbWFwKFxuICAgICAgKGVsKSA9PlxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IG9uY2UoZWwsICd0cmFuc2l0aW9uZW5kIHRyYW5zaXRpb25jYW5jZWxlZCcsIHJlc29sdmUpKSkpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uTm9kZXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0Um93cyhjaGlsZHJlbih0YXJnZXQpKS5yZWR1Y2UoXG4gICAgICAobm9kZXMsIHJvdykgPT5cbiAgICAgIG5vZGVzLmNvbmNhdChcbiAgICAgIHNvcnRCeSQxKFxuICAgICAgcm93LmZpbHRlcigoZWwpID0+IGlzSW5WaWV3KGVsKSksXG4gICAgICAnb2Zmc2V0TGVmdCcpKSxcblxuXG4gICAgICBbXSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbGlkZSAoYWN0aW9uLCB0YXJnZXQsIGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBsZXQgbm9kZXMgPSBjaGlsZHJlbih0YXJnZXQpO1xuXG4gICAgICAgIC8vIEdldCBjdXJyZW50IHN0YXRlXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9wcyA9IG5vZGVzLm1hcCgoZWwpID0+IGdldFByb3BzKGVsLCB0cnVlKSk7XG4gICAgICAgIGNvbnN0IHRhcmdldFByb3BzID0gY3NzKHRhcmdldCwgWydoZWlnaHQnLCAncGFkZGluZyddKTtcblxuICAgICAgICAvLyBDYW5jZWwgcHJldmlvdXMgYW5pbWF0aW9uc1xuICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbCh0YXJnZXQpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKFRyYW5zaXRpb24uY2FuY2VsKTtcbiAgICAgICAgcmVzZXQodGFyZ2V0KTtcblxuICAgICAgICAvLyBBZGRpbmcsIHNvcnRpbmcsIHJlbW92aW5nIG5vZGVzXG4gICAgICAgIGFjdGlvbigpO1xuXG4gICAgICAgIC8vIEZpbmQgbmV3IG5vZGVzXG4gICAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNoaWxkcmVuKHRhcmdldCkuZmlsdGVyKChlbCkgPT4gIWluY2x1ZGVzKG5vZGVzLCBlbCkpKTtcblxuICAgICAgICAvLyBXYWl0IGZvciB1cGRhdGUgdG8gcHJvcGFnYXRlXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIC8vIEZvcmNlIHVwZGF0ZVxuICAgICAgICAgIGZhc3Rkb20uZmx1c2goKTtcblxuICAgICAgICAgIC8vIEdldCBuZXcgc3RhdGVcbiAgICAgICAgICBjb25zdCB0YXJnZXRQcm9wc1RvID0gY3NzKHRhcmdldCwgWydoZWlnaHQnLCAncGFkZGluZyddKTtcbiAgICAgICAgICBjb25zdCBbcHJvcHNUbywgcHJvcHNGcm9tXSA9IGdldFRyYW5zaXRpb25Qcm9wcyh0YXJnZXQsIG5vZGVzLCBjdXJyZW50UHJvcHMpO1xuXG4gICAgICAgICAgLy8gUmVzZXQgdG8gcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICBub2Rlcy5mb3JFYWNoKChlbCwgaSkgPT4gcHJvcHNGcm9tW2ldICYmIGNzcyhlbCwgcHJvcHNGcm9tW2ldKSk7XG4gICAgICAgICAgY3NzKHRhcmdldCwgeyBkaXNwbGF5OiAnYmxvY2snLCAuLi50YXJnZXRQcm9wcyB9KTtcblxuICAgICAgICAgIC8vIFN0YXJ0IHRyYW5zaXRpb25zIG9uIG5leHQgZnJhbWVcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbnMgPSBub2Rlcy5cbiAgICAgICAgICAgIG1hcChcbiAgICAgICAgICAgIChlbCwgaSkgPT5cbiAgICAgICAgICAgIHBhcmVudChlbCkgPT09IHRhcmdldCAmJlxuICAgICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChlbCwgcHJvcHNUb1tpXSwgZHVyYXRpb24sICdlYXNlJykpLlxuXG4gICAgICAgICAgICBjb25jYXQoVHJhbnNpdGlvbi5zdGFydCh0YXJnZXQsIHRhcmdldFByb3BzVG8sIGR1cmF0aW9uLCAnZWFzZScpKTtcblxuICAgICAgICAgICAgUHJvbWlzZS5hbGwodHJhbnNpdGlvbnMpLlxuICAgICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goXG4gICAgICAgICAgICAgIChlbCwgaSkgPT5cbiAgICAgICAgICAgICAgcGFyZW50KGVsKSA9PT0gdGFyZ2V0ICYmXG4gICAgICAgICAgICAgIGNzcyhlbCwgJ2Rpc3BsYXknLCBwcm9wc1RvW2ldLm9wYWNpdHkgPT09IDAgPyAnbm9uZScgOiAnJykpO1xuXG4gICAgICAgICAgICAgIHJlc2V0KHRhcmdldCk7XG4gICAgICAgICAgICB9LCBub29wKS5cbiAgICAgICAgICAgIHRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJvcHMoZWwsIG9wYWNpdHkpIHtcbiAgICAgIGNvbnN0IHpJbmRleCA9IGNzcyhlbCwgJ3pJbmRleCcpO1xuXG4gICAgICByZXR1cm4gaXNWaXNpYmxlKGVsKSA/XG4gICAgICB7XG4gICAgICAgIGRpc3BsYXk6ICcnLFxuICAgICAgICBvcGFjaXR5OiBvcGFjaXR5ID8gY3NzKGVsLCAnb3BhY2l0eScpIDogJzAnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB6SW5kZXg6IHpJbmRleCA9PT0gJ2F1dG8nID8gaW5kZXgoZWwpIDogekluZGV4LFxuICAgICAgICAuLi5nZXRQb3NpdGlvbldpdGhNYXJnaW4oZWwpIH0gOlxuXG4gICAgICBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uUHJvcHModGFyZ2V0LCBub2RlcywgY3VycmVudFByb3BzKSB7XG4gICAgICBjb25zdCBwcm9wc1RvID0gbm9kZXMubWFwKChlbCwgaSkgPT5cbiAgICAgIHBhcmVudChlbCkgJiYgaSBpbiBjdXJyZW50UHJvcHMgP1xuICAgICAgY3VycmVudFByb3BzW2ldID9cbiAgICAgIGlzVmlzaWJsZShlbCkgP1xuICAgICAgZ2V0UG9zaXRpb25XaXRoTWFyZ2luKGVsKSA6XG4gICAgICB7IG9wYWNpdHk6IDAgfSA6XG4gICAgICB7IG9wYWNpdHk6IGlzVmlzaWJsZShlbCkgPyAxIDogMCB9IDpcbiAgICAgIGZhbHNlKTtcblxuXG4gICAgICBjb25zdCBwcm9wc0Zyb20gPSBwcm9wc1RvLm1hcCgocHJvcHMsIGkpID0+IHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBhcmVudChub2Rlc1tpXSkgPT09IHRhcmdldCAmJiAoY3VycmVudFByb3BzW2ldIHx8IGdldFByb3BzKG5vZGVzW2ldKSk7XG5cbiAgICAgICAgaWYgKCFmcm9tKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgIGRlbGV0ZSBmcm9tLm9wYWNpdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoISgnb3BhY2l0eScgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgY29uc3QgeyBvcGFjaXR5IH0gPSBmcm9tO1xuXG4gICAgICAgICAgaWYgKG9wYWNpdHkgJSAxKSB7XG4gICAgICAgICAgICBwcm9wcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGZyb20ub3BhY2l0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gW3Byb3BzVG8sIHByb3BzRnJvbV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXQoZWwpIHtcbiAgICAgIGNzcyhlbC5jaGlsZHJlbiwge1xuICAgICAgICBoZWlnaHQ6ICcnLFxuICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgb3BhY2l0eTogJycsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICcnLFxuICAgICAgICBwb3NpdGlvbjogJycsXG4gICAgICAgIHRvcDogJycsXG4gICAgICAgIG1hcmdpblRvcDogJycsXG4gICAgICAgIG1hcmdpbkxlZnQ6ICcnLFxuICAgICAgICB0cmFuc2Zvcm06ICcnLFxuICAgICAgICB3aWR0aDogJycsXG4gICAgICAgIHpJbmRleDogJycgfSk7XG5cbiAgICAgIGNzcyhlbCwgeyBoZWlnaHQ6ICcnLCBkaXNwbGF5OiAnJywgcGFkZGluZzogJycgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25XaXRoTWFyZ2luKGVsKSB7XG4gICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IG9mZnNldChlbCk7XG4gICAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gcG9zaXRpb24oZWwpO1xuICAgICAgY29uc3QgeyBtYXJnaW5MZWZ0LCBtYXJnaW5Ub3AgfSA9IGNzcyhlbCwgWydtYXJnaW5Ub3AnLCAnbWFyZ2luTGVmdCddKTtcblxuICAgICAgcmV0dXJuIHsgdG9wLCBsZWZ0LCBoZWlnaHQsIHdpZHRoLCBtYXJnaW5MZWZ0LCBtYXJnaW5Ub3AsIHRyYW5zZm9ybTogJycgfTtcbiAgICB9XG5cbiAgICB2YXIgQW5pbWF0ZSA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIsXG4gICAgICAgIGFuaW1hdGlvbjogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgYW5pbWF0aW9uOiAnc2xpZGUnIH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhbmltYXRlKGFjdGlvbiwgdGFyZ2V0KSB7aWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7dGFyZ2V0ID0gdGhpcy4kZWw7fVxuICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmFuaW1hdGlvbjtcbiAgICAgICAgICBjb25zdCBhbmltYXRpb25GbiA9XG4gICAgICAgICAgbmFtZSA9PT0gJ2ZhZGUnID9cbiAgICAgICAgICBmYWRlIDpcbiAgICAgICAgICBuYW1lID09PSAnZGVsYXllZC1mYWRlJyA/XG4gICAgICAgICAgZnVuY3Rpb24gKCkge2ZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge2FyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07fXJldHVybiBmYWRlKC4uLmFyZ3MsIDQwKTt9IDpcbiAgICAgICAgICBuYW1lID9cbiAgICAgICAgICBzbGlkZSA6XG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBhbmltYXRpb25GbihhY3Rpb24sIHRhcmdldCwgdGhpcy5kdXJhdGlvbikudGhlbihcbiAgICAgICAgICAoKSA9PiB0aGlzLiR1cGRhdGUodGFyZ2V0LCAncmVzaXplJyksXG4gICAgICAgICAgbm9vcCk7XG5cbiAgICAgICAgfSB9IH07XG5cbiAgICB2YXIgZmlsdGVyID0ge1xuICAgICAgbWl4aW5zOiBbQW5pbWF0ZV0sXG5cbiAgICAgIGFyZ3M6ICd0YXJnZXQnLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IEJvb2xlYW4sXG4gICAgICAgIHNlbEFjdGl2ZTogQm9vbGVhbiB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICBzZWxBY3RpdmU6IGZhbHNlLFxuICAgICAgICBhdHRySXRlbTogJ3VrLWZpbHRlci1jb250cm9sJyxcbiAgICAgICAgY2xzOiAndWstYWN0aXZlJyxcbiAgICAgICAgZHVyYXRpb246IDI1MCB9LFxuXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRvZ2dsZXM6IHtcbiAgICAgICAgICBnZXQoX3JlZiwgJGVsKSB7bGV0IHsgYXR0ckl0ZW0gfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gJCQoXCJbXCIgKyBhdHRySXRlbSArIFwiXSxbZGF0YS1cIiArIGF0dHJJdGVtICsgXCJdXCIsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxBY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZXMgPSAkJCh0aGlzLnNlbEFjdGl2ZSwgdGhpcy4kZWwpO1xuICAgICAgICAgICAgICB0aGlzLnRvZ2dsZXMuZm9yRWFjaCgoZWwpID0+IHRvZ2dsZUNsYXNzKGVsLCB0aGlzLmNscywgaW5jbHVkZXMoYWN0aXZlcywgZWwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgICBnZXQoX3JlZjIsICRlbCkge2xldCB7IHRhcmdldCB9ID0gX3JlZjI7XG4gICAgICAgICAgICByZXR1cm4gJCQodGFyZ2V0ICsgXCIgPiAqXCIsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGxpc3QsIG9sZCkge1xuICAgICAgICAgICAgaWYgKG9sZCAmJiAhaXNFcXVhbExpc3QobGlzdCwgb2xkKSkge1xuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9IH0sXG5cblxuXG4gICAgICBldmVudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gXCJbXCIgKyB0aGlzLmF0dHJJdGVtICsgXCJdLFtkYXRhLVwiICsgdGhpcy5hdHRySXRlbSArIFwiXVwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmFwcGx5KGUuY3VycmVudCk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFwcGx5KGVsKSB7XG4gICAgICAgICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gbWVyZ2VTdGF0ZShlbCwgdGhpcy5hdHRySXRlbSwgdGhpcy5nZXRTdGF0ZSgpKTtcblxuICAgICAgICAgIGlmICghaXNFcXVhbFN0YXRlKHByZXZTdGF0ZSwgbmV3U3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlcy5cbiAgICAgICAgICBmaWx0ZXIoKGl0ZW0pID0+IGhhc0NsYXNzKGl0ZW0sIHRoaXMuY2xzKSkuXG4gICAgICAgICAgcmVkdWNlKChzdGF0ZSwgZWwpID0+IG1lcmdlU3RhdGUoZWwsIHRoaXMuYXR0ckl0ZW0sIHN0YXRlKSwge1xuICAgICAgICAgICAgZmlsdGVyOiB7ICcnOiAnJyB9LFxuICAgICAgICAgICAgc29ydDogW10gfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRTdGF0ZShzdGF0ZSwgYW5pbWF0ZSkge2lmIChhbmltYXRlID09PSB2b2lkIDApIHthbmltYXRlID0gdHJ1ZTt9XG4gICAgICAgICAgc3RhdGUgPSB7IGZpbHRlcjogeyAnJzogJycgfSwgc29ydDogW10sIC4uLnN0YXRlIH07XG5cbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAnYmVmb3JlRmlsdGVyJywgW3RoaXMsIHN0YXRlXSk7XG5cbiAgICAgICAgICB0aGlzLnRvZ2dsZXMuZm9yRWFjaCgoZWwpID0+XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzLCAhIW1hdGNoRmlsdGVyKGVsLCB0aGlzLmF0dHJJdGVtLCBzdGF0ZSkpKTtcblxuXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgJCQodGhpcy50YXJnZXQsIHRoaXMuJGVsKS5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGFwcGx5U3RhdGUoc3RhdGUsIHRhcmdldCwgY2hpbGRyZW4odGFyZ2V0KSk7XG4gICAgICAgICAgICAgIHRoaXMuJHVwZGF0ZSh0aGlzLiRlbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGUgPyB0aGlzLmFuaW1hdGUoZmlsdGVyRm4sIHRhcmdldCkgOiBmaWx0ZXJGbigpO1xuICAgICAgICAgIH0pKS5cbiAgICAgICAgICB0aGVuKCgpID0+IHRyaWdnZXIodGhpcy4kZWwsICdhZnRlckZpbHRlcicsIFt0aGlzXSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICAgIGZhc3Rkb20ud3JpdGUoKCkgPT4gdGhpcy5zZXRTdGF0ZSh0aGlzLmdldFN0YXRlKCksIGZhbHNlKSk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldEZpbHRlcihlbCwgYXR0cikge1xuICAgICAgcmV0dXJuIHBhcnNlT3B0aW9ucyhkYXRhKGVsLCBhdHRyKSwgWydmaWx0ZXInXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFcXVhbFN0YXRlKHN0YXRlQSwgc3RhdGVCKSB7XG4gICAgICByZXR1cm4gWydmaWx0ZXInLCAnc29ydCddLmV2ZXJ5KChwcm9wKSA9PiBpc0VxdWFsKHN0YXRlQVtwcm9wXSwgc3RhdGVCW3Byb3BdKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlTdGF0ZShzdGF0ZSwgdGFyZ2V0LCBjaGlsZHJlbikge1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihzdGF0ZSk7XG5cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goKGVsKSA9PiBjc3MoZWwsICdkaXNwbGF5Jywgc2VsZWN0b3IgJiYgIW1hdGNoZXMoZWwsIHNlbGVjdG9yKSA/ICdub25lJyA6ICcnKSk7XG5cbiAgICAgIGNvbnN0IFtzb3J0LCBvcmRlcl0gPSBzdGF0ZS5zb3J0O1xuXG4gICAgICBpZiAoc29ydCkge1xuICAgICAgICBjb25zdCBzb3J0ZWQgPSBzb3J0SXRlbXMoY2hpbGRyZW4sIHNvcnQsIG9yZGVyKTtcbiAgICAgICAgaWYgKCFpc0VxdWFsKHNvcnRlZCwgY2hpbGRyZW4pKSB7XG4gICAgICAgICAgYXBwZW5kKHRhcmdldCwgc29ydGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlU3RhdGUoZWwsIGF0dHIsIHN0YXRlKSB7XG4gICAgICBjb25zdCBmaWx0ZXJCeSA9IGdldEZpbHRlcihlbCwgYXR0cik7XG4gICAgICBjb25zdCB7IGZpbHRlciwgZ3JvdXAsIHNvcnQsIG9yZGVyID0gJ2FzYycgfSA9IGZpbHRlckJ5O1xuXG4gICAgICBpZiAoZmlsdGVyIHx8IGlzVW5kZWZpbmVkKHNvcnQpKSB7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5maWx0ZXJbJyddO1xuICAgICAgICAgICAgc3RhdGUuZmlsdGVyW2dyb3VwXSA9IGZpbHRlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmZpbHRlcltncm91cF07XG5cbiAgICAgICAgICAgIGlmIChpc0VtcHR5KHN0YXRlLmZpbHRlcikgfHwgJycgaW4gc3RhdGUuZmlsdGVyKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmZpbHRlciA9IHsgJyc6IGZpbHRlciB8fCAnJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5maWx0ZXIgPSB7ICcnOiBmaWx0ZXIgfHwgJycgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHNvcnQpKSB7XG4gICAgICAgIHN0YXRlLnNvcnQgPSBbc29ydCwgb3JkZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hGaWx0ZXIoXG4gICAgZWwsXG4gICAgYXR0ciwgX3JlZjMpXG5cbiAgICB7bGV0IHsgZmlsdGVyOiBzdGF0ZUZpbHRlciA9IHsgJyc6ICcnIH0sIHNvcnQ6IFtzdGF0ZVNvcnQsIHN0YXRlT3JkZXJdIH0gPSBfcmVmMztcbiAgICAgIGNvbnN0IHsgZmlsdGVyID0gJycsIGdyb3VwID0gJycsIHNvcnQsIG9yZGVyID0gJ2FzYycgfSA9IGdldEZpbHRlcihlbCwgYXR0cik7XG5cbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZChzb3J0KSA/XG4gICAgICBncm91cCBpbiBzdGF0ZUZpbHRlciAmJiBmaWx0ZXIgPT09IHN0YXRlRmlsdGVyW2dyb3VwXSB8fFxuICAgICAgIWZpbHRlciAmJiBncm91cCAmJiAhKGdyb3VwIGluIHN0YXRlRmlsdGVyKSAmJiAhc3RhdGVGaWx0ZXJbJyddIDpcbiAgICAgIHN0YXRlU29ydCA9PT0gc29ydCAmJiBzdGF0ZU9yZGVyID09PSBvcmRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0VxdWFsTGlzdChsaXN0QSwgbGlzdEIpIHtcbiAgICAgIHJldHVybiBsaXN0QS5sZW5ndGggPT09IGxpc3RCLmxlbmd0aCAmJiBsaXN0QS5ldmVyeSgoZWwpID0+IGxpc3RCLmluY2x1ZGVzKGVsKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0b3IoX3JlZjQpIHtsZXQgeyBmaWx0ZXIgfSA9IF9yZWY0O1xuICAgICAgbGV0IHNlbGVjdG9yID0gJyc7XG4gICAgICBlYWNoKGZpbHRlciwgKHZhbHVlKSA9PiBzZWxlY3RvciArPSB2YWx1ZSB8fCAnJyk7XG4gICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEl0ZW1zKG5vZGVzLCBzb3J0LCBvcmRlcikge1xuICAgICAgcmV0dXJuIFsuLi5ub2Rlc10uc29ydChcbiAgICAgIChhLCBiKSA9PlxuICAgICAgZGF0YShhLCBzb3J0KS5sb2NhbGVDb21wYXJlKGRhdGEoYiwgc29ydCksIHVuZGVmaW5lZCwgeyBudW1lcmljOiB0cnVlIH0pICogKFxuICAgICAgb3JkZXIgPT09ICdhc2MnIHx8IC0xKSk7XG5cbiAgICB9XG5cbiAgICB2YXIgQW5pbWF0aW9ucyQyID0ge1xuICAgICAgc2xpZGU6IHtcbiAgICAgICAgc2hvdyhkaXIpIHtcbiAgICAgICAgICByZXR1cm4gW3sgdHJhbnNmb3JtOiB0cmFuc2xhdGUoZGlyICogLTEwMCkgfSwgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpIH1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkKGN1cnJlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoZGlyICogLTEwMCAqIHBlcmNlbnQpIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZShkaXIgKiAxMDAgKiAoMSAtIHBlcmNlbnQpKSB9XTtcblxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVkKGVsKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoY3NzKGVsLCAndHJhbnNmb3JtJykuc3BsaXQoJywnKVs0XSAvIGVsLm9mZnNldFdpZHRoKSB8fCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZSh2YWx1ZSwgdW5pdCkge2lmICh2YWx1ZSA9PT0gdm9pZCAwKSB7dmFsdWUgPSAwO31pZiAodW5pdCA9PT0gdm9pZCAwKSB7dW5pdCA9ICclJzt9XG4gICAgICB2YWx1ZSArPSB2YWx1ZSA/IHVuaXQgOiAnJztcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgdmFsdWUgKyBcIiwgMCwgMClcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZTNkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJzY2FsZTNkKFwiICsgdmFsdWUgKyBcIiwgXCIgKyB2YWx1ZSArIFwiLCAxKVwiO1xuICAgIH1cblxuICAgIHZhciBBbmltYXRpb25zJDEgPSB7XG4gICAgICAuLi5BbmltYXRpb25zJDIsXG4gICAgICBmYWRlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiAxIC0gY3NzKGN1cnJlbnQsICdvcGFjaXR5Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICByZXR1cm4gW3sgb3BhY2l0eTogMSAtIHBlcmNlbnQgfSwgeyBvcGFjaXR5OiBwZXJjZW50IH1dO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgc2NhbGU6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiBzY2FsZTNkKDEgLSAwLjIpIH0sXG4gICAgICAgICAgeyBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06IHNjYWxlM2QoMSkgfV07XG5cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIGNzcyhjdXJyZW50LCAnb3BhY2l0eScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IG9wYWNpdHk6IDEgLSBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSAtIDAuMiAqIHBlcmNlbnQpIH0sXG4gICAgICAgICAgeyBvcGFjaXR5OiBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSAtIDAuMiArIDAuMiAqIHBlcmNlbnQpIH1dO1xuXG4gICAgICAgIH0gfSB9O1xuXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbmVyJDEocHJldiwgbmV4dCwgZGlyLCBfcmVmKSB7bGV0IHsgYW5pbWF0aW9uLCBlYXNpbmcgfSA9IF9yZWY7XG4gICAgICBjb25zdCB7IHBlcmNlbnQsIHRyYW5zbGF0ZSwgc2hvdyA9IG5vb3AgfSA9IGFuaW1hdGlvbjtcbiAgICAgIGNvbnN0IHByb3BzID0gc2hvdyhkaXIpO1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlyLFxuXG4gICAgICAgIHNob3coZHVyYXRpb24sIHBlcmNlbnQsIGxpbmVhcikge2lmIChwZXJjZW50ID09PSB2b2lkIDApIHtwZXJjZW50ID0gMDt9XG4gICAgICAgICAgY29uc3QgdGltaW5nID0gbGluZWFyID8gJ2xpbmVhcicgOiBlYXNpbmc7XG4gICAgICAgICAgZHVyYXRpb24gLT0gTWF0aC5yb3VuZChkdXJhdGlvbiAqIGNsYW1wKHBlcmNlbnQsIC0xLCAxKSk7XG5cbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShwZXJjZW50KTtcblxuICAgICAgICAgIHRyaWdnZXJVcGRhdGUkMShuZXh0LCAnaXRlbWluJywgeyBwZXJjZW50LCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSQxKHByZXYsICdpdGVtb3V0JywgeyBwZXJjZW50OiAxIC0gcGVyY2VudCwgZHVyYXRpb24sIHRpbWluZywgZGlyIH0pO1xuXG4gICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQobmV4dCwgcHJvcHNbMV0sIGR1cmF0aW9uLCB0aW1pbmcpLFxuICAgICAgICAgIFRyYW5zaXRpb24uc3RhcnQocHJldiwgcHJvcHNbMF0sIGR1cmF0aW9uLCB0aW1pbmcpXSkuXG4gICAgICAgICAgdGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfSwgbm9vcCk7XG5cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwoW25leHQsIHByZXZdKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHNbMF0pIHtcbiAgICAgICAgICAgIGNzcyhbbmV4dCwgcHJldl0sIHByb3AsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yd2FyZChkdXJhdGlvbiwgcGVyY2VudCkge2lmIChwZXJjZW50ID09PSB2b2lkIDApIHtwZXJjZW50ID0gdGhpcy5wZXJjZW50KCk7fVxuICAgICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKFtuZXh0LCBwcmV2XSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhkdXJhdGlvbiwgcGVyY2VudCwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHRyYW5zbGF0ZShwZXJjZW50LCBkaXIpO1xuICAgICAgICAgIGNzcyhuZXh0LCBwcm9wc1sxXSk7XG4gICAgICAgICAgY3NzKHByZXYsIHByb3BzWzBdKTtcbiAgICAgICAgICB0cmlnZ2VyVXBkYXRlJDEobmV4dCwgJ2l0ZW10cmFuc2xhdGVpbicsIHsgcGVyY2VudCwgZGlyIH0pO1xuICAgICAgICAgIHRyaWdnZXJVcGRhdGUkMShwcmV2LCAnaXRlbXRyYW5zbGF0ZW91dCcsIHsgcGVyY2VudDogMSAtIHBlcmNlbnQsIGRpciB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KCkge1xuICAgICAgICAgIHJldHVybiBwZXJjZW50KHByZXYgfHwgbmV4dCwgbmV4dCwgZGlyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREaXN0YW5jZSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldi5vZmZzZXRXaWR0aDtcbiAgICAgICAgfSB9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZSQxKGVsLCB0eXBlLCBkYXRhKSB7XG4gICAgICB0cmlnZ2VyKGVsLCBjcmVhdGVFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UsIGRhdGEpKTtcbiAgICB9XG5cbiAgICB2YXIgU2xpZGVyQXV0b3BsYXkgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBhdXRvcGxheTogQm9vbGVhbixcbiAgICAgICAgYXV0b3BsYXlJbnRlcnZhbDogTnVtYmVyLFxuICAgICAgICBwYXVzZU9uSG92ZXI6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgYXV0b3BsYXlJbnRlcnZhbDogNzAwMCxcbiAgICAgICAgcGF1c2VPbkhvdmVyOiB0cnVlIH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmF1dG9wbGF5ICYmIHRoaXMuc3RhcnRBdXRvcGxheSgpO1xuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN0b3BBdXRvcGxheSgpO1xuICAgICAgfSxcblxuICAgICAgdXBkYXRlKCkge1xuICAgICAgICBhdHRyKHRoaXMuc2xpZGVzLCAndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAndmlzaWJpbGl0eWNoYW5nZScsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvcGxheTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEF1dG9wbGF5KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRBdXRvcGxheSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc3RhcnRBdXRvcGxheSgpIHtcbiAgICAgICAgICB0aGlzLnN0b3BBdXRvcGxheSgpO1xuXG4gICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgICAgICgpID0+XG4gICAgICAgICAgKCF0aGlzLmRyYWdnYWJsZSB8fCAhJCgnOmZvY3VzJywgdGhpcy4kZWwpKSAmJiAoXG4gICAgICAgICAgIXRoaXMucGF1c2VPbkhvdmVyIHx8ICFtYXRjaGVzKHRoaXMuJGVsLCAnOmhvdmVyJykpICYmXG4gICAgICAgICAgIXRoaXMuc3RhY2subGVuZ3RoICYmXG4gICAgICAgICAgdGhpcy5zaG93KCduZXh0JyksXG4gICAgICAgICAgdGhpcy5hdXRvcGxheUludGVydmFsKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHN0b3BBdXRvcGxheSgpIHtcbiAgICAgICAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIFNsaWRlckRyYWcgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBkcmFnZ2FibGU6IEJvb2xlYW4gfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgdGhyZXNob2xkOiAxMCB9LFxuXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnc3RhcnQnLCAnbW92ZScsICdlbmQnXSkge1xuICAgICAgICAgIGNvbnN0IGZuID0gdGhpc1trZXldO1xuICAgICAgICAgIHRoaXNba2V5XSA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBnZXRFdmVudFBvcyhlKS54ICogKGlzUnRsID8gLTEgOiAxKTtcblxuICAgICAgICAgICAgdGhpcy5wcmV2UG9zID0gcG9zID09PSB0aGlzLnBvcyA/IHRoaXMucHJldlBvcyA6IHRoaXMucG9zO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG5cbiAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBwb2ludGVyRG93bixcblxuICAgICAgICBkZWxlZ2F0ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxTbGlkZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICF0aGlzLmRyYWdnYWJsZSB8fFxuICAgICAgICAgICFpc1RvdWNoKGUpICYmIGhhc1RleHROb2Rlc09ubHkoZS50YXJnZXQpIHx8XG4gICAgICAgICAgY2xvc2VzdChlLnRhcmdldCwgc2VsSW5wdXQpIHx8XG4gICAgICAgICAgZS5idXR0b24gPiAwIHx8XG4gICAgICAgICAgdGhpcy5sZW5ndGggPCAyKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YXJ0KGUpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZHJhZ3N0YXJ0JyxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgIHRoaXMuZHJhZyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3RyYW5zaXRpb25lcikge1xuICAgICAgICAgICAgdGhpcy5wZXJjZW50ID0gdGhpcy5fdHJhbnNpdGlvbmVyLnBlcmNlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZyArPSB0aGlzLl90cmFuc2l0aW9uZXIuZ2V0RGlzdGFuY2UoKSAqIHRoaXMucGVyY2VudCAqIHRoaXMuZGlyO1xuXG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIudHJhbnNsYXRlKHRoaXMucGVyY2VudCk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJldkluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlck1vdmUsIHRoaXMubW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgICAgICAgIC8vICdpbnB1dCcgZXZlbnQgaXMgdHJpZ2dlcmVkIGJ5IHZpZGVvIGNvbnRyb2xzXG4gICAgICAgICAgb24oZG9jdW1lbnQsIHBvaW50ZXJVcCArIFwiIFwiICsgcG9pbnRlckNhbmNlbCArIFwiIGlucHV0XCIsIHRoaXMuZW5kLCB0cnVlKTtcblxuICAgICAgICAgIGNzcyh0aGlzLmxpc3QsICd1c2VyU2VsZWN0JywgJ25vbmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlKGUpIHtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMucG9zIC0gdGhpcy5kcmFnO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIGRpc3RhbmNlID09PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmV2UG9zID09PSB0aGlzLnBvcyB8fFxuICAgICAgICAgICF0aGlzLmRyYWdnaW5nICYmIE1hdGguYWJzKGRpc3RhbmNlKSA8IHRoaXMudGhyZXNob2xkKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwcmV2ZW50IGNsaWNrIGV2ZW50XG4gICAgICAgICAgY3NzKHRoaXMubGlzdCwgJ3BvaW50ZXJFdmVudHMnLCAnbm9uZScpO1xuXG4gICAgICAgICAgZS5jYW5jZWxhYmxlICYmIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGlyID0gZGlzdGFuY2UgPCAwID8gMSA6IC0xO1xuXG4gICAgICAgICAgY29uc3QgeyBzbGlkZXMgfSA9IHRoaXM7XG4gICAgICAgICAgbGV0IHsgcHJldkluZGV4IH0gPSB0aGlzO1xuICAgICAgICAgIGxldCBkaXMgPSBNYXRoLmFicyhkaXN0YW5jZSk7XG4gICAgICAgICAgbGV0IG5leHRJbmRleCA9IHRoaXMuZ2V0SW5kZXgocHJldkluZGV4ICsgdGhpcy5kaXIsIHByZXZJbmRleCk7XG4gICAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5fZ2V0RGlzdGFuY2UocHJldkluZGV4LCBuZXh0SW5kZXgpIHx8IHNsaWRlc1twcmV2SW5kZXhdLm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgd2hpbGUgKG5leHRJbmRleCAhPT0gcHJldkluZGV4ICYmIGRpcyA+IHdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWcgLT0gd2lkdGggKiB0aGlzLmRpcjtcblxuICAgICAgICAgICAgcHJldkluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgZGlzIC09IHdpZHRoO1xuICAgICAgICAgICAgbmV4dEluZGV4ID0gdGhpcy5nZXRJbmRleChwcmV2SW5kZXggKyB0aGlzLmRpciwgcHJldkluZGV4KTtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fZ2V0RGlzdGFuY2UocHJldkluZGV4LCBuZXh0SW5kZXgpIHx8IHNsaWRlc1twcmV2SW5kZXhdLm9mZnNldFdpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucGVyY2VudCA9IGRpcyAvIHdpZHRoO1xuXG4gICAgICAgICAgY29uc3QgcHJldiA9IHNsaWRlc1twcmV2SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBzbGlkZXNbbmV4dEluZGV4XTtcbiAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5pbmRleCAhPT0gbmV4dEluZGV4O1xuICAgICAgICAgIGNvbnN0IGVkZ2UgPSBwcmV2SW5kZXggPT09IG5leHRJbmRleDtcblxuICAgICAgICAgIGxldCBpdGVtU2hvd247XG5cbiAgICAgICAgICBbdGhpcy5pbmRleCwgdGhpcy5wcmV2SW5kZXhdLlxuICAgICAgICAgIGZpbHRlcigoaSkgPT4gIWluY2x1ZGVzKFtuZXh0SW5kZXgsIHByZXZJbmRleF0sIGkpKS5cbiAgICAgICAgICBmb3JFYWNoKChpKSA9PiB7XG4gICAgICAgICAgICB0cmlnZ2VyKHNsaWRlc1tpXSwgJ2l0ZW1oaWRkZW4nLCBbdGhpc10pO1xuXG4gICAgICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgICBpdGVtU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLnByZXZJbmRleCA9IHByZXZJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSBwcmV2SW5kZXggJiYgdGhpcy5wcmV2SW5kZXggIT09IHByZXZJbmRleCB8fCBpdGVtU2hvd24pIHtcbiAgICAgICAgICAgIHRyaWdnZXIoc2xpZGVzW3RoaXMuaW5kZXhdLCAnaXRlbXNob3duJywgW3RoaXNdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gbmV4dEluZGV4O1xuXG4gICAgICAgICAgICAhZWRnZSAmJiB0cmlnZ2VyKHByZXYsICdiZWZvcmVpdGVtaGlkZScsIFt0aGlzXSk7XG4gICAgICAgICAgICB0cmlnZ2VyKG5leHQsICdiZWZvcmVpdGVtc2hvdycsIFt0aGlzXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gdGhpcy5fdHJhbnNsYXRlKE1hdGguYWJzKHRoaXMucGVyY2VudCksIHByZXYsICFlZGdlICYmIG5leHQpO1xuXG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICFlZGdlICYmIHRyaWdnZXIocHJldiwgJ2l0ZW1oaWRlJywgW3RoaXNdKTtcbiAgICAgICAgICAgIHRyaWdnZXIobmV4dCwgJ2l0ZW1zaG93JywgW3RoaXNdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgcG9pbnRlck1vdmUsIHRoaXMubW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIHBvaW50ZXJVcCArIFwiIFwiICsgcG9pbnRlckNhbmNlbCArIFwiIGlucHV0XCIsIHRoaXMuZW5kLCB0cnVlKTtcblxuICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHRoaXMucHJldkluZGV4KSB7XG4gICAgICAgICAgICAgIHRoaXMucGVyY2VudCA9IDEgLSB0aGlzLnBlcmNlbnQ7XG4gICAgICAgICAgICAgIHRoaXMuZGlyICo9IC0xO1xuICAgICAgICAgICAgICB0aGlzLl9zaG93KGZhbHNlLCB0aGlzLmluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRpckNoYW5nZSA9XG4gICAgICAgICAgICAgIChpc1J0bCA/IHRoaXMuZGlyICogKGlzUnRsID8gMSA6IC0xKSA6IHRoaXMuZGlyKSA8IDAgPT09XG4gICAgICAgICAgICAgIHRoaXMucHJldlBvcyA+IHRoaXMucG9zO1xuICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gZGlyQ2hhbmdlID8gdGhpcy5pbmRleCA6IHRoaXMucHJldkluZGV4O1xuXG4gICAgICAgICAgICAgIGlmIChkaXJDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmNlbnQgPSAxIC0gdGhpcy5wZXJjZW50O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zaG93KFxuICAgICAgICAgICAgICB0aGlzLmRpciA+IDAgJiYgIWRpckNoYW5nZSB8fCB0aGlzLmRpciA8IDAgJiYgZGlyQ2hhbmdlID9cbiAgICAgICAgICAgICAgJ25leHQnIDpcbiAgICAgICAgICAgICAgJ3ByZXZpb3VzJyxcbiAgICAgICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjc3ModGhpcy5saXN0LCB7IHVzZXJTZWxlY3Q6ICcnLCBwb2ludGVyRXZlbnRzOiAnJyB9KTtcblxuICAgICAgICAgIHRoaXMuZHJhZyA9IHRoaXMucGVyY2VudCA9IG51bGw7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGhhc1RleHROb2Rlc09ubHkoZWwpIHtcbiAgICAgIHJldHVybiAhZWwuY2hpbGRyZW4ubGVuZ3RoICYmIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBTbGlkZXJOYXYgPSB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNlbE5hdjogZmFsc2UgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBuYXYoX3JlZiwgJGVsKSB7bGV0IHsgc2VsTmF2IH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAkKHNlbE5hdiwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZWxOYXZJdGVtKF9yZWYyKSB7bGV0IHsgYXR0ckl0ZW0gfSA9IF9yZWYyO1xuICAgICAgICAgIHJldHVybiBcIltcIiArIGF0dHJJdGVtICsgXCJdLFtkYXRhLVwiICsgYXR0ckl0ZW0gKyBcIl1cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBuYXZJdGVtcyhfLCAkZWwpIHtcbiAgICAgICAgICByZXR1cm4gJCQodGhpcy5zZWxOYXZJdGVtLCAkZWwpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHdyaXRlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5hdiAmJiB0aGlzLmxlbmd0aCAhPT0gdGhpcy5uYXYuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBodG1sKFxuICAgICAgICAgICAgdGhpcy5uYXYsXG4gICAgICAgICAgICB0aGlzLnNsaWRlcy5cbiAgICAgICAgICAgIG1hcCgoXywgaSkgPT4gXCI8bGkgXCIgKyB0aGlzLmF0dHJJdGVtICsgXCI9XFxcIlwiICsgaSArIFwiXFxcIj48YSBocmVmPjwvYT48L2xpPlwiKS5cbiAgICAgICAgICAgIGpvaW4oJycpKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubmF2SXRlbXMuY29uY2F0KHRoaXMubmF2KS5mb3JFYWNoKChlbCkgPT4gZWwgJiYgKGVsLmhpZGRlbiA9ICF0aGlzLm1heEluZGV4KSk7XG5cbiAgICAgICAgICB0aGlzLnVwZGF0ZU5hdigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydyZXNpemUnXSB9LFxuXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnY2xpY2snLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbE5hdkl0ZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2hvdyhkYXRhKGUuY3VycmVudCwgdGhpcy5hdHRySXRlbSkpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnaXRlbXNob3cnLFxuICAgICAgICBoYW5kbGVyOiAndXBkYXRlTmF2JyB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdXBkYXRlTmF2KCkge1xuICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLmdldFZhbGlkSW5kZXgoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMubmF2SXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IGRhdGEoZWwsIHRoaXMuYXR0ckl0ZW0pO1xuXG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcy5jbHNBY3RpdmUsIHRvTnVtYmVyKGNtZCkgPT09IGkpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICd1ay1pbnZpc2libGUnLFxuICAgICAgICAgICAgdGhpcy5maW5pdGUgJiYgKFxuICAgICAgICAgICAgY21kID09PSAncHJldmlvdXMnICYmIGkgPT09IDAgfHwgY21kID09PSAnbmV4dCcgJiYgaSA+PSB0aGlzLm1heEluZGV4KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIFNsaWRlciA9IHtcbiAgICAgIG1peGluczogW1NsaWRlckF1dG9wbGF5LCBTbGlkZXJEcmFnLCBTbGlkZXJOYXYsIFJlc2l6ZV0sXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsc0FjdGl2YXRlZDogQm9vbGVhbixcbiAgICAgICAgZWFzaW5nOiBTdHJpbmcsXG4gICAgICAgIGluZGV4OiBOdW1iZXIsXG4gICAgICAgIGZpbml0ZTogQm9vbGVhbixcbiAgICAgICAgdmVsb2NpdHk6IE51bWJlcixcbiAgICAgICAgc2VsU2xpZGVzOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiAoKSA9PiAoe1xuICAgICAgICBlYXNpbmc6ICdlYXNlJyxcbiAgICAgICAgZmluaXRlOiBmYWxzZSxcbiAgICAgICAgdmVsb2NpdHk6IDEsXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBwcmV2SW5kZXg6IC0xLFxuICAgICAgICBzdGFjazogW10sXG4gICAgICAgIHBlcmNlbnQ6IDAsXG4gICAgICAgIGNsc0FjdGl2ZTogJ3VrLWFjdGl2ZScsXG4gICAgICAgIGNsc0FjdGl2YXRlZDogZmFsc2UsXG4gICAgICAgIFRyYW5zaXRpb25lcjogZmFsc2UsXG4gICAgICAgIHRyYW5zaXRpb25PcHRpb25zOiB7fSB9KSxcblxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucHJldkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmdldFZhbGlkSW5kZXgodGhpcy4kcHJvcHMuaW5kZXgpO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuc2xpZGVzLCB0aGlzLmNsc0FjdGl2ZSk7XG4gICAgICB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBkdXJhdGlvbihfcmVmLCAkZWwpIHtsZXQgeyB2ZWxvY2l0eSB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gc3BlZWRVcCgkZWwub2Zmc2V0V2lkdGggLyB2ZWxvY2l0eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlzdChfcmVmMiwgJGVsKSB7bGV0IHsgc2VsTGlzdCB9ID0gX3JlZjI7XG4gICAgICAgICAgcmV0dXJuICQoc2VsTGlzdCwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXhJbmRleCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlbFNsaWRlcyhfcmVmMykge2xldCB7IHNlbExpc3QsIHNlbFNsaWRlcyB9ID0gX3JlZjM7XG4gICAgICAgICAgcmV0dXJuIHNlbExpc3QgKyBcIiBcIiArIChzZWxTbGlkZXMgfHwgJz4gKicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNsaWRlczoge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkJCh0aGlzLnNlbFNsaWRlcywgdGhpcy4kZWwpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YXRjaCgpIHtcbiAgICAgICAgICAgIHRoaXMuJHJlc2V0KCk7XG4gICAgICAgICAgfSB9LFxuXG5cbiAgICAgICAgbGVuZ3RoKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWRlcy5sZW5ndGg7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coaW5kZXgsIGZvcmNlKSB7aWYgKGZvcmNlID09PSB2b2lkIDApIHtmb3JjZSA9IGZhbHNlO31cbiAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyB8fCAhdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IHN0YWNrIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IHF1ZXVlSW5kZXggPSBmb3JjZSA/IDAgOiBzdGFjay5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBzdGFjay5zcGxpY2UocXVldWVJbmRleCwgMSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaG93KHN0YWNrLnNoaWZ0KCksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzdGFja1tmb3JjZSA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oaW5kZXgpO1xuXG4gICAgICAgICAgaWYgKCFmb3JjZSAmJiBzdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lci5mb3J3YXJkKE1hdGgubWluKHRoaXMuZHVyYXRpb24sIDIwMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJldkluZGV4ID0gdGhpcy5nZXRJbmRleCh0aGlzLmluZGV4KTtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gaGFzQ2xhc3ModGhpcy5zbGlkZXMsIHRoaXMuY2xzQWN0aXZlKSAmJiB0aGlzLnNsaWRlc1twcmV2SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuZ2V0SW5kZXgoaW5kZXgsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLnNsaWRlc1tuZXh0SW5kZXhdO1xuXG4gICAgICAgICAgaWYgKHByZXYgPT09IG5leHQpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kaXIgPSBnZXREaXJlY3Rpb24oaW5kZXgsIHByZXZJbmRleCk7XG4gICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICBwcmV2ICYmICF0cmlnZ2VyKHByZXYsICdiZWZvcmVpdGVtaGlkZScsIFt0aGlzXSkgfHxcbiAgICAgICAgICAhdHJpZ2dlcihuZXh0LCAnYmVmb3JlaXRlbXNob3cnLCBbdGhpcywgcHJldl0pKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnByZXZJbmRleDtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX3Nob3cocHJldiwgbmV4dCwgZm9yY2UpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcHJldiAmJiB0cmlnZ2VyKHByZXYsICdpdGVtaGlkZGVuJywgW3RoaXNdKTtcbiAgICAgICAgICAgIHRyaWdnZXIobmV4dCwgJ2l0ZW1zaG93bicsIFt0aGlzXSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBmYXN0ZG9tLndyaXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdyhzdGFjay5zaGlmdCgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcHJldiAmJiB0cmlnZ2VyKHByZXYsICdpdGVtaGlkZScsIFt0aGlzXSk7XG4gICAgICAgICAgdHJpZ2dlcihuZXh0LCAnaXRlbXNob3cnLCBbdGhpc10pO1xuXG4gICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SW5kZXgoaW5kZXgsIHByZXYpIHtpZiAoaW5kZXggPT09IHZvaWQgMCkge2luZGV4ID0gdGhpcy5pbmRleDt9aWYgKHByZXYgPT09IHZvaWQgMCkge3ByZXYgPSB0aGlzLmluZGV4O31cbiAgICAgICAgICByZXR1cm4gY2xhbXAoZ2V0SW5kZXgoaW5kZXgsIHRoaXMuc2xpZGVzLCBwcmV2LCB0aGlzLmZpbml0ZSksIDAsIHRoaXMubWF4SW5kZXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFZhbGlkSW5kZXgoaW5kZXgsIHByZXZJbmRleCkge2lmIChpbmRleCA9PT0gdm9pZCAwKSB7aW5kZXggPSB0aGlzLmluZGV4O31pZiAocHJldkluZGV4ID09PSB2b2lkIDApIHtwcmV2SW5kZXggPSB0aGlzLnByZXZJbmRleDt9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXgoaW5kZXgsIHByZXZJbmRleCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Nob3cocHJldiwgbmV4dCwgZm9yY2UpIHtcbiAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIocHJldiwgbmV4dCwgdGhpcy5kaXIsIHtcbiAgICAgICAgICAgIGVhc2luZzogZm9yY2UgP1xuICAgICAgICAgICAgbmV4dC5vZmZzZXRXaWR0aCA8IDYwMCA/XG4gICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpJyAvKiBlYXNlT3V0UXVhZCAqLyA6XG4gICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAuMTY1LCAwLjg0LCAwLjQ0LCAxKScgLyogZWFzZU91dFF1YXJ0ICovIDpcbiAgICAgICAgICAgIHRoaXMuZWFzaW5nLFxuICAgICAgICAgICAgLi4udGhpcy50cmFuc2l0aW9uT3B0aW9ucyB9KTtcblxuXG4gICAgICAgICAgaWYgKCFmb3JjZSAmJiAhcHJldikge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB0aGlzLnN0YWNrO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uZXJbbGVuZ3RoID4gMSA/ICdmb3J3YXJkJyA6ICdzaG93J10oXG4gICAgICAgICAgbGVuZ3RoID4gMSA/IE1hdGgubWluKHRoaXMuZHVyYXRpb24sIDc1ICsgNzUgLyAobGVuZ3RoIC0gMSkpIDogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aGlzLnBlcmNlbnQpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldERpc3RhbmNlKHByZXYsIG5leHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNpdGlvbmVyKHByZXYsIHByZXYgIT09IG5leHQgJiYgbmV4dCkuZ2V0RGlzdGFuY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdHJhbnNsYXRlKHBlcmNlbnQsIHByZXYsIG5leHQpIHtpZiAocHJldiA9PT0gdm9pZCAwKSB7cHJldiA9IHRoaXMucHJldkluZGV4O31pZiAobmV4dCA9PT0gdm9pZCAwKSB7bmV4dCA9IHRoaXMuaW5kZXg7fVxuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25lciA9IHRoaXMuX2dldFRyYW5zaXRpb25lcihwcmV2ICE9PSBuZXh0ID8gcHJldiA6IGZhbHNlLCBuZXh0KTtcbiAgICAgICAgICB0cmFuc2l0aW9uZXIudHJhbnNsYXRlKHBlcmNlbnQpO1xuICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFRyYW5zaXRpb25lcihcbiAgICAgICAgcHJldixcbiAgICAgICAgbmV4dCxcbiAgICAgICAgZGlyLFxuICAgICAgICBvcHRpb25zKVxuICAgICAgICB7aWYgKHByZXYgPT09IHZvaWQgMCkge3ByZXYgPSB0aGlzLnByZXZJbmRleDt9aWYgKG5leHQgPT09IHZvaWQgMCkge25leHQgPSB0aGlzLmluZGV4O31pZiAoZGlyID09PSB2b2lkIDApIHtkaXIgPSB0aGlzLmRpciB8fCAxO31pZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7b3B0aW9ucyA9IHRoaXMudHJhbnNpdGlvbk9wdGlvbnM7fVxuICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5UcmFuc2l0aW9uZXIoXG4gICAgICAgICAgaXNOdW1iZXIocHJldikgPyB0aGlzLnNsaWRlc1twcmV2XSA6IHByZXYsXG4gICAgICAgICAgaXNOdW1iZXIobmV4dCkgPyB0aGlzLnNsaWRlc1tuZXh0XSA6IG5leHQsXG4gICAgICAgICAgZGlyICogKGlzUnRsID8gLTEgOiAxKSxcbiAgICAgICAgICBvcHRpb25zKTtcblxuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBnZXREaXJlY3Rpb24oaW5kZXgsIHByZXZJbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4ID09PSAnbmV4dCcgPyAxIDogaW5kZXggPT09ICdwcmV2aW91cycgPyAtMSA6IGluZGV4IDwgcHJldkluZGV4ID8gLTEgOiAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNwZWVkVXAoeCkge1xuICAgICAgcmV0dXJuIDAuNSAqIHggKyAzMDA7IC8vIHBhcmFib2xhIHRocm91Z2ggKDQwMCw1MDA7IDYwMCw2MDA7IDE4MDAsMTIwMClcbiAgICB9XG5cbiAgICB2YXIgU2xpZGVzaG93ID0ge1xuICAgICAgbWl4aW5zOiBbU2xpZGVyXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGFuaW1hdGlvbjogJ3NsaWRlJyxcbiAgICAgICAgY2xzQWN0aXZhdGVkOiAndWstdHJhbnNpdGlvbi1hY3RpdmUnLFxuICAgICAgICBBbmltYXRpb25zOiBBbmltYXRpb25zJDIsXG4gICAgICAgIFRyYW5zaXRpb25lcjogVHJhbnNpdGlvbmVyJDEgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBhbmltYXRpb24oX3JlZikge2xldCB7IGFuaW1hdGlvbiwgQW5pbWF0aW9ucyB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4geyAuLi4oQW5pbWF0aW9uc1thbmltYXRpb25dIHx8IEFuaW1hdGlvbnMuc2xpZGUpLCBuYW1lOiBhbmltYXRpb24gfTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2l0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgICByZXR1cm4geyBhbmltYXRpb246IHRoaXMuYW5pbWF0aW9uIH07XG4gICAgICAgIH0gfSxcblxuXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgYmVmb3JlaXRlbXNob3coX3JlZjIpIHtsZXQgeyB0YXJnZXQgfSA9IF9yZWYyO1xuICAgICAgICAgIGFkZENsYXNzKHRhcmdldCwgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGl0ZW1zaG93bihfcmVmMykge2xldCB7IHRhcmdldCB9ID0gX3JlZjM7XG4gICAgICAgICAgYWRkQ2xhc3ModGFyZ2V0LCB0aGlzLmNsc0FjdGl2YXRlZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbWhpZGRlbihfcmVmNCkge2xldCB7IHRhcmdldCB9ID0gX3JlZjQ7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGFyZ2V0LCB0aGlzLmNsc0FjdGl2ZSwgdGhpcy5jbHNBY3RpdmF0ZWQpO1xuICAgICAgICB9IH0gfTtcblxuICAgIHZhciBMaWdodGJveFBhbmVsID0ge1xuICAgICAgbWl4aW5zOiBbQ29udGFpbmVyLCBNb2RhbCwgVG9nZ2xhYmxlLCBTbGlkZXNob3ddLFxuXG4gICAgICBmdW5jdGlvbmFsOiB0cnVlLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBkZWxheUNvbnRyb2xzOiBOdW1iZXIsXG4gICAgICAgIHByZWxvYWQ6IE51bWJlcixcbiAgICAgICAgdmlkZW9BdXRvcGxheTogQm9vbGVhbixcbiAgICAgICAgdGVtcGxhdGU6IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6ICgpID0+ICh7XG4gICAgICAgIHByZWxvYWQ6IDEsXG4gICAgICAgIHZpZGVvQXV0b3BsYXk6IGZhbHNlLFxuICAgICAgICBkZWxheUNvbnRyb2xzOiAzMDAwLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGNsczogJ3VrLW9wZW4nLFxuICAgICAgICBjbHNQYWdlOiAndWstbGlnaHRib3gtcGFnZScsXG4gICAgICAgIHNlbExpc3Q6ICcudWstbGlnaHRib3gtaXRlbXMnLFxuICAgICAgICBhdHRySXRlbTogJ3VrLWxpZ2h0Ym94LWl0ZW0nLFxuICAgICAgICBzZWxDbG9zZTogJy51ay1jbG9zZS1sYXJnZScsXG4gICAgICAgIHNlbENhcHRpb246ICcudWstbGlnaHRib3gtY2FwdGlvbicsXG4gICAgICAgIHBhdXNlT25Ib3ZlcjogZmFsc2UsXG4gICAgICAgIHZlbG9jaXR5OiAyLFxuICAgICAgICBBbmltYXRpb25zOiBBbmltYXRpb25zJDEsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcInVrLWxpZ2h0Ym94IHVrLW92ZXJmbG93LWhpZGRlblxcXCI+IDx1bCBjbGFzcz1cXFwidWstbGlnaHRib3gtaXRlbXNcXFwiPjwvdWw+IDxkaXYgY2xhc3M9XFxcInVrLWxpZ2h0Ym94LXRvb2xiYXIgdWstcG9zaXRpb24tdG9wIHVrLXRleHQtcmlnaHQgdWstdHJhbnNpdGlvbi1zbGlkZS10b3AgdWstdHJhbnNpdGlvbi1vcGFxdWVcXFwiPiA8YnV0dG9uIGNsYXNzPVxcXCJ1ay1saWdodGJveC10b29sYmFyLWljb24gdWstY2xvc2UtbGFyZ2VcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgdWstY2xvc2U+PC9idXR0b24+IDwvZGl2PiA8YSBjbGFzcz1cXFwidWstbGlnaHRib3gtYnV0dG9uIHVrLXBvc2l0aW9uLWNlbnRlci1sZWZ0IHVrLXBvc2l0aW9uLW1lZGl1bSB1ay10cmFuc2l0aW9uLWZhZGVcXFwiIGhyZWYgdWstc2xpZGVuYXYtcHJldmlvdXMgdWstbGlnaHRib3gtaXRlbT1cXFwicHJldmlvdXNcXFwiPjwvYT4gPGEgY2xhc3M9XFxcInVrLWxpZ2h0Ym94LWJ1dHRvbiB1ay1wb3NpdGlvbi1jZW50ZXItcmlnaHQgdWstcG9zaXRpb24tbWVkaXVtIHVrLXRyYW5zaXRpb24tZmFkZVxcXCIgaHJlZiB1ay1zbGlkZW5hdi1uZXh0IHVrLWxpZ2h0Ym94LWl0ZW09XFxcIm5leHRcXFwiPjwvYT4gPGRpdiBjbGFzcz1cXFwidWstbGlnaHRib3gtdG9vbGJhciB1ay1saWdodGJveC1jYXB0aW9uIHVrLXBvc2l0aW9uLWJvdHRvbSB1ay10ZXh0LWNlbnRlciB1ay10cmFuc2l0aW9uLXNsaWRlLWJvdHRvbSB1ay10cmFuc2l0aW9uLW9wYXF1ZVxcXCI+PC9kaXY+IDwvZGl2PlwiIH0pLFxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICBjb25zdCAkZWwgPSAkKHRoaXMudGVtcGxhdGUpO1xuICAgICAgICBjb25zdCBsaXN0ID0gJCh0aGlzLnNlbExpc3QsICRlbCk7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoKSA9PiBhcHBlbmQobGlzdCwgJzxsaT4nKSk7XG5cbiAgICAgICAgdGhpcy4kbW91bnQoYXBwZW5kKHRoaXMuY29udGFpbmVyLCAkZWwpKTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNhcHRpb24oX3JlZiwgJGVsKSB7bGV0IHsgc2VsQ2FwdGlvbiB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gJChzZWxDYXB0aW9uLCAkZWwpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IHBvaW50ZXJNb3ZlICsgXCIgXCIgKyBwb2ludGVyRG93biArIFwiIGtleWRvd25cIixcblxuICAgICAgICBoYW5kbGVyOiAnc2hvd0NvbnRyb2xzJyB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaWNrJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGRlbGVnYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbFNsaWRlcztcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaG93bicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuc2hvd0NvbnRyb2xzKCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdoaWRlJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5oaWRlQ29udHJvbHMoKTtcblxuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuc2xpZGVzLCB0aGlzLmNsc0FjdGl2ZSk7XG4gICAgICAgICAgVHJhbnNpdGlvbi5zdG9wKHRoaXMuc2xpZGVzKTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2hpZGRlbicsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIHRoaXMuJGRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdrZXl1cCcsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICghdGhpcy5pc1RvZ2dsZWQodGhpcy4kZWwpIHx8ICF0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgICB0aGlzLnNob3coJ3ByZXZpb3VzJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgdGhpcy5zaG93KCduZXh0Jyk7XG4gICAgICAgICAgICAgIGJyZWFrO31cblxuICAgICAgICB9IH0sXG5cblxuICAgICAge1xuICAgICAgICBuYW1lOiAnYmVmb3JlaXRlbXNob3cnLFxuXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcblxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBBbmltYXRpb25zJDFbJ3NjYWxlJ107XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZS50YXJnZXQsIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSgxLCAwLCB0aGlzLmluZGV4KTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2l0ZW1zaG93JyxcblxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGh0bWwodGhpcy5jYXB0aW9uLCB0aGlzLmdldEl0ZW0oKS5jYXB0aW9uIHx8ICcnKTtcblxuICAgICAgICAgIGZvciAobGV0IGogPSAtdGhpcy5wcmVsb2FkOyBqIDw9IHRoaXMucHJlbG9hZDsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRJdGVtKHRoaXMuaW5kZXggKyBqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpdGVtc2hvd24nLFxuXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSB0aGlzLiRwcm9wcy5kcmFnZ2FibGU7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpdGVtbG9hZCcsXG5cbiAgICAgICAgYXN5bmMgaGFuZGxlcihfLCBpdGVtKSB7XG4gICAgICAgICAgY29uc3QgeyBzb3VyY2U6IHNyYywgdHlwZSwgYWx0ID0gJycsIHBvc3RlciwgYXR0cnMgPSB7fSB9ID0gaXRlbTtcblxuICAgICAgICAgIHRoaXMuc2V0SXRlbShpdGVtLCAnPHNwYW4gdWstc3Bpbm5lcj48L3NwYW4+Jyk7XG5cbiAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBtYXRjaGVzO1xuICAgICAgICAgIGNvbnN0IGlmcmFtZUF0dHJzID0ge1xuICAgICAgICAgICAgZnJhbWVib3JkZXI6ICcwJyxcbiAgICAgICAgICAgIGFsbG93OiAnYXV0b3BsYXknLFxuICAgICAgICAgICAgYWxsb3dmdWxsc2NyZWVuOiAnJyxcbiAgICAgICAgICAgIHN0eWxlOiAnbWF4LXdpZHRoOiAxMDAlOyBib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4gICAgICAgICAgICAndWstcmVzcG9uc2l2ZSc6ICcnLFxuICAgICAgICAgICAgJ3VrLXZpZGVvJzogXCJcIiArIHRoaXMudmlkZW9BdXRvcGxheSB9O1xuXG5cbiAgICAgICAgICAvLyBJbWFnZVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlID09PSAnaW1hZ2UnIHx8XG4gICAgICAgICAgc3JjLm1hdGNoKC9cXC4oYXZpZnxqcGU/Z3xqZmlmfGE/cG5nfGdpZnxzdmd8d2VicCkoJHxcXD8pL2kpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYXdhaXQgZ2V0SW1hZ2Uoc3JjLCBhdHRycy5zcmNzZXQsIGF0dHJzLnNpemUpO1xuICAgICAgICAgICAgICB0aGlzLnNldEl0ZW0oaXRlbSwgY3JlYXRlRWwoJ2ltZycsIHsgc3JjLCB3aWR0aCwgaGVpZ2h0LCBhbHQsIC4uLmF0dHJzIH0pKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRFcnJvcihpdGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVmlkZW9cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2aWRlbycgfHwgc3JjLm1hdGNoKC9cXC4obXA0fHdlYm18b2d2KSgkfFxcPykvaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gY3JlYXRlRWwoJ3ZpZGVvJywge1xuICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgIHBvc3RlcixcbiAgICAgICAgICAgICAgY29udHJvbHM6ICcnLFxuICAgICAgICAgICAgICBwbGF5c2lubGluZTogJycsXG4gICAgICAgICAgICAgICd1ay12aWRlbyc6IFwiXCIgKyB0aGlzLnZpZGVvQXV0b3BsYXksXG4gICAgICAgICAgICAgIC4uLmF0dHJzIH0pO1xuXG5cbiAgICAgICAgICAgIG9uKHZpZGVvLCAnbG9hZGVkbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGF0dHIodmlkZW8sIHsgd2lkdGg6IHZpZGVvLnZpZGVvV2lkdGgsIGhlaWdodDogdmlkZW8udmlkZW9IZWlnaHQgfSk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0SXRlbShpdGVtLCB2aWRlbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9uKHZpZGVvLCAnZXJyb3InLCAoKSA9PiB0aGlzLnNldEVycm9yKGl0ZW0pKTtcblxuICAgICAgICAgICAgLy8gSWZyYW1lXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaWZyYW1lJyB8fCBzcmMubWF0Y2goL1xcLihodG1sfHBocCkoJHxcXD8pL2kpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEl0ZW0oXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgY3JlYXRlRWwoJ2lmcmFtZScsIHtcbiAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICBmcmFtZWJvcmRlcjogJzAnLFxuICAgICAgICAgICAgICBhbGxvd2Z1bGxzY3JlZW46ICcnLFxuICAgICAgICAgICAgICBjbGFzczogJ3VrLWxpZ2h0Ym94LWlmcmFtZScsXG4gICAgICAgICAgICAgIC4uLmF0dHJzIH0pKTtcblxuXG5cbiAgICAgICAgICAgIC8vIFlvdVR1YmVcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIG1hdGNoZXMgPSBzcmMubWF0Y2goXG4gICAgICAgICAgL1xcL1xcLyg/Oi4qP3lvdXR1YmUoLW5vY29va2llKT9cXC4uKj9bPyZddj18eW91dHVcXC5iZVxcLykoW1xcdy1dezExfSlbJj9dPyguKik/LykpXG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEl0ZW0oXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgY3JlYXRlRWwoJ2lmcmFtZScsIHtcbiAgICAgICAgICAgICAgc3JjOiBcImh0dHBzOi8vd3d3LnlvdXR1YmVcIiArIChtYXRjaGVzWzFdIHx8ICcnKSArIFwiLmNvbS9lbWJlZC9cIiArIG1hdGNoZXNbMl0gKyAoXG4gICAgICAgICAgICAgIG1hdGNoZXNbM10gPyBcIj9cIiArIG1hdGNoZXNbM10gOiAnJyksXG5cbiAgICAgICAgICAgICAgd2lkdGg6IDE5MjAsXG4gICAgICAgICAgICAgIGhlaWdodDogMTA4MCxcbiAgICAgICAgICAgICAgLi4uaWZyYW1lQXR0cnMsXG4gICAgICAgICAgICAgIC4uLmF0dHJzIH0pKTtcblxuXG5cbiAgICAgICAgICAgIC8vIFZpbWVvXG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzID0gc3JjLm1hdGNoKC9cXC9cXC8uKj92aW1lb1xcLlthLXpdK1xcLyhcXGQrKVsmP10/KC4qKT8vKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBhd2FpdCAoXG4gICAgICAgICAgICAgIGF3YWl0IGZldGNoKFwiaHR0cHM6Ly92aW1lby5jb20vYXBpL29lbWJlZC5qc29uP21heHdpZHRoPTE5MjAmdXJsPVwiICtcbiAgICAgICAgICAgICAgZW5jb2RlVVJJKFxuICAgICAgICAgICAgICBzcmMpLFxuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ29taXQnIH0pKS5cblxuXG4gICAgICAgICAgICAgIGpzb24oKTtcblxuICAgICAgICAgICAgICB0aGlzLnNldEl0ZW0oXG4gICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgIGNyZWF0ZUVsKCdpZnJhbWUnLCB7XG4gICAgICAgICAgICAgICAgc3JjOiBcImh0dHBzOi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby9cIiArIG1hdGNoZXNbMV0gKyAoXG4gICAgICAgICAgICAgICAgbWF0Y2hlc1syXSA/IFwiP1wiICsgbWF0Y2hlc1syXSA6ICcnKSxcblxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAuLi5pZnJhbWVBdHRycyxcbiAgICAgICAgICAgICAgICAuLi5hdHRycyB9KSk7XG5cblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldEVycm9yKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSB9XSxcblxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgbG9hZEl0ZW0oaW5kZXgpIHtpZiAoaW5kZXggPT09IHZvaWQgMCkge2luZGV4ID0gdGhpcy5pbmRleDt9XG4gICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZ2V0SXRlbShpbmRleCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuZ2V0U2xpZGUoaXRlbSkuY2hpbGRFbGVtZW50Q291bnQpIHtcbiAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdpdGVtbG9hZCcsIFtpdGVtXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEl0ZW0oaW5kZXgpIHtpZiAoaW5kZXggPT09IHZvaWQgMCkge2luZGV4ID0gdGhpcy5pbmRleDt9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbZ2V0SW5kZXgoaW5kZXgsIHRoaXMuc2xpZGVzKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0SXRlbShpdGVtLCBjb250ZW50KSB7XG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ2l0ZW1sb2FkZWQnLCBbdGhpcywgaHRtbCh0aGlzLmdldFNsaWRlKGl0ZW0pLCBjb250ZW50KV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNsaWRlKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zbGlkZXNbdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pXTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRFcnJvcihpdGVtKSB7XG4gICAgICAgICAgdGhpcy5zZXRJdGVtKGl0ZW0sICc8c3BhbiB1ay1pY29uPVwiaWNvbjogYm9sdDsgcmF0aW86IDJcIj48L3NwYW4+Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd0NvbnRyb2xzKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbnRyb2xzVGltZXIpO1xuICAgICAgICAgIHRoaXMuY29udHJvbHNUaW1lciA9IHNldFRpbWVvdXQodGhpcy5oaWRlQ29udHJvbHMsIHRoaXMuZGVsYXlDb250cm9scyk7XG5cbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgJ3VrLWFjdGl2ZScsICd1ay10cmFuc2l0aW9uLWFjdGl2ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGVDb250cm9scygpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgJ3VrLWFjdGl2ZScsICd1ay10cmFuc2l0aW9uLWFjdGl2ZScpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbCh0YWcsIGF0dHJzKSB7XG4gICAgICBjb25zdCBlbCA9IGZyYWdtZW50KFwiPFwiICsgdGFnICsgXCI+XCIpO1xuICAgICAgYXR0cihlbCwgYXR0cnMpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cblxuICAgIHZhciBsaWdodGJveCA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwkMSxcblxuICAgICAgcHJvcHM6IHsgdG9nZ2xlOiBTdHJpbmcgfSxcblxuICAgICAgZGF0YTogeyB0b2dnbGU6ICdhJyB9LFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICB0b2dnbGVzOiB7XG4gICAgICAgICAgZ2V0KF9yZWYsICRlbCkge2xldCB7IHRvZ2dsZSB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiAkJCh0b2dnbGUsICRlbCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfSB9IH0sXG5cblxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGljaycsXG5cbiAgICAgICAgZGVsZWdhdGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlICsgXCI6bm90KC51ay1kaXNhYmxlZClcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zaG93KGUuY3VycmVudCk7XG4gICAgICAgIH0gfV0sXG5cblxuXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coaW5kZXgpIHtcbiAgICAgICAgICBjb25zdCBpdGVtcyA9IHVuaXF1ZUJ5KHRoaXMudG9nZ2xlcy5tYXAodG9JdGVtKSwgJ3NvdXJjZScpO1xuXG4gICAgICAgICAgaWYgKGlzRWxlbWVudChpbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlIH0gPSB0b0l0ZW0oaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggPSBmaW5kSW5kZXgoaXRlbXMsIChfcmVmMikgPT4ge2xldCB7IHNvdXJjZTogc3JjIH0gPSBfcmVmMjtyZXR1cm4gc291cmNlID09PSBzcmM7fSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wYW5lbCA9IHRoaXMucGFuZWwgfHwgdGhpcy4kY3JlYXRlKCdsaWdodGJveFBhbmVsJywgeyAuLi50aGlzLiRwcm9wcywgaXRlbXMgfSk7XG5cbiAgICAgICAgICBvbih0aGlzLnBhbmVsLiRlbCwgJ2hpZGRlbicsICgpID0+IHRoaXMucGFuZWwgPSBmYWxzZSk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYW5lbC5zaG93KGluZGV4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlKCkge3ZhciBfdGhpcyRwYW5lbDtcbiAgICAgICAgICByZXR1cm4gKF90aGlzJHBhbmVsID0gdGhpcy5wYW5lbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBhbmVsLmhpZGUoKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCQxKFVJa2l0LCBMaWdodGJveCkge1xuICAgICAgaWYgKCFVSWtpdC5saWdodGJveFBhbmVsKSB7XG4gICAgICAgIFVJa2l0LmNvbXBvbmVudCgnbGlnaHRib3hQYW5lbCcsIExpZ2h0Ym94UGFuZWwpO1xuICAgICAgfVxuXG4gICAgICBhc3NpZ24oTGlnaHRib3gucHJvcHMsIFVJa2l0LmNvbXBvbmVudCgnbGlnaHRib3hQYW5lbCcpLm9wdGlvbnMucHJvcHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSXRlbShlbCkge1xuICAgICAgY29uc3QgaXRlbSA9IHt9O1xuXG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgWydocmVmJywgJ2NhcHRpb24nLCAndHlwZScsICdwb3N0ZXInLCAnYWx0JywgJ2F0dHJzJ10pIHtcbiAgICAgICAgaXRlbVthdHRyID09PSAnaHJlZicgPyAnc291cmNlJyA6IGF0dHJdID0gZGF0YShlbCwgYXR0cik7XG4gICAgICB9XG5cbiAgICAgIGl0ZW0uYXR0cnMgPSBwYXJzZU9wdGlvbnMoaXRlbS5hdHRycyk7XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIHZhciBub3RpZmljYXRpb24gPSB7XG4gICAgICBtaXhpbnM6IFtDb250YWluZXJdLFxuXG4gICAgICBmdW5jdGlvbmFsOiB0cnVlLFxuXG4gICAgICBhcmdzOiBbJ21lc3NhZ2UnLCAnc3RhdHVzJ10sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWVzc2FnZTogJycsXG4gICAgICAgIHN0YXR1czogJycsXG4gICAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgICAgIGdyb3VwOiBudWxsLFxuICAgICAgICBwb3M6ICd0b3AtY2VudGVyJyxcbiAgICAgICAgY2xzQ29udGFpbmVyOiAndWstbm90aWZpY2F0aW9uJyxcbiAgICAgICAgY2xzQ2xvc2U6ICd1ay1ub3RpZmljYXRpb24tY2xvc2UnLFxuICAgICAgICBjbHNNc2c6ICd1ay1ub3RpZmljYXRpb24tbWVzc2FnZScgfSxcblxuXG4gICAgICBpbnN0YWxsLFxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBtYXJnaW5Qcm9wKF9yZWYpIHtsZXQgeyBwb3MgfSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIFwibWFyZ2luXCIgKyAoc3RhcnRzV2l0aChwb3MsICd0b3AnKSA/ICdUb3AnIDogJ0JvdHRvbScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0UHJvcHMoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgb3BhY2l0eTogMCwgW3RoaXMubWFyZ2luUHJvcF06IC10aGlzLiRlbC5vZmZzZXRIZWlnaHQgfTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9XG4gICAgICAgICQoXCIuXCIgKyB0aGlzLmNsc0NvbnRhaW5lciArIFwiLVwiICsgdGhpcy5wb3MsIHRoaXMuY29udGFpbmVyKSB8fFxuICAgICAgICBhcHBlbmQoXG4gICAgICAgIHRoaXMuY29udGFpbmVyLCBcIjxkaXYgY2xhc3M9XFxcIlwiICtcbiAgICAgICAgdGhpcy5jbHNDb250YWluZXIgKyBcIiBcIiArIHRoaXMuY2xzQ29udGFpbmVyICsgXCItXCIgKyB0aGlzLnBvcyArIFwiXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogYmxvY2tcXFwiPjwvZGl2PlwiKTtcblxuXG4gICAgICAgIHRoaXMuJG1vdW50KFxuICAgICAgICBhcHBlbmQoXG4gICAgICAgIGNvbnRhaW5lciwgXCI8ZGl2IGNsYXNzPVxcXCJcIiArXG4gICAgICAgIHRoaXMuY2xzTXNnICsgKHRoaXMuc3RhdHVzID8gXCIgXCIgKyB0aGlzLmNsc01zZyArIFwiLVwiICsgdGhpcy5zdGF0dXMgOiAnJykgKyBcIlxcXCI+IDxhIGhyZWYgY2xhc3M9XFxcIlwiICtcbiAgICAgICAgdGhpcy5jbHNDbG9zZSArIFwiXFxcIiBkYXRhLXVrLWNsb3NlPjwvYT4gPGRpdj5cIiArXG4gICAgICAgIHRoaXMubWVzc2FnZSArIFwiPC9kaXY+IDwvZGl2PlwiKSk7XG5cblxuXG4gICAgICB9LFxuXG4gICAgICBhc3luYyBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHRvRmxvYXQoY3NzKHRoaXMuJGVsLCB0aGlzLm1hcmdpblByb3ApKTtcbiAgICAgICAgYXdhaXQgVHJhbnNpdGlvbi5zdGFydChjc3ModGhpcy4kZWwsIHRoaXMuc3RhcnRQcm9wcyksIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIFt0aGlzLm1hcmdpblByb3BdOiBtYXJnaW4gfSk7XG5cblxuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5jbG9zZSwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGNsaWNrKGUpIHtcbiAgICAgICAgICBpZiAoY2xvc2VzdChlLnRhcmdldCwgJ2FbaHJlZj1cIiNcIl0sYVtocmVmPVwiXCJdJykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFtwb2ludGVyRW50ZXJdKCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFtwb2ludGVyTGVhdmVdKCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuY2xvc2UsIHRoaXMudGltZW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBjbG9zZShpbW1lZGlhdGUpIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVGbiA9IChlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50KGVsKTtcblxuICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ2Nsb3NlJywgW3RoaXNdKTtcbiAgICAgICAgICAgIHJlbW92ZSQxKGVsKTtcblxuICAgICAgICAgICAgaWYgKCEoY29udGFpbmVyICE9IG51bGwgJiYgY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlJDEoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgYXdhaXQgVHJhbnNpdGlvbi5zdGFydCh0aGlzLiRlbCwgdGhpcy5zdGFydFByb3BzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmVGbih0aGlzLiRlbCk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoVUlraXQpIHtcbiAgICAgIFVJa2l0Lm5vdGlmaWNhdGlvbi5jbG9zZUFsbCA9IGZ1bmN0aW9uIChncm91cCwgaW1tZWRpYXRlKSB7XG4gICAgICAgIGFwcGx5KGRvY3VtZW50LmJvZHksIChlbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IFVJa2l0LmdldENvbXBvbmVudChlbCwgJ25vdGlmaWNhdGlvbicpO1xuICAgICAgICAgIGlmIChub3RpZmljYXRpb24gJiYgKCFncm91cCB8fCBncm91cCA9PT0gbm90aWZpY2F0aW9uLmdyb3VwKSkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uLmNsb3NlKGltbWVkaWF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICB4OiB0cmFuc2Zvcm1GbixcbiAgICAgIHk6IHRyYW5zZm9ybUZuLFxuICAgICAgcm90YXRlOiB0cmFuc2Zvcm1GbixcbiAgICAgIHNjYWxlOiB0cmFuc2Zvcm1GbixcbiAgICAgIGNvbG9yOiBjb2xvckZuLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvckZuLFxuICAgICAgYm9yZGVyQ29sb3I6IGNvbG9yRm4sXG4gICAgICBibHVyOiBmaWx0ZXJGbixcbiAgICAgIGh1ZTogZmlsdGVyRm4sXG4gICAgICBmb3BhY2l0eTogZmlsdGVyRm4sXG4gICAgICBncmF5c2NhbGU6IGZpbHRlckZuLFxuICAgICAgaW52ZXJ0OiBmaWx0ZXJGbixcbiAgICAgIHNhdHVyYXRlOiBmaWx0ZXJGbixcbiAgICAgIHNlcGlhOiBmaWx0ZXJGbixcbiAgICAgIG9wYWNpdHk6IGNzc1Byb3BGbixcbiAgICAgIHN0cm9rZTogc3Ryb2tlRm4sXG4gICAgICBiZ3g6IGJhY2tncm91bmRGbixcbiAgICAgIGJneTogYmFja2dyb3VuZEZuIH07XG5cblxuICAgIGNvbnN0IHsga2V5cyB9ID0gT2JqZWN0O1xuXG4gICAgdmFyIFBhcmFsbGF4ID0ge1xuICAgICAgbWl4aW5zOiBbTWVkaWFdLFxuXG4gICAgICBwcm9wczogZmlsbE9iamVjdChrZXlzKHByb3BzKSwgJ2xpc3QnKSxcblxuICAgICAgZGF0YTogZmlsbE9iamVjdChrZXlzKHByb3BzKSwgdW5kZWZpbmVkKSxcblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgcHJvcHMocHJvcGVydGllcywgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGtleXMocHJvcHMpLnJlZHVjZSgocmVzdWx0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHByb3BlcnRpZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHByb3BzW3Byb3BdKHByb3AsICRlbCwgcHJvcGVydGllc1twcm9wXS5zbGljZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGxvYWQoKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gdGhpcy5nZXRDc3MoMCkpIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgcHJvcCwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDc3MocGVyY2VudCkge1xuICAgICAgICAgIGNvbnN0IGNzcyA9IHsgdHJhbnNmb3JtOiAnJywgZmlsdGVyOiAnJyB9O1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB0aGlzLnByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzW3Byb3BdKGNzcywgcGVyY2VudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjc3M7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgbGV0IHVuaXQgPSBnZXRVbml0KHN0b3BzKSB8fCB7IHg6ICdweCcsIHk6ICdweCcsIHJvdGF0ZTogJ2RlZycgfVtwcm9wXSB8fCAnJztcbiAgICAgIGxldCB0cmFuc2Zvcm1GbjtcblxuICAgICAgaWYgKHByb3AgPT09ICd4JyB8fCBwcm9wID09PSAneScpIHtcbiAgICAgICAgcHJvcCA9IFwidHJhbnNsYXRlXCIgKyB1Y2ZpcnN0KHByb3ApO1xuICAgICAgICB0cmFuc2Zvcm1GbiA9IChzdG9wKSA9PiB0b0Zsb2F0KHRvRmxvYXQoc3RvcCkudG9GaXhlZCh1bml0ID09PSAncHgnID8gMCA6IDYpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ3NjYWxlJykge1xuICAgICAgICB1bml0ID0gJyc7XG4gICAgICAgIHRyYW5zZm9ybUZuID0gKHN0b3ApID0+XG4gICAgICAgIGdldFVuaXQoW3N0b3BdKSA/IHRvUHgoc3RvcCwgJ3dpZHRoJywgZWwsIHRydWUpIC8gZWwub2Zmc2V0V2lkdGggOiBzdG9wO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQocHJvcCA9PT0gJ3NjYWxlJyA/IDEgOiAwKTtcbiAgICAgIH1cblxuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzLCB0cmFuc2Zvcm1Gbik7XG5cbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNzcy50cmFuc2Zvcm0gKz0gXCIgXCIgKyBwcm9wICsgXCIoXCIgKyBnZXRWYWx1ZShzdG9wcywgcGVyY2VudCkgKyB1bml0ICsgXCIpXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbG9yRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoZ2V0Q3NzVmFsdWUoZWwsIHByb3AsICcnKSk7XG4gICAgICB9XG5cbiAgICAgIHN0b3BzID0gcGFyc2VTdG9wcyhzdG9wcywgKHN0b3ApID0+IHBhcnNlQ29sb3IoZWwsIHN0b3ApKTtcblxuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmQsIHBdID0gZ2V0U3RvcChzdG9wcywgcGVyY2VudCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3RhcnQuXG4gICAgICAgIG1hcCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICB2YWx1ZSArPSBwICogKGVuZFtpXSAtIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gaSA9PT0gMyA/IHRvRmxvYXQodmFsdWUpIDogcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgfSkuXG4gICAgICAgIGpvaW4oJywnKTtcbiAgICAgICAgY3NzW3Byb3BdID0gXCJyZ2JhKFwiICsgdmFsdWUgKyBcIilcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb2xvcihlbCwgY29sb3IpIHtcbiAgICAgIHJldHVybiBnZXRDc3NWYWx1ZShlbCwgJ2NvbG9yJywgY29sb3IpLlxuICAgICAgc3BsaXQoL1soKSxdL2cpLlxuICAgICAgc2xpY2UoMSwgLTEpLlxuICAgICAgY29uY2F0KDEpLlxuICAgICAgc2xpY2UoMCwgNCkuXG4gICAgICBtYXAodG9GbG9hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVuaXQgPSBnZXRVbml0KHN0b3BzKSB8fCB7IGJsdXI6ICdweCcsIGh1ZTogJ2RlZycgfVtwcm9wXSB8fCAnJSc7XG4gICAgICBwcm9wID0geyBmb3BhY2l0eTogJ29wYWNpdHknLCBodWU6ICdodWUtcm90YXRlJyB9W3Byb3BdIHx8IHByb3A7XG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMpO1xuXG4gICAgICByZXR1cm4gKGNzcywgcGVyY2VudCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgICAgY3NzLmZpbHRlciArPSBcIiBcIiArIHByb3AgKyBcIihcIiArICh2YWx1ZSArIHVuaXQpICsgXCIpXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNzc1Byb3BGbihwcm9wLCBlbCwgc3RvcHMpIHtcbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdChnZXRDc3NWYWx1ZShlbCwgcHJvcCwgJycpKTtcbiAgICAgIH1cblxuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzKTtcblxuICAgICAgcmV0dXJuIChjc3MsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY3NzW3Byb3BdID0gZ2V0VmFsdWUoc3RvcHMsIHBlcmNlbnQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJva2VGbihwcm9wLCBlbCwgc3RvcHMpIHtcbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdCgwKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdW5pdCA9IGdldFVuaXQoc3RvcHMpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TWF4UGF0aExlbmd0aChlbCk7XG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMucmV2ZXJzZSgpLCAoc3RvcCkgPT4ge1xuICAgICAgICBzdG9wID0gdG9GbG9hdChzdG9wKTtcbiAgICAgICAgcmV0dXJuIHVuaXQgPT09ICclJyA/IHN0b3AgKiBsZW5ndGggLyAxMDAgOiBzdG9wO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghc3RvcHMuc29tZSgoX3JlZikgPT4ge2xldCBbdmFsdWVdID0gX3JlZjtyZXR1cm4gdmFsdWU7fSkpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICB9XG5cbiAgICAgIGNzcyhlbCwgJ3N0cm9rZURhc2hhcnJheScsIGxlbmd0aCk7XG5cbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNzcy5zdHJva2VEYXNob2Zmc2V0ID0gZ2V0VmFsdWUoc3RvcHMsIHBlcmNlbnQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiYWNrZ3JvdW5kRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoMCk7XG4gICAgICB9XG5cbiAgICAgIHByb3AgPSBwcm9wLnN1YnN0cigtMSk7XG4gICAgICBjb25zdCBhdHRyID0gcHJvcCA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzLCAoc3RvcCkgPT4gdG9QeChzdG9wLCBhdHRyLCBlbCkpO1xuXG4gICAgICBjb25zdCBiZ1BvcyA9IGdldENzc1ZhbHVlKGVsLCBcImJhY2tncm91bmQtcG9zaXRpb24tXCIgKyBwcm9wLCAnJyk7XG5cbiAgICAgIHJldHVybiBnZXRDc3NWYWx1ZShlbCwgJ2JhY2tncm91bmRTaXplJywgJycpID09PSAnY292ZXInID9cbiAgICAgIGJhY2tncm91bmRDb3ZlckZuKHByb3AsIGVsLCBzdG9wcywgYmdQb3MsIGF0dHIpIDpcbiAgICAgIHNldEJhY2tncm91bmRQb3NGbihwcm9wLCBzdG9wcywgYmdQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhY2tncm91bmRDb3ZlckZuKHByb3AsIGVsLCBzdG9wcywgYmdQb3MsIGF0dHIpIHtcbiAgICAgIGNvbnN0IGRpbUltYWdlID0gZ2V0QmFja2dyb3VuZEltYWdlRGltZW5zaW9ucyhlbCk7XG5cbiAgICAgIGlmICghZGltSW1hZ2Uud2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlcyA9IHN0b3BzLm1hcCgoX3JlZjIpID0+IHtsZXQgW3ZhbHVlXSA9IF9yZWYyO3JldHVybiB2YWx1ZTt9KTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKC4uLnZhbHVlcyk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heCguLi52YWx1ZXMpO1xuICAgICAgY29uc3QgZG93biA9IHZhbHVlcy5pbmRleE9mKG1pbikgPCB2YWx1ZXMuaW5kZXhPZihtYXgpO1xuXG4gICAgICBjb25zdCBkaWZmID0gbWF4IC0gbWluO1xuICAgICAgbGV0IHBvcyA9IChkb3duID8gLWRpZmYgOiAwKSAtIChkb3duID8gbWluIDogbWF4KTtcblxuICAgICAgY29uc3QgZGltRWwgPSB7XG4gICAgICAgIHdpZHRoOiBlbC5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbC5vZmZzZXRIZWlnaHQgfTtcblxuXG4gICAgICBjb25zdCBiYXNlRGltID0gRGltZW5zaW9ucy5jb3ZlcihkaW1JbWFnZSwgZGltRWwpO1xuICAgICAgY29uc3Qgc3BhbiA9IGJhc2VEaW1bYXR0cl0gLSBkaW1FbFthdHRyXTtcblxuICAgICAgaWYgKHNwYW4gPCBkaWZmKSB7XG4gICAgICAgIGRpbUVsW2F0dHJdID0gYmFzZURpbVthdHRyXSArIGRpZmYgLSBzcGFuO1xuICAgICAgfSBlbHNlIGlmIChzcGFuID4gZGlmZikge1xuICAgICAgICBjb25zdCBwb3NQZXJjZW50YWdlID0gZGltRWxbYXR0cl0gLyB0b1B4KGJnUG9zLCBhdHRyLCBlbCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHBvc1BlcmNlbnRhZ2UpIHtcbiAgICAgICAgICBwb3MgLT0gKHNwYW4gLSBkaWZmKSAvIHBvc1BlcmNlbnRhZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZGltID0gRGltZW5zaW9ucy5jb3ZlcihkaW1JbWFnZSwgZGltRWwpO1xuXG4gICAgICBjb25zdCBmbiA9IHNldEJhY2tncm91bmRQb3NGbihwcm9wLCBzdG9wcywgcG9zICsgXCJweFwiKTtcbiAgICAgIHJldHVybiAoY3NzLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGZuKGNzcywgcGVyY2VudCk7XG4gICAgICAgIGNzcy5iYWNrZ3JvdW5kU2l6ZSA9IGRpbS53aWR0aCArIFwicHggXCIgKyBkaW0uaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBjc3MuYmFja2dyb3VuZFJlcGVhdCA9ICduby1yZXBlYXQnO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRCYWNrZ3JvdW5kUG9zRm4ocHJvcCwgc3RvcHMsIHBvcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjc3MsIHBlcmNlbnQpIHtcbiAgICAgICAgY3NzW1wiYmFja2dyb3VuZC1wb3NpdGlvbi1cIiArIHByb3BdID0gXCJjYWxjKFwiICsgcG9zICsgXCIgKyBcIiArIGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KSArIFwicHgpXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kSW1hZ2VEaW1lbnNpb25zKGVsKSB7XG4gICAgICBjb25zdCBzcmMgPSBjc3MoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKS5yZXBsYWNlKC9ebm9uZXx1cmxcXChbXCInXT8oLis/KVtcIiddP1xcKSQvLCAnJDEnKTtcblxuICAgICAgaWYgKGRpbWVuc2lvbnNbc3JjXSkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uc1tzcmNdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XG5cbiAgICAgICAgaWYgKCFpbWFnZS5uYXR1cmFsV2lkdGgpIHtcbiAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkaW1lbnNpb25zW3NyY10gPSB0b0RpbWVuc2lvbnMoaW1hZ2UpO1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQoJ2xvYWQnLCBmYWxzZSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRvRGltZW5zaW9ucyhpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbWVuc2lvbnNbc3JjXSA9IHRvRGltZW5zaW9ucyhpbWFnZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EaW1lbnNpb25zKGltYWdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogaW1hZ2UubmF0dXJhbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltYWdlLm5hdHVyYWxIZWlnaHQgfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RvcHMoc3RvcHMsIGZuKSB7aWYgKGZuID09PSB2b2lkIDApIHtmbiA9IHRvRmxvYXQ7fVxuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gc3RvcHM7XG4gICAgICBsZXQgbnVsbEluZGV4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IFt2YWx1ZSwgcGVyY2VudF0gPSBpc1N0cmluZyhzdG9wc1tpXSkgPyBzdG9wc1tpXS50cmltKCkuc3BsaXQoJyAnKSA6IFtzdG9wc1tpXV07XG4gICAgICAgIHZhbHVlID0gZm4odmFsdWUpO1xuICAgICAgICBwZXJjZW50ID0gcGVyY2VudCA/IHRvRmxvYXQocGVyY2VudCkgLyAxMDAgOiBudWxsO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgaWYgKHBlcmNlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3ZhbHVlLCAwXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpZiAocGVyY2VudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50ICE9PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbdmFsdWUsIHBlcmNlbnRdKTtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFt2YWx1ZSwgcGVyY2VudF0pO1xuXG4gICAgICAgIGlmIChwZXJjZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgbnVsbEluZGV4Kys7XG4gICAgICAgIH0gZWxzZSBpZiAobnVsbEluZGV4KSB7XG4gICAgICAgICAgY29uc3QgbGVmdFBlcmNlbnQgPSByZXN1bHRbaSAtIG51bGxJbmRleCAtIDFdWzFdO1xuICAgICAgICAgIGNvbnN0IHAgPSAocGVyY2VudCAtIGxlZnRQZXJjZW50KSAvIChudWxsSW5kZXggKyAxKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gbnVsbEluZGV4OyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICByZXN1bHRbaSAtIGpdWzFdID0gbGVmdFBlcmNlbnQgKyBwICogKG51bGxJbmRleCAtIGogKyAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBudWxsSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RvcChzdG9wcywgcGVyY2VudCkge1xuICAgICAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgoc3RvcHMuc2xpY2UoMSksIChfcmVmMykgPT4ge2xldCBbLCB0YXJnZXRQZXJjZW50XSA9IF9yZWYzO3JldHVybiBwZXJjZW50IDw9IHRhcmdldFBlcmNlbnQ7fSkgKyAxO1xuICAgICAgcmV0dXJuIFtcbiAgICAgIHN0b3BzW2luZGV4IC0gMV1bMF0sXG4gICAgICBzdG9wc1tpbmRleF1bMF0sXG4gICAgICAocGVyY2VudCAtIHN0b3BzW2luZGV4IC0gMV1bMV0pIC8gKHN0b3BzW2luZGV4XVsxXSAtIHN0b3BzW2luZGV4IC0gMV1bMV0pXTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZCwgcF0gPSBnZXRTdG9wKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgIHJldHVybiBpc051bWJlcihzdGFydCkgPyBzdGFydCArIE1hdGguYWJzKHN0YXJ0IC0gZW5kKSAqIHAgKiAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogK2VuZDtcbiAgICB9XG5cbiAgICBjb25zdCB1bml0UmUgPSAvXi0/XFxkKyhcXFMqKS87XG4gICAgZnVuY3Rpb24gZ2V0VW5pdChzdG9wcywgZGVmYXVsdFVuaXQpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RvcCBvZiBzdG9wcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN0b3AubWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3AubWF0Y2godW5pdFJlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmYXVsdFVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q3NzVmFsdWUoZWwsIHByb3AsIHZhbHVlKSB7XG4gICAgICBjb25zdCBwcmV2ID0gZWwuc3R5bGVbcHJvcF07XG4gICAgICBjb25zdCB2YWwgPSBjc3MoY3NzKGVsLCBwcm9wLCB2YWx1ZSksIHByb3ApO1xuICAgICAgZWwuc3R5bGVbcHJvcF0gPSBwcmV2O1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWxsT2JqZWN0KGtleXMsIHZhbHVlKSB7XG4gICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKGRhdGEsIHByb3ApID0+IHtcbiAgICAgICAgZGF0YVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYWxsYXggPSB7XG4gICAgICBtaXhpbnM6IFtQYXJhbGxheCwgUmVzaXplLCBTY3JvbGxdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICAgICAgdmlld3BvcnQ6IE51bWJlciwgLy8gRGVwcmVjYXRlZFxuICAgICAgICBlYXNpbmc6IE51bWJlcixcbiAgICAgICAgc3RhcnQ6IFN0cmluZyxcbiAgICAgICAgZW5kOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIHZpZXdwb3J0OiAxLFxuICAgICAgICBlYXNpbmc6IDEsXG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IDAgfSxcblxuXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICB0YXJnZXQoX3JlZiwgJGVsKSB7bGV0IHsgdGFyZ2V0IH0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBnZXRPZmZzZXRFbGVtZW50KHRhcmdldCAmJiBxdWVyeSh0YXJnZXQsICRlbCkgfHwgJGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydChfcmVmMikge2xldCB7IHN0YXJ0IH0gPSBfcmVmMjtcbiAgICAgICAgICByZXR1cm4gdG9QeChzdGFydCwgJ2hlaWdodCcsIHRoaXMudGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmQoX3JlZjMpIHtsZXQgeyBlbmQsIHZpZXdwb3J0IH0gPSBfcmVmMztcbiAgICAgICAgICByZXR1cm4gdG9QeChcbiAgICAgICAgICBlbmQgfHwgKHZpZXdwb3J0ID0gKDEgLSB2aWV3cG9ydCkgKiAxMDApICYmIHZpZXdwb3J0ICsgXCJ2aCtcIiArIHZpZXdwb3J0ICsgXCIlXCIsXG4gICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgdGhpcy50YXJnZXQsXG4gICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKF9yZWY0LCB0eXBlcykge2xldCB7IHBlcmNlbnQgfSA9IF9yZWY0O1xuICAgICAgICAgIGlmICghdHlwZXMuaGFzKCdzY3JvbGwnKSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5tYXRjaE1lZGlhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJldiA9IHBlcmNlbnQ7XG4gICAgICAgICAgcGVyY2VudCA9IGVhc2Uoc2Nyb2xsZWRPdmVyKHRoaXMudGFyZ2V0LCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCksIHRoaXMuZWFzaW5nKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwZXJjZW50LFxuICAgICAgICAgICAgc3R5bGU6IHByZXYgPT09IHBlcmNlbnQgPyBmYWxzZSA6IHRoaXMuZ2V0Q3NzKHBlcmNlbnQpIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmNSkge2xldCB7IHN0eWxlIH0gPSBfcmVmNTtcbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hNZWRpYSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0eWxlICYmIGNzcyh0aGlzLiRlbCwgc3R5bGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW50czogWydzY3JvbGwnLCAncmVzaXplJ10gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGVhc2UocGVyY2VudCwgZWFzaW5nKSB7XG4gICAgICByZXR1cm4gZWFzaW5nID49IDAgPyBNYXRoLnBvdyhwZXJjZW50LCBlYXNpbmcgKyAxKSA6IDEgLSBNYXRoLnBvdygxIC0gcGVyY2VudCwgLWVhc2luZyArIDEpO1xuICAgIH1cblxuICAgIC8vIFNWRyBlbGVtZW50cyBkbyBub3QgaW5oZXJpdCBmcm9tIEhUTUxFbGVtZW50XG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0RWxlbWVudChlbCkge1xuICAgICAgcmV0dXJuIGVsID8gJ29mZnNldFRvcCcgaW4gZWwgPyBlbCA6IGdldE9mZnNldEVsZW1lbnQocGFyZW50KGVsKSkgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIFNsaWRlclJlYWN0aXZlID0ge1xuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHdyaXRlKCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCB8fCB0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldFZhbGlkSW5kZXgodGhpcy5pbmRleCk7XG5cbiAgICAgICAgICBpZiAoIX50aGlzLnByZXZJbmRleCB8fCB0aGlzLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zaG93KGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0gfTtcblxuICAgIHZhciBTbGlkZXJQcmVsb2FkID0ge1xuICAgICAgbWl4aW5zOiBbTGF6eWxvYWRdLFxuXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMubGF6eWxvYWQodGhpcy5zbGlkZXMsIHRoaXMuZ2V0QWRqYWNlbnRTbGlkZXMpO1xuICAgICAgfSB9O1xuXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbmVyIChwcmV2LCBuZXh0LCBkaXIsIF9yZWYpIHtsZXQgeyBjZW50ZXIsIGVhc2luZywgbGlzdCB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG5cbiAgICAgIGNvbnN0IGZyb20gPSBwcmV2ID9cbiAgICAgIGdldExlZnQocHJldiwgbGlzdCwgY2VudGVyKSA6XG4gICAgICBnZXRMZWZ0KG5leHQsIGxpc3QsIGNlbnRlcikgKyBkaW1lbnNpb25zJDEobmV4dCkud2lkdGggKiBkaXI7XG4gICAgICBjb25zdCB0byA9IG5leHQgP1xuICAgICAgZ2V0TGVmdChuZXh0LCBsaXN0LCBjZW50ZXIpIDpcbiAgICAgIGZyb20gKyBkaW1lbnNpb25zJDEocHJldikud2lkdGggKiBkaXIgKiAoaXNSdGwgPyAtMSA6IDEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXIsXG5cbiAgICAgICAgc2hvdyhkdXJhdGlvbiwgcGVyY2VudCwgbGluZWFyKSB7aWYgKHBlcmNlbnQgPT09IHZvaWQgMCkge3BlcmNlbnQgPSAwO31cbiAgICAgICAgICBjb25zdCB0aW1pbmcgPSBsaW5lYXIgPyAnbGluZWFyJyA6IGVhc2luZztcbiAgICAgICAgICBkdXJhdGlvbiAtPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogY2xhbXAocGVyY2VudCwgLTEsIDEpKTtcblxuICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHBlcmNlbnQpO1xuXG4gICAgICAgICAgcGVyY2VudCA9IHByZXYgPyBwZXJjZW50IDogY2xhbXAocGVyY2VudCwgMCwgMSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZSh0aGlzLmdldEl0ZW1JbigpLCAnaXRlbWluJywgeyBwZXJjZW50LCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSk7XG4gICAgICAgICAgcHJldiAmJlxuICAgICAgICAgIHRyaWdnZXJVcGRhdGUodGhpcy5nZXRJdGVtSW4odHJ1ZSksICdpdGVtb3V0Jywge1xuICAgICAgICAgICAgcGVyY2VudDogMSAtIHBlcmNlbnQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZyxcbiAgICAgICAgICAgIGRpciB9KTtcblxuXG4gICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChcbiAgICAgICAgICBsaXN0LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLXRvICogKGlzUnRsID8gLTEgOiAxKSwgJ3B4JykgfSxcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmcpLlxuICAgICAgICAgIHRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgbm9vcCk7XG5cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwobGlzdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgY3NzKGxpc3QsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yd2FyZChkdXJhdGlvbiwgcGVyY2VudCkge2lmIChwZXJjZW50ID09PSB2b2lkIDApIHtwZXJjZW50ID0gdGhpcy5wZXJjZW50KCk7fVxuICAgICAgICAgIFRyYW5zaXRpb24uY2FuY2VsKGxpc3QpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNob3coZHVyYXRpb24sIHBlcmNlbnQsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmdldERpc3RhbmNlKCkgKiBkaXIgKiAoaXNSdGwgPyAtMSA6IDEpO1xuXG4gICAgICAgICAgY3NzKFxuICAgICAgICAgIGxpc3QsXG4gICAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICAgdHJhbnNsYXRlKFxuICAgICAgICAgIGNsYW1wKFxuICAgICAgICAgIC10byArIChkaXN0YW5jZSAtIGRpc3RhbmNlICogcGVyY2VudCksXG4gICAgICAgICAgLWdldFdpZHRoKGxpc3QpLFxuICAgICAgICAgIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCkgKiAoXG4gICAgICAgICAgaXNSdGwgPyAtMSA6IDEpLFxuICAgICAgICAgICdweCcpKTtcblxuXG5cbiAgICAgICAgICBjb25zdCBhY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVzKCk7XG4gICAgICAgICAgY29uc3QgaXRlbUluID0gdGhpcy5nZXRJdGVtSW4oKTtcbiAgICAgICAgICBjb25zdCBpdGVtT3V0ID0gdGhpcy5nZXRJdGVtSW4odHJ1ZSk7XG5cbiAgICAgICAgICBwZXJjZW50ID0gcHJldiA/IGNsYW1wKHBlcmNlbnQsIC0xLCAxKSA6IDA7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHNsaWRlIG9mIGNoaWxkcmVuKGxpc3QpKSB7XG4gICAgICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IGluY2x1ZGVzKGFjdGl2ZXMsIHNsaWRlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW4gPSBzbGlkZSA9PT0gaXRlbUluO1xuICAgICAgICAgICAgY29uc3QgaXNPdXQgPSBzbGlkZSA9PT0gaXRlbU91dDtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZUluID1cbiAgICAgICAgICAgIGlzSW4gfHxcbiAgICAgICAgICAgICFpc091dCAmJiAoXG4gICAgICAgICAgICBpc0FjdGl2ZSB8fFxuICAgICAgICAgICAgZGlyICogKGlzUnRsID8gLTEgOiAxKSA9PT0gLTEgXlxuICAgICAgICAgICAgZ2V0RWxMZWZ0KHNsaWRlLCBsaXN0KSA+IGdldEVsTGVmdChwcmV2IHx8IG5leHQpKTtcblxuICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZShzbGlkZSwgXCJpdGVtdHJhbnNsYXRlXCIgKyAodHJhbnNsYXRlSW4gPyAnaW4nIDogJ291dCcpLCB7XG4gICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgcGVyY2VudDogaXNPdXQgPyAxIC0gcGVyY2VudCA6IGlzSW4gPyBwZXJjZW50IDogaXNBY3RpdmUgPyAxIDogMCB9KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhcbiAgICAgICAgICAoY3NzKGxpc3QsICd0cmFuc2Zvcm0nKS5zcGxpdCgnLCcpWzRdICogKGlzUnRsID8gLTEgOiAxKSArIGZyb20pIC8gKHRvIC0gZnJvbSkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGlzdGFuY2UoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvIC0gZnJvbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SXRlbUluKG91dCkge2lmIChvdXQgPT09IHZvaWQgMCkge291dCA9IGZhbHNlO31cbiAgICAgICAgICBsZXQgYWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlcygpO1xuICAgICAgICAgIGxldCBuZXh0QWN0aXZlcyA9IGluVmlldyhsaXN0LCBnZXRMZWZ0KG5leHQgfHwgcHJldiwgbGlzdCwgY2VudGVyKSk7XG5cbiAgICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gYWN0aXZlcztcbiAgICAgICAgICAgIGFjdGl2ZXMgPSBuZXh0QWN0aXZlcztcbiAgICAgICAgICAgIG5leHRBY3RpdmVzID0gdGVtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV4dEFjdGl2ZXNbZmluZEluZGV4KG5leHRBY3RpdmVzLCAoZWwpID0+ICFpbmNsdWRlcyhhY3RpdmVzLCBlbCkpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBY3RpdmVzKCkge1xuICAgICAgICAgIHJldHVybiBpblZpZXcobGlzdCwgZ2V0TGVmdChwcmV2IHx8IG5leHQsIGxpc3QsIGNlbnRlcikpO1xuICAgICAgICB9IH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMZWZ0KGVsLCBsaXN0LCBjZW50ZXIpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBnZXRFbExlZnQoZWwsIGxpc3QpO1xuXG4gICAgICByZXR1cm4gY2VudGVyID8gbGVmdCAtIGNlbnRlckVsKGVsLCBsaXN0KSA6IE1hdGgubWluKGxlZnQsIGdldE1heChsaXN0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWF4KGxpc3QpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBnZXRXaWR0aChsaXN0KSAtIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2lkdGgobGlzdCkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuKGxpc3QpLnJlZHVjZSgocmlnaHQsIGVsKSA9PiBkaW1lbnNpb25zJDEoZWwpLndpZHRoICsgcmlnaHQsIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlbnRlckVsKGVsLCBsaXN0KSB7XG4gICAgICByZXR1cm4gZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoIC8gMiAtIGRpbWVuc2lvbnMkMShlbCkud2lkdGggLyAyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVsTGVmdChlbCwgbGlzdCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZWwgJiZcbiAgICAgICAgKHBvc2l0aW9uKGVsKS5sZWZ0ICsgKGlzUnRsID8gZGltZW5zaW9ucyQxKGVsKS53aWR0aCAtIGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aCA6IDApKSAqIChcbiAgICAgICAgaXNSdGwgPyAtMSA6IDEpIHx8XG4gICAgICAgIDApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5WaWV3KGxpc3QsIGxpc3RMZWZ0KSB7XG4gICAgICBsaXN0TGVmdCAtPSAxO1xuICAgICAgY29uc3QgbGlzdFdpZHRoID0gZGltZW5zaW9ucyQxKGxpc3QpLndpZHRoO1xuICAgICAgY29uc3QgbGlzdFJpZ2h0ID0gbGlzdExlZnQgKyBsaXN0V2lkdGggKyAyO1xuXG4gICAgICByZXR1cm4gY2hpbGRyZW4obGlzdCkuZmlsdGVyKChzbGlkZSkgPT4ge1xuICAgICAgICBjb25zdCBzbGlkZUxlZnQgPSBnZXRFbExlZnQoc2xpZGUsIGxpc3QpO1xuICAgICAgICBjb25zdCBzbGlkZVJpZ2h0ID0gc2xpZGVMZWZ0ICsgTWF0aC5taW4oZGltZW5zaW9ucyQxKHNsaWRlKS53aWR0aCwgbGlzdFdpZHRoKTtcblxuICAgICAgICByZXR1cm4gc2xpZGVMZWZ0ID49IGxpc3RMZWZ0ICYmIHNsaWRlUmlnaHQgPD0gbGlzdFJpZ2h0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZShlbCwgdHlwZSwgZGF0YSkge1xuICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIHNsaWRlciA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBTbGlkZXIsIFNsaWRlclJlYWN0aXZlLCBTbGlkZXJQcmVsb2FkXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2VudGVyOiBCb29sZWFuLFxuICAgICAgICBzZXRzOiBCb29sZWFuIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICBjZW50ZXI6IGZhbHNlLFxuICAgICAgICBzZXRzOiBmYWxzZSxcbiAgICAgICAgYXR0ckl0ZW06ICd1ay1zbGlkZXItaXRlbScsXG4gICAgICAgIHNlbExpc3Q6ICcudWstc2xpZGVyLWl0ZW1zJyxcbiAgICAgICAgc2VsTmF2OiAnLnVrLXNsaWRlci1uYXYnLFxuICAgICAgICBjbHNDb250YWluZXI6ICd1ay1zbGlkZXItY29udGFpbmVyJyxcbiAgICAgICAgVHJhbnNpdGlvbmVyIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYXZnV2lkdGgoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFdpZHRoKHRoaXMubGlzdCkgLyB0aGlzLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pdGUoX3JlZikge2xldCB7IGZpbml0ZSB9ID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZmluaXRlIHx8XG4gICAgICAgICAgICBNYXRoLmNlaWwoZ2V0V2lkdGgodGhpcy5saXN0KSkgPFxuICAgICAgICAgICAgTWF0aC50cnVuYyhkaW1lbnNpb25zJDEodGhpcy5saXN0KS53aWR0aCArIGdldE1heEVsV2lkdGgodGhpcy5saXN0KSArIHRoaXMuY2VudGVyKSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBtYXhJbmRleCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZmluaXRlIHx8IHRoaXMuY2VudGVyICYmICF0aGlzLnNldHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdCh0aGlzLnNldHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBsZnQgPSAwO1xuICAgICAgICAgIGNvbnN0IG1heCA9IGdldE1heCh0aGlzLmxpc3QpO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KHRoaXMuc2xpZGVzLCAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChsZnQgPj0gbWF4KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZnQgKz0gZGltZW5zaW9ucyQxKGVsKS53aWR0aDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB+aW5kZXggPyBpbmRleCA6IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRzKF9yZWYyKSB7bGV0IHsgc2V0czogZW5hYmxlZCB9ID0gX3JlZjI7XG4gICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICAgIGNvbnN0IHNldHMgPSBbXTtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpLndpZHRoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlV2lkdGggPSBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbaV0pLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAobGVmdCArIHNsaWRlV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGVmdCA8IHdpZHRoIC8gMiAmJlxuICAgICAgICAgICAgICBsZWZ0ICsgc2xpZGVXaWR0aCArIGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1sraSArIDFdKS53aWR0aCAvIDIgPiB3aWR0aCAvIDIpXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZXRzLnB1c2goK2kpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB3aWR0aCAvIDIgLSBzbGlkZVdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgIHNldHMucHVzaChNYXRoLm1pbigraSwgdGhpcy5tYXhJbmRleCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0ICs9IHNsaWRlV2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5jZW50ZXIsXG4gICAgICAgICAgICBsaXN0OiB0aGlzLmxpc3QgfTtcblxuICAgICAgICB9IH0sXG5cblxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNDb250YWluZXIsICEkKFwiLlwiICsgdGhpcy5jbHNDb250YWluZXIsIHRoaXMuJGVsKSk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgd3JpdGUoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLm5hdkl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRvTnVtYmVyKGRhdGEoZWwsIHRoaXMuYXR0ckl0ZW0pKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZWwuaGlkZGVuID1cbiAgICAgICAgICAgICAgIXRoaXMubWF4SW5kZXggfHxcbiAgICAgICAgICAgICAgaW5kZXggPiB0aGlzLm1heEluZGV4IHx8XG4gICAgICAgICAgICAgIHRoaXMuc2V0cyAmJiAhaW5jbHVkZXModGhpcy5zZXRzLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMubGVuZ3RoICYmICF0aGlzLmRyYWdnaW5nICYmICF0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZW9yZGVyKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGUoMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVDbGFzc2VzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGJlZm9yZWl0ZW1zaG93KGUpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXMuZHJhZ2dpbmcgJiZcbiAgICAgICAgICB0aGlzLnNldHMgJiZcbiAgICAgICAgICB0aGlzLnN0YWNrLmxlbmd0aCA8IDIgJiZcbiAgICAgICAgICAhaW5jbHVkZXModGhpcy5zZXRzLCB0aGlzLmluZGV4KSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5nZXRWYWxpZEluZGV4KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKFxuICAgICAgICAgIHRoaXMuaW5kZXggLVxuICAgICAgICAgIHRoaXMucHJldkluZGV4ICsgKFxuICAgICAgICAgIHRoaXMuZGlyID4gMCAmJiB0aGlzLmluZGV4IDwgdGhpcy5wcmV2SW5kZXggfHxcbiAgICAgICAgICB0aGlzLmRpciA8IDAgJiYgdGhpcy5pbmRleCA+IHRoaXMucHJldkluZGV4ID9cbiAgICAgICAgICAodGhpcy5tYXhJbmRleCArIDEpICogdGhpcy5kaXIgOlxuICAgICAgICAgIDApKTtcblxuXG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nICYmIGRpZmYgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnNwbGljZSgxLCAwLCB0aGlzLmRpciA+IDAgPyAnbmV4dCcgOiAncHJldmlvdXMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGluZGV4ID1cbiAgICAgICAgICB0aGlzLmRpciA8IDAgfHwgIXRoaXMuc2xpZGVzW3RoaXMucHJldkluZGV4XSA/IHRoaXMuaW5kZXggOiB0aGlzLnByZXZJbmRleDtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID1cbiAgICAgICAgICBzcGVlZFVwKHRoaXMuYXZnV2lkdGggLyB0aGlzLnZlbG9jaXR5KSAqIChcbiAgICAgICAgICBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbaW5kZXhdKS53aWR0aCAvIHRoaXMuYXZnV2lkdGgpO1xuXG4gICAgICAgICAgdGhpcy5yZW9yZGVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbXNob3coKSB7XG4gICAgICAgICAgaWYgKH50aGlzLnByZXZJbmRleCkge1xuICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy5fZ2V0VHJhbnNpdGlvbmVyKCkuZ2V0SXRlbUluKCksIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXRlbXNob3duKCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZlQ2xhc3NlcygpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICByZW9yZGVyKCkge1xuICAgICAgICAgIGlmICh0aGlzLmZpbml0ZSkge1xuICAgICAgICAgICAgY3NzKHRoaXMuc2xpZGVzLCAnb3JkZXInLCAnJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRpciA+IDAgJiYgdGhpcy5zbGlkZXNbdGhpcy5wcmV2SW5kZXhdID8gdGhpcy5wcmV2SW5kZXggOiB0aGlzLmluZGV4O1xuXG4gICAgICAgICAgdGhpcy5zbGlkZXMuZm9yRWFjaCgoc2xpZGUsIGkpID0+XG4gICAgICAgICAgY3NzKFxuICAgICAgICAgIHNsaWRlLFxuICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgdGhpcy5kaXIgPiAwICYmIGkgPCBpbmRleCA/IDEgOiB0aGlzLmRpciA8IDAgJiYgaSA+PSB0aGlzLmluZGV4ID8gLTEgOiAnJykpO1xuXG5cblxuICAgICAgICAgIGlmICghdGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5zbGlkZXNbaW5kZXhdO1xuICAgICAgICAgIGxldCB3aWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpLndpZHRoIC8gMiAtIGRpbWVuc2lvbnMkMShuZXh0KS53aWR0aCAvIDI7XG4gICAgICAgICAgbGV0IGogPSAwO1xuXG4gICAgICAgICAgd2hpbGUgKHdpZHRoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IHRoaXMuZ2V0SW5kZXgoLS1qICsgaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5zbGlkZXNbc2xpZGVJbmRleF07XG5cbiAgICAgICAgICAgIGNzcyhzbGlkZSwgJ29yZGVyJywgc2xpZGVJbmRleCA+IGluZGV4ID8gLTIgOiAtMSk7XG4gICAgICAgICAgICB3aWR0aCAtPSBkaW1lbnNpb25zJDEoc2xpZGUpLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVBY3RpdmVDbGFzc2VzKCkge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZXMgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIodGhpcy5pbmRleCkuZ2V0QWN0aXZlcygpO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUNsYXNzZXMgPSBbXG4gICAgICAgICAgdGhpcy5jbHNBY3RpdmUsXG4gICAgICAgICAgKCF0aGlzLnNldHMgfHwgaW5jbHVkZXModGhpcy5zZXRzLCB0b0Zsb2F0KHRoaXMuaW5kZXgpKSkgJiYgdGhpcy5jbHNBY3RpdmF0ZWQgfHxcbiAgICAgICAgICAnJ107XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHNsaWRlIG9mIHRoaXMuc2xpZGVzKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzbGlkZSwgYWN0aXZlQ2xhc3NlcywgaW5jbHVkZXMoYWN0aXZlcywgc2xpZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VmFsaWRJbmRleChpbmRleCwgcHJldkluZGV4KSB7aWYgKGluZGV4ID09PSB2b2lkIDApIHtpbmRleCA9IHRoaXMuaW5kZXg7fWlmIChwcmV2SW5kZXggPT09IHZvaWQgMCkge3ByZXZJbmRleCA9IHRoaXMucHJldkluZGV4O31cbiAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoaW5kZXgsIHByZXZJbmRleCk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuc2V0cykge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBwcmV2O1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVzKHRoaXMuc2V0cywgaW5kZXgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldiA9IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmdldEluZGV4KGluZGV4ICsgdGhpcy5kaXIsIHByZXZJbmRleCk7XG4gICAgICAgICAgfSB3aGlsZSAoaW5kZXggIT09IHByZXYpO1xuXG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFkamFjZW50U2xpZGVzKCkge1xuICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSAtd2lkdGg7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSB3aWR0aCAqIDI7XG4gICAgICAgICAgY29uc3Qgc2xpZGVXaWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1t0aGlzLmluZGV4XSkud2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2xpZGVMZWZ0ID0gdGhpcy5jZW50ZXIgPyB3aWR0aCAvIDIgLSBzbGlkZVdpZHRoIC8gMiA6IDA7XG4gICAgICAgICAgY29uc3Qgc2xpZGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBbLTEsIDFdKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExlZnQgPSBzbGlkZUxlZnQgKyAoaSA+IDAgPyBzbGlkZVdpZHRoIDogMCk7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5zbGlkZXNbdGhpcy5nZXRJbmRleCh0aGlzLmluZGV4ICsgaSArIGorKyAqIGkpXTtcbiAgICAgICAgICAgICAgY3VycmVudExlZnQgKz0gZGltZW5zaW9ucyQxKHNsaWRlKS53aWR0aCAqIGk7XG4gICAgICAgICAgICAgIHNsaWRlcy5hZGQoc2xpZGUpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5zbGlkZXMubGVuZ3RoID4gaiAmJiBjdXJyZW50TGVmdCA+IGxlZnQgJiYgY3VycmVudExlZnQgPCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHNsaWRlcyk7XG4gICAgICAgIH0gfSB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldE1heEVsV2lkdGgobGlzdCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIC4uLmNoaWxkcmVuKGxpc3QpLm1hcCgoZWwpID0+IGRpbWVuc2lvbnMkMShlbCkud2lkdGgpKTtcbiAgICB9XG5cbiAgICB2YXIgc2xpZGVyUGFyYWxsYXggPSB7XG4gICAgICBtaXhpbnM6IFtQYXJhbGxheF0sXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2VsSXRlbTogJyFsaScgfSxcblxuXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLml0ZW0gPSBxdWVyeSh0aGlzLnNlbEl0ZW0sIHRoaXMuJGVsKTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5pdGVtID0gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnaXRlbWluIGl0ZW1vdXQnLFxuXG4gICAgICAgIHNlbGY6IHRydWUsXG5cbiAgICAgICAgZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVyKF9yZWYpIHtsZXQgeyB0eXBlLCBkZXRhaWw6IHsgcGVyY2VudCwgZHVyYXRpb24sIHRpbWluZywgZGlyIH0gfSA9IF9yZWY7XG4gICAgICAgICAgZmFzdGRvbS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzRnJvbSA9IHRoaXMuZ2V0Q3NzKGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkpO1xuICAgICAgICAgICAgY29uc3QgcHJvcHNUbyA9IHRoaXMuZ2V0Q3NzKGlzSW4odHlwZSkgPyAwLjUgOiBkaXIgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgcHJvcHNGcm9tKTtcbiAgICAgICAgICAgICAgVHJhbnNpdGlvbi5zdGFydCh0aGlzLiRlbCwgcHJvcHNUbywgZHVyYXRpb24sIHRpbWluZykuY2F0Y2gobm9vcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RyYW5zaXRpb25jYW5jZWxlZCB0cmFuc2l0aW9uZW5kJyxcblxuICAgICAgICBzZWxmOiB0cnVlLFxuXG4gICAgICAgIGVsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICBUcmFuc2l0aW9uLmNhbmNlbCh0aGlzLiRlbCk7XG4gICAgICAgIH0gfSxcblxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpdGVtdHJhbnNsYXRlaW4gaXRlbXRyYW5zbGF0ZW91dCcsXG5cbiAgICAgICAgc2VsZjogdHJ1ZSxcblxuICAgICAgICBlbCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZXIoX3JlZjIpIHtsZXQgeyB0eXBlLCBkZXRhaWw6IHsgcGVyY2VudCwgZGlyIH0gfSA9IF9yZWYyO1xuICAgICAgICAgIGZhc3Rkb20ucmVhZCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuZ2V0Q3NzKGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkpO1xuICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiBjc3ModGhpcy4kZWwsIHByb3BzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gfV0gfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIGlzSW4odHlwZSkge1xuICAgICAgcmV0dXJuIGVuZHNXaXRoKHR5cGUsICdpbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkge1xuICAgICAgcGVyY2VudCAvPSAyO1xuXG4gICAgICByZXR1cm4gaXNJbih0eXBlKSBeIGRpciA8IDAgPyBwZXJjZW50IDogMSAtIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdmFyIEFuaW1hdGlvbnMgPSB7XG4gICAgICAuLi5BbmltYXRpb25zJDIsXG4gICAgICBmYWRlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAsIHpJbmRleDogMCB9LCB7IHpJbmRleDogLTEgfV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyY2VudChjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLSBjc3MoY3VycmVudCwgJ29wYWNpdHknKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCkge1xuICAgICAgICAgIHJldHVybiBbeyBvcGFjaXR5OiAxIC0gcGVyY2VudCwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogc2NhbGUzZCgxICsgMC41KSwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIGNzcyhjdXJyZW50LCAnb3BhY2l0eScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7IG9wYWNpdHk6IDEgLSBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSArIDAuNSAqIHBlcmNlbnQpLCB6SW5kZXg6IDAgfSxcbiAgICAgICAgICB7IHpJbmRleDogLTEgfV07XG5cbiAgICAgICAgfSB9LFxuXG5cbiAgICAgIHB1bGw6IHtcbiAgICAgICAgc2hvdyhkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/XG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzApLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpLCB6SW5kZXg6IDAgfV0gOlxuXG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSwgekluZGV4OiAtMSB9XTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmNlbnQoY3VycmVudCwgbmV4dCwgZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgPyAxIC0gdHJhbnNsYXRlZChuZXh0KSA6IHRyYW5zbGF0ZWQoY3VycmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQsIGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID9cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgzMCAqIHBlcmNlbnQpLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTAwICogKDEgLSBwZXJjZW50KSksIHpJbmRleDogMCB9XSA6XG5cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtcGVyY2VudCAqIDEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzAgKiAoMSAtIHBlcmNlbnQpKSwgekluZGV4OiAtMSB9XTtcblxuICAgICAgICB9IH0sXG5cblxuICAgICAgcHVzaDoge1xuICAgICAgICBzaG93KGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID9cbiAgICAgICAgICBbXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxMDApLCB6SW5kZXg6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKCksIHpJbmRleDogLTEgfV0gOlxuXG4gICAgICAgICAgW1xuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTMwKSwgekluZGV4OiAtMSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSwgekluZGV4OiAwIH1dO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyY2VudChjdXJyZW50LCBuZXh0LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyID4gMCA/IDEgLSB0cmFuc2xhdGVkKG5leHQpIDogdHJhbnNsYXRlZChjdXJyZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCwgZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgP1xuICAgICAgICAgIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKHBlcmNlbnQgKiAxMDApLCB6SW5kZXg6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC0zMCAqICgxIC0gcGVyY2VudCkpLCB6SW5kZXg6IC0xIH1dIDpcblxuICAgICAgICAgIFtcbiAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC0zMCAqIHBlcmNlbnQpLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxMDAgKiAoMSAtIHBlcmNlbnQpKSwgekluZGV4OiAwIH1dO1xuXG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIHNsaWRlc2hvdyA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBTbGlkZXNob3csIFNsaWRlclJlYWN0aXZlLCBTbGlkZXJQcmVsb2FkXSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcmF0aW86IFN0cmluZyxcbiAgICAgICAgbWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgICAgIG1heEhlaWdodDogTnVtYmVyIH0sXG5cblxuICAgICAgZGF0YToge1xuICAgICAgICByYXRpbzogJzE2OjknLFxuICAgICAgICBtaW5IZWlnaHQ6IGZhbHNlLFxuICAgICAgICBtYXhIZWlnaHQ6IGZhbHNlLFxuICAgICAgICBzZWxMaXN0OiAnLnVrLXNsaWRlc2hvdy1pdGVtcycsXG4gICAgICAgIGF0dHJJdGVtOiAndWstc2xpZGVzaG93LWl0ZW0nLFxuICAgICAgICBzZWxOYXY6ICcudWstc2xpZGVzaG93LW5hdicsXG4gICAgICAgIEFuaW1hdGlvbnMgfSxcblxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnJhdGlvLnNwbGl0KCc6JykubWFwKE51bWJlcik7XG5cbiAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKiB0aGlzLmxpc3Qub2Zmc2V0V2lkdGggLyB3aWR0aCB8fCAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLm1pbkhlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5tYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7IGhlaWdodDogaGVpZ2h0IC0gYm94TW9kZWxBZGp1c3QodGhpcy5saXN0LCAnaGVpZ2h0JywgJ2NvbnRlbnQtYm94JykgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cml0ZShfcmVmKSB7bGV0IHsgaGVpZ2h0IH0gPSBfcmVmO1xuICAgICAgICAgIGhlaWdodCA+IDAgJiYgY3NzKHRoaXMubGlzdCwgJ21pbkhlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ3Jlc2l6ZSddIH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBnZXRBZGphY2VudFNsaWRlcygpIHtcbiAgICAgICAgICByZXR1cm4gWzEsIC0xXS5tYXAoKGkpID0+IHRoaXMuc2xpZGVzW3RoaXMuZ2V0SW5kZXgodGhpcy5pbmRleCArIGkpXSk7XG4gICAgICAgIH0gfSB9O1xuXG4gICAgdmFyIHNvcnRhYmxlID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIEFuaW1hdGVdLFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBncm91cDogU3RyaW5nLFxuICAgICAgICB0aHJlc2hvbGQ6IE51bWJlcixcbiAgICAgICAgY2xzSXRlbTogU3RyaW5nLFxuICAgICAgICBjbHNQbGFjZWhvbGRlcjogU3RyaW5nLFxuICAgICAgICBjbHNEcmFnOiBTdHJpbmcsXG4gICAgICAgIGNsc0RyYWdTdGF0ZTogU3RyaW5nLFxuICAgICAgICBjbHNCYXNlOiBTdHJpbmcsXG4gICAgICAgIGNsc05vRHJhZzogU3RyaW5nLFxuICAgICAgICBjbHNFbXB0eTogU3RyaW5nLFxuICAgICAgICBjbHNDdXN0b206IFN0cmluZyxcbiAgICAgICAgaGFuZGxlOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGdyb3VwOiBmYWxzZSxcbiAgICAgICAgdGhyZXNob2xkOiA1LFxuICAgICAgICBjbHNJdGVtOiAndWstc29ydGFibGUtaXRlbScsXG4gICAgICAgIGNsc1BsYWNlaG9sZGVyOiAndWstc29ydGFibGUtcGxhY2Vob2xkZXInLFxuICAgICAgICBjbHNEcmFnOiAndWstc29ydGFibGUtZHJhZycsXG4gICAgICAgIGNsc0RyYWdTdGF0ZTogJ3VrLWRyYWcnLFxuICAgICAgICBjbHNCYXNlOiAndWstc29ydGFibGUnLFxuICAgICAgICBjbHNOb0RyYWc6ICd1ay1zb3J0YWJsZS1ub2RyYWcnLFxuICAgICAgICBjbHNFbXB0eTogJ3VrLXNvcnRhYmxlLWVtcHR5JyxcbiAgICAgICAgY2xzQ3VzdG9tOiAnJyxcbiAgICAgICAgaGFuZGxlOiBmYWxzZSxcbiAgICAgICAgcG9zOiB7fSB9LFxuXG5cbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnaW5pdCcsICdzdGFydCcsICdtb3ZlJywgJ2VuZCddKSB7XG4gICAgICAgICAgY29uc3QgZm4gPSB0aGlzW2tleV07XG4gICAgICAgICAgdGhpc1trZXldID0gKGUpID0+IHtcbiAgICAgICAgICAgIGFzc2lnbih0aGlzLnBvcywgZ2V0RXZlbnRQb3MoZSkpO1xuICAgICAgICAgICAgZm4oZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIG5hbWU6IHBvaW50ZXJEb3duLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgaGFuZGxlcjogJ2luaXQnIH0sXG5cblxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdGFyZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAodGhpcy4kZWwudEJvZGllcyB8fCBbdGhpcy4kZWxdKVswXTtcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtcygpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW4odGhpcy50YXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRW1wdHk6IHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLml0ZW1zKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd2F0Y2goZW1wdHkpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmNsc0VtcHR5LCBlbXB0eSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9LFxuXG5cbiAgICAgICAgaGFuZGxlczoge1xuICAgICAgICAgIGdldChfcmVmLCBlbCkge2xldCB7IGhhbmRsZSB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUgPyAkJChoYW5kbGUsIGVsKSA6IHRoaXMuaXRlbXM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdhdGNoKGhhbmRsZXMsIHByZXYpIHtcbiAgICAgICAgICAgIGNzcyhwcmV2LCB7IHRvdWNoQWN0aW9uOiAnJywgdXNlclNlbGVjdDogJycgfSk7XG4gICAgICAgICAgICBjc3MoaGFuZGxlcywgeyB0b3VjaEFjdGlvbjogaGFzVG91Y2ggPyAnbm9uZScgOiAnJywgdXNlclNlbGVjdDogJ25vbmUnIH0pOyAvLyB0b3VjaEFjdGlvbiBzZXQgdG8gJ25vbmUnIGNhdXNlcyBhIHBlcmZvcm1hbmNlIGRyb3AgaW4gQ2hyb21lIDgwXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSB9IH0sXG5cblxuXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgd3JpdGUoZGF0YSkge1xuICAgICAgICAgIGlmICghdGhpcy5kcmFnIHx8ICFwYXJlbnQodGhpcy5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBwb3M6IHsgeCwgeSB9LFxuICAgICAgICAgICAgb3JpZ2luOiB7IG9mZnNldFRvcCwgb2Zmc2V0TGVmdCB9LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgfSA9XG4gICAgICAgICAgdGhpcztcblxuICAgICAgICAgIGNzcyh0aGlzLmRyYWcsIHtcbiAgICAgICAgICAgIHRvcDogeSAtIG9mZnNldFRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHggLSBvZmZzZXRMZWZ0IH0pO1xuXG5cbiAgICAgICAgICBjb25zdCBzb3J0YWJsZSA9IHRoaXMuZ2V0U29ydGFibGUoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KSk7XG5cbiAgICAgICAgICBpZiAoIXNvcnRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBpdGVtcyB9ID0gc29ydGFibGU7XG5cbiAgICAgICAgICBpZiAoaXRlbXMuc29tZShUcmFuc2l0aW9uLmluUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZmluZFRhcmdldChpdGVtcywgeyB4LCB5IH0pO1xuXG4gICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCAmJiAoIXRhcmdldCB8fCB0YXJnZXQgPT09IHBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5nZXRTb3J0YWJsZShwbGFjZWhvbGRlcik7XG4gICAgICAgICAgY29uc3QgaW5zZXJ0VGFyZ2V0ID0gZmluZEluc2VydFRhcmdldChcbiAgICAgICAgICBzb3J0YWJsZS50YXJnZXQsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBzb3J0YWJsZSA9PT0gcHJldmlvdXMgJiYgZGF0YS5tb3ZlZCAhPT0gdGFyZ2V0KTtcblxuXG4gICAgICAgICAgaWYgKGluc2VydFRhcmdldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5zZXJ0VGFyZ2V0ICYmIHBsYWNlaG9sZGVyID09PSBpbnNlcnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc29ydGFibGUgIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgICBwcmV2aW91cy5yZW1vdmUocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgZGF0YS5tb3ZlZCA9IHRhcmdldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEubW92ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc29ydGFibGUuaW5zZXJ0KHBsYWNlaG9sZGVyLCBpbnNlcnRUYXJnZXQpO1xuXG4gICAgICAgICAgdGhpcy50b3VjaGVkLmFkZChzb3J0YWJsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXZlbnRzOiBbJ21vdmUnXSB9LFxuXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgaW5pdChlKSB7XG4gICAgICAgICAgY29uc3QgeyB0YXJnZXQsIGJ1dHRvbiwgZGVmYXVsdFByZXZlbnRlZCB9ID0gZTtcbiAgICAgICAgICBjb25zdCBbcGxhY2Vob2xkZXJdID0gdGhpcy5pdGVtcy5maWx0ZXIoKGVsKSA9PiB3aXRoaW4odGFyZ2V0LCBlbCkpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICFwbGFjZWhvbGRlciB8fFxuICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgfHxcbiAgICAgICAgICBidXR0b24gPiAwIHx8XG4gICAgICAgICAgaXNJbnB1dCh0YXJnZXQpIHx8XG4gICAgICAgICAgd2l0aGluKHRhcmdldCwgXCIuXCIgKyB0aGlzLmNsc05vRHJhZykgfHxcbiAgICAgICAgICB0aGlzLmhhbmRsZSAmJiAhd2l0aGluKHRhcmdldCwgdGhpcy5oYW5kbGUpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB0aGlzLnRvdWNoZWQgPSBuZXcgU2V0KFt0aGlzXSk7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgIHRoaXMub3JpZ2luID0geyB0YXJnZXQsIGluZGV4OiBpbmRleChwbGFjZWhvbGRlciksIC4uLnRoaXMucG9zIH07XG5cbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlck1vdmUsIHRoaXMubW92ZSk7XG4gICAgICAgICAgb24oZG9jdW1lbnQsIHBvaW50ZXJVcCwgdGhpcy5lbmQpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnQoZSkge1xuICAgICAgICAgIHRoaXMuZHJhZyA9IGFwcGVuZERyYWcodGhpcy4kY29udGFpbmVyLCB0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gdGhpcy5wbGFjZWhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy5vcmlnaW4sIHsgb2Zmc2V0TGVmdDogdGhpcy5wb3MueCAtIGxlZnQsIG9mZnNldFRvcDogdGhpcy5wb3MueSAtIHRvcCB9KTtcblxuICAgICAgICAgIGFkZENsYXNzKHRoaXMuZHJhZywgdGhpcy5jbHNEcmFnLCB0aGlzLmNsc0N1c3RvbSk7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5wbGFjZWhvbGRlciwgdGhpcy5jbHNQbGFjZWhvbGRlcik7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5pdGVtcywgdGhpcy5jbHNJdGVtKTtcbiAgICAgICAgICBhZGRDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzRHJhZ1N0YXRlKTtcblxuICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdzdGFydCcsIFt0aGlzLCB0aGlzLnBsYWNlaG9sZGVyXSk7XG5cbiAgICAgICAgICB0cmFja1Njcm9sbCh0aGlzLnBvcyk7XG5cbiAgICAgICAgICB0aGlzLm1vdmUoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZShlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZykge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnbW92ZScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgTWF0aC5hYnModGhpcy5wb3MueCAtIHRoaXMub3JpZ2luLngpID4gdGhpcy50aHJlc2hvbGQgfHxcbiAgICAgICAgICBNYXRoLmFicyh0aGlzLnBvcy55IC0gdGhpcy5vcmlnaW4ueSkgPiB0aGlzLnRocmVzaG9sZClcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgb2ZmKGRvY3VtZW50LCBwb2ludGVyTW92ZSwgdGhpcy5tb3ZlKTtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIHBvaW50ZXJVcCwgdGhpcy5lbmQpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1bnRyYWNrU2Nyb2xsKCk7XG5cbiAgICAgICAgICBjb25zdCBzb3J0YWJsZSA9IHRoaXMuZ2V0U29ydGFibGUodGhpcy5wbGFjZWhvbGRlcik7XG5cbiAgICAgICAgICBpZiAodGhpcyA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9yaWdpbi5pbmRleCAhPT0gaW5kZXgodGhpcy5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ21vdmVkJywgW3RoaXMsIHRoaXMucGxhY2Vob2xkZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJpZ2dlcihzb3J0YWJsZS4kZWwsICdhZGRlZCcsIFtzb3J0YWJsZSwgdGhpcy5wbGFjZWhvbGRlcl0pO1xuICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgJ3JlbW92ZWQnLCBbdGhpcywgdGhpcy5wbGFjZWhvbGRlcl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsICdzdG9wJywgW3RoaXMsIHRoaXMucGxhY2Vob2xkZXJdKTtcblxuICAgICAgICAgIHJlbW92ZSQxKHRoaXMuZHJhZyk7XG4gICAgICAgICAgdGhpcy5kcmFnID0gbnVsbDtcblxuICAgICAgICAgIGZvciAoY29uc3QgeyBjbHNQbGFjZWhvbGRlciwgY2xzSXRlbSB9IG9mIHRoaXMudG91Y2hlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzb3J0YWJsZSBvZiB0aGlzLnRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc29ydGFibGUuaXRlbXMsIGNsc1BsYWNlaG9sZGVyLCBjbHNJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50b3VjaGVkID0gbnVsbDtcbiAgICAgICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzRHJhZ1N0YXRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnQoZWxlbWVudCwgdGFyZ2V0KSB7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5pdGVtcywgdGhpcy5jbHNJdGVtKTtcblxuICAgICAgICAgIGNvbnN0IGluc2VydCA9ICgpID0+IHRhcmdldCA/IGJlZm9yZSh0YXJnZXQsIGVsZW1lbnQpIDogYXBwZW5kKHRoaXMudGFyZ2V0LCBlbGVtZW50KTtcblxuICAgICAgICAgIHRoaXMuYW5pbWF0ZShpbnNlcnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZShlbGVtZW50KSB7XG4gICAgICAgICAgaWYgKCF3aXRoaW4oZWxlbWVudCwgdGhpcy50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5hbmltYXRlKCgpID0+IHJlbW92ZSQxKGVsZW1lbnQpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTb3J0YWJsZShlbGVtZW50KSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3Qgc29ydGFibGUgPSB0aGlzLiRnZXRDb21wb25lbnQoZWxlbWVudCwgJ3NvcnRhYmxlJyk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHNvcnRhYmxlICYmIChcbiAgICAgICAgICAgIHNvcnRhYmxlID09PSB0aGlzIHx8IHRoaXMuZ3JvdXAgIT09IGZhbHNlICYmIHNvcnRhYmxlLmdyb3VwID09PSB0aGlzLmdyb3VwKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNvcnRhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGVsZW1lbnQgPSBwYXJlbnQoZWxlbWVudCkpO1xuICAgICAgICB9IH0gfTtcblxuXG5cbiAgICBsZXQgdHJhY2tUaW1lcjtcbiAgICBmdW5jdGlvbiB0cmFja1Njcm9sbChwb3MpIHtcbiAgICAgIGxldCBsYXN0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHRyYWNrVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGxldCB7IHgsIHkgfSA9IHBvcztcbiAgICAgICAgeSArPSBzY3JvbGxUb3Aod2luZG93KTtcblxuICAgICAgICBjb25zdCBkaXN0ID0gKERhdGUubm93KCkgLSBsYXN0KSAqIDAuMztcbiAgICAgICAgbGFzdCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgc2Nyb2xsUGFyZW50cyhkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHBvcy55KSwgL2F1dG98c2Nyb2xsLykuXG4gICAgICAgIHJldmVyc2UoKS5cbiAgICAgICAgc29tZSgoc2Nyb2xsRWwpID0+IHtcbiAgICAgICAgICBsZXQgeyBzY3JvbGxUb3A6IHNjcm9sbCwgc2Nyb2xsSGVpZ2h0IH0gPSBzY3JvbGxFbDtcblxuICAgICAgICAgIGNvbnN0IHsgdG9wLCBib3R0b20sIGhlaWdodCB9ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWwpO1xuXG4gICAgICAgICAgaWYgKHRvcCA8IHkgJiYgdG9wICsgMzUgPiB5KSB7XG4gICAgICAgICAgICBzY3JvbGwgLT0gZGlzdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJvdHRvbSA+IHkgJiYgYm90dG9tIC0gMzUgPCB5KSB7XG4gICAgICAgICAgICBzY3JvbGwgKz0gZGlzdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzY3JvbGwgPiAwICYmIHNjcm9sbCA8IHNjcm9sbEhlaWdodCAtIGhlaWdodCkge1xuICAgICAgICAgICAgc2Nyb2xsVG9wKHNjcm9sbEVsLCBzY3JvbGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIDE1KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRyYWNrU2Nyb2xsKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0cmFja1RpbWVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBlbmREcmFnKGNvbnRhaW5lciwgZWxlbWVudCkge1xuICAgICAgY29uc3QgY2xvbmUgPSBhcHBlbmQoXG4gICAgICBjb250YWluZXIsXG4gICAgICBlbGVtZW50Lm91dGVySFRNTC5yZXBsYWNlKC8oXjwpKD86bGl8dHIpfCg/OmxpfHRyKShcXC8+JCkvZywgJyQxZGl2JDInKSk7XG5cblxuICAgICAgY3NzKGNsb25lLCAnbWFyZ2luJywgJzAnLCAnaW1wb3J0YW50Jyk7XG4gICAgICBjc3MoY2xvbmUsIHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICBwYWRkaW5nOiBjc3MoZWxlbWVudCwgJ3BhZGRpbmcnKSB9KTtcblxuXG4gICAgICBoZWlnaHQoY2xvbmUuZmlyc3RFbGVtZW50Q2hpbGQsIGhlaWdodChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSk7XG5cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kVGFyZ2V0KGl0ZW1zLCBwb2ludCkge1xuICAgICAgcmV0dXJuIGl0ZW1zW2ZpbmRJbmRleChpdGVtcywgKGl0ZW0pID0+IHBvaW50SW5SZWN0KHBvaW50LCBpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRJbnNlcnRUYXJnZXQobGlzdCwgdGFyZ2V0LCBwbGFjZWhvbGRlciwgeCwgeSwgc2FtZUxpc3QpIHtcbiAgICAgIGlmICghY2hpbGRyZW4obGlzdCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICghc2FtZUxpc3QpIHtcbiAgICAgICAgaWYgKCFpc0hvcml6b250YWwobGlzdCwgcGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHkgPCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMiA/IHRhcmdldCA6IHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwbGFjZWhvbGRlclJlY3QgPSBwbGFjZWhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNhbWVSb3cgPSBsaW5lc0ludGVyc2VjdChcbiAgICAgIFtyZWN0LnRvcCwgcmVjdC5ib3R0b21dLFxuICAgICAgW3BsYWNlaG9sZGVyUmVjdC50b3AsIHBsYWNlaG9sZGVyUmVjdC5ib3R0b21dKTtcblxuXG4gICAgICBjb25zdCBwb2ludGVyUG9zID0gc2FtZVJvdyA/IHggOiB5O1xuICAgICAgY29uc3QgbGVuZ3RoUHJvcCA9IHNhbWVSb3cgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICBjb25zdCBzdGFydFByb3AgPSBzYW1lUm93ID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICBjb25zdCBlbmRQcm9wID0gc2FtZVJvdyA/ICdyaWdodCcgOiAnYm90dG9tJztcblxuICAgICAgY29uc3QgZGlmZiA9XG4gICAgICBwbGFjZWhvbGRlclJlY3RbbGVuZ3RoUHJvcF0gPCByZWN0W2xlbmd0aFByb3BdID9cbiAgICAgIHJlY3RbbGVuZ3RoUHJvcF0gLSBwbGFjZWhvbGRlclJlY3RbbGVuZ3RoUHJvcF0gOlxuICAgICAgMDtcblxuICAgICAgaWYgKHBsYWNlaG9sZGVyUmVjdFtzdGFydFByb3BdIDwgcmVjdFtzdGFydFByb3BdKSB7XG4gICAgICAgIGlmIChkaWZmICYmIHBvaW50ZXJQb3MgPCByZWN0W3N0YXJ0UHJvcF0gKyBkaWZmKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmICYmIHBvaW50ZXJQb3MgPiByZWN0W2VuZFByb3BdIC0gZGlmZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIb3Jpem9udGFsKGxpc3QsIHBsYWNlaG9sZGVyKSB7XG4gICAgICBjb25zdCBzaW5nbGUgPSBjaGlsZHJlbihsaXN0KS5sZW5ndGggPT09IDE7XG5cbiAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgYXBwZW5kKGxpc3QsIHBsYWNlaG9sZGVyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXRlbXMgPSBjaGlsZHJlbihsaXN0KTtcbiAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGl0ZW1zLnNvbWUoKGVsLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY3RBID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBpdGVtcy5zbGljZShpICsgMSkuc29tZSgoZWwpID0+IHtcbiAgICAgICAgICBjb25zdCByZWN0QiA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHJldHVybiAhbGluZXNJbnRlcnNlY3QoW3JlY3RBLmxlZnQsIHJlY3RBLnJpZ2h0XSwgW3JlY3RCLmxlZnQsIHJlY3RCLnJpZ2h0XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgcmVtb3ZlJDEocGxhY2Vob2xkZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNIb3Jpem9udGFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVzSW50ZXJzZWN0KGxpbmVBLCBsaW5lQikge1xuICAgICAgcmV0dXJuIGxpbmVBWzFdID4gbGluZUJbMF0gJiYgbGluZUJbMV0gPiBsaW5lQVswXTtcbiAgICB9XG5cbiAgICB2YXIgdG9vbHRpcCA9IHtcbiAgICAgIG1peGluczogW0NvbnRhaW5lciwgVG9nZ2xhYmxlLCBQb3NpdGlvbl0sXG5cbiAgICAgIGFyZ3M6ICd0aXRsZScsXG5cbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGRlbGF5OiBOdW1iZXIsXG4gICAgICAgIHRpdGxlOiBTdHJpbmcgfSxcblxuXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBvczogJ3RvcCcsXG4gICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgIGFuaW1hdGlvbjogWyd1ay1hbmltYXRpb24tc2NhbGUtdXAnXSxcbiAgICAgICAgZHVyYXRpb246IDEwMCxcbiAgICAgICAgY2xzOiAndWstYWN0aXZlJyB9LFxuXG5cbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuX2hhc1RpdGxlID0gaGFzQXR0cih0aGlzLiRlbCwgJ3RpdGxlJyk7XG4gICAgICAgIGF0dHIodGhpcy4kZWwsICd0aXRsZScsICcnKTtcbiAgICAgICAgdGhpcy51cGRhdGVBcmlhKGZhbHNlKTtcbiAgICAgICAgbWFrZUZvY3VzYWJsZSh0aGlzLiRlbCk7XG4gICAgICB9LFxuXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICBhdHRyKHRoaXMuJGVsLCAndGl0bGUnLCB0aGlzLl9oYXNUaXRsZSA/IHRoaXMudGl0bGUgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQodGhpcy50b29sdGlwIHx8IG51bGwpIHx8ICF0aGlzLnRpdGxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fdW5iaW5kID0gb25jZShcbiAgICAgICAgICBkb2N1bWVudCwgXCJzaG93IGtleWRvd24gXCIgK1xuICAgICAgICAgIHBvaW50ZXJEb3duLFxuICAgICAgICAgIHRoaXMuaGlkZSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAoZSkgPT5cbiAgICAgICAgICBlLnR5cGUgPT09IHBvaW50ZXJEb3duICYmICF3aXRoaW4oZS50YXJnZXQsIHRoaXMuJGVsKSB8fFxuICAgICAgICAgIGUudHlwZSA9PT0gJ2tleWRvd24nICYmIGUua2V5Q29kZSA9PT0gMjcgfHxcbiAgICAgICAgICBlLnR5cGUgPT09ICdzaG93JyAmJiBlLmRldGFpbFswXSAhPT0gdGhpcyAmJiBlLmRldGFpbFswXS4kbmFtZSA9PT0gdGhpcy4kbmFtZSk7XG5cblxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lcik7XG4gICAgICAgICAgdGhpcy5zaG93VGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX3Nob3csIHRoaXMuZGVsYXkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFzeW5jIGhpZGUoKSB7XG4gICAgICAgICAgaWYgKG1hdGNoZXModGhpcy4kZWwsICdpbnB1dDpmb2N1cycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVyKTtcblxuICAgICAgICAgIGlmICghdGhpcy5pc1RvZ2dsZWQodGhpcy50b29sdGlwIHx8IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdGhpcy50b2dnbGVFbGVtZW50KHRoaXMudG9vbHRpcCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICByZW1vdmUkMSh0aGlzLnRvb2x0aXApO1xuICAgICAgICAgIHRoaXMudG9vbHRpcCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fdW5iaW5kKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Nob3coKSB7XG4gICAgICAgICAgdGhpcy50b29sdGlwID0gYXBwZW5kKFxuICAgICAgICAgIHRoaXMuY29udGFpbmVyLCBcIjxkaXYgY2xhc3M9XFxcInVrLVwiICtcbiAgICAgICAgICB0aGlzLiRvcHRpb25zLm5hbWUgKyBcIlxcXCI+IDxkaXYgY2xhc3M9XFxcInVrLVwiICtcbiAgICAgICAgICB0aGlzLiRvcHRpb25zLm5hbWUgKyBcIi1pbm5lclxcXCI+XCIgKyB0aGlzLnRpdGxlICsgXCI8L2Rpdj4gPC9kaXY+XCIpO1xuXG5cblxuICAgICAgICAgIG9uKHRoaXMudG9vbHRpcCwgJ3RvZ2dsZWQnLCAoZSwgdG9nZ2xlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBcmlhKHRvZ2dsZWQpO1xuXG4gICAgICAgICAgICBpZiAoIXRvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uQXQodGhpcy50b29sdGlwLCB0aGlzLiRlbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IFtkaXIsIGFsaWduXSA9IGdldEFsaWdubWVudCh0aGlzLnRvb2x0aXAsIHRoaXMuJGVsLCB0aGlzLnBvcyk7XG5cbiAgICAgICAgICAgIHRoaXMub3JpZ2luID1cbiAgICAgICAgICAgIHRoaXMuYXhpcyA9PT0gJ3knID9cbiAgICAgICAgICAgIGZsaXBQb3NpdGlvbihkaXIpICsgXCItXCIgKyBhbGlnbiA6XG4gICAgICAgICAgICBhbGlnbiArIFwiLVwiICsgZmxpcFBvc2l0aW9uKGRpcik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy50b29sdGlwLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVBcmlhKHRvZ2dsZWQpIHtcbiAgICAgICAgICBhdHRyKHRoaXMuJGVsLCAnYXJpYS1leHBhbmRlZCcsIHRvZ2dsZWQpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGZvY3VzOiAnc2hvdycsXG4gICAgICAgIGJsdXI6ICdoaWRlJyxcblxuICAgICAgICBbcG9pbnRlckVudGVyICsgXCIgXCIgKyBwb2ludGVyTGVhdmVdKGUpIHtcbiAgICAgICAgICBpZiAoIWlzVG91Y2goZSkpIHtcbiAgICAgICAgICAgIHRoaXNbZS50eXBlID09PSBwb2ludGVyRW50ZXIgPyAnc2hvdycgOiAnaGlkZSddKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENsaWNraW5nIGEgYnV0dG9uIGRvZXMgbm90IGdpdmUgaXQgZm9jdXMgb24gYWxsIGJyb3dzZXJzIGFuZCBwbGF0Zm9ybXNcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2J1dHRvbiNjbGlja2luZ19hbmRfZm9jdXNcbiAgICAgICAgW3BvaW50ZXJEb3duXShlKSB7XG4gICAgICAgICAgaWYgKGlzVG91Y2goZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gbWFrZUZvY3VzYWJsZShlbCkge1xuICAgICAgaWYgKCFpc0ZvY3VzYWJsZShlbCkpIHtcbiAgICAgICAgYXR0cihlbCwgJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBbGlnbm1lbnQoZWwsIHRhcmdldCwgX3JlZikge2xldCBbZGlyLCBhbGlnbl0gPSBfcmVmO1xuICAgICAgY29uc3QgZWxPZmZzZXQgPSBvZmZzZXQoZWwpO1xuICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0KHRhcmdldCk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gW1xuICAgICAgWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICBbJ3RvcCcsICdib3R0b20nXV07XG5cblxuICAgICAgZm9yIChjb25zdCBwcm9wcyBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChlbE9mZnNldFtwcm9wc1swXV0gPj0gdGFyZ2V0T2Zmc2V0W3Byb3BzWzFdXSkge1xuICAgICAgICAgIGRpciA9IHByb3BzWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbE9mZnNldFtwcm9wc1sxXV0gPD0gdGFyZ2V0T2Zmc2V0W3Byb3BzWzBdXSkge1xuICAgICAgICAgIGRpciA9IHByb3BzWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BzID0gaW5jbHVkZXMocHJvcGVydGllc1swXSwgZGlyKSA/IHByb3BlcnRpZXNbMV0gOiBwcm9wZXJ0aWVzWzBdO1xuICAgICAgaWYgKGVsT2Zmc2V0W3Byb3BzWzBdXSA9PT0gdGFyZ2V0T2Zmc2V0W3Byb3BzWzBdXSkge1xuICAgICAgICBhbGlnbiA9IHByb3BzWzBdO1xuICAgICAgfSBlbHNlIGlmIChlbE9mZnNldFtwcm9wc1sxXV0gPT09IHRhcmdldE9mZnNldFtwcm9wc1sxXV0pIHtcbiAgICAgICAgYWxpZ24gPSBwcm9wc1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZGlyLCBhbGlnbl07XG4gICAgfVxuXG4gICAgdmFyIHVwbG9hZCA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGFsbG93OiBTdHJpbmcsXG4gICAgICAgIGNsc0RyYWdvdmVyOiBTdHJpbmcsXG4gICAgICAgIGNvbmN1cnJlbnQ6IE51bWJlcixcbiAgICAgICAgbWF4U2l6ZTogTnVtYmVyLFxuICAgICAgICBtZXRob2Q6IFN0cmluZyxcbiAgICAgICAgbWltZTogU3RyaW5nLFxuICAgICAgICBtc2dJbnZhbGlkTWltZTogU3RyaW5nLFxuICAgICAgICBtc2dJbnZhbGlkTmFtZTogU3RyaW5nLFxuICAgICAgICBtc2dJbnZhbGlkU2l6ZTogU3RyaW5nLFxuICAgICAgICBtdWx0aXBsZTogQm9vbGVhbixcbiAgICAgICAgbmFtZTogU3RyaW5nLFxuICAgICAgICBwYXJhbXM6IE9iamVjdCxcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB1cmw6IFN0cmluZyB9LFxuXG5cbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYWxsb3c6IGZhbHNlLFxuICAgICAgICBjbHNEcmFnb3ZlcjogJ3VrLWRyYWdvdmVyJyxcbiAgICAgICAgY29uY3VycmVudDogMSxcbiAgICAgICAgbWF4U2l6ZTogMCxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIG1pbWU6IGZhbHNlLFxuICAgICAgICBtc2dJbnZhbGlkTWltZTogJ0ludmFsaWQgRmlsZSBUeXBlOiAlcycsXG4gICAgICAgIG1zZ0ludmFsaWROYW1lOiAnSW52YWxpZCBGaWxlIE5hbWU6ICVzJyxcbiAgICAgICAgbXNnSW52YWxpZFNpemU6ICdJbnZhbGlkIEZpbGUgU2l6ZTogJXMgS2lsb2J5dGVzIE1heCcsXG4gICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgbmFtZTogJ2ZpbGVzW10nLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICB0eXBlOiAnJyxcbiAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgYWJvcnQ6IG5vb3AsXG4gICAgICAgIGJlZm9yZUFsbDogbm9vcCxcbiAgICAgICAgYmVmb3JlU2VuZDogbm9vcCxcbiAgICAgICAgY29tcGxldGU6IG5vb3AsXG4gICAgICAgIGNvbXBsZXRlQWxsOiBub29wLFxuICAgICAgICBlcnJvcjogbm9vcCxcbiAgICAgICAgZmFpbDogbm9vcCxcbiAgICAgICAgbG9hZDogbm9vcCxcbiAgICAgICAgbG9hZEVuZDogbm9vcCxcbiAgICAgICAgbG9hZFN0YXJ0OiBub29wLFxuICAgICAgICBwcm9ncmVzczogbm9vcCB9LFxuXG5cbiAgICAgIGV2ZW50czoge1xuICAgICAgICBjaGFuZ2UoZSkge1xuICAgICAgICAgIGlmICghbWF0Y2hlcyhlLnRhcmdldCwgJ2lucHV0W3R5cGU9XCJmaWxlXCJdJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoZS50YXJnZXQuZmlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkKGUudGFyZ2V0LmZpbGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnRhcmdldC52YWx1ZSA9ICcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyb3AoZSkge1xuICAgICAgICAgIHN0b3AoZSk7XG5cbiAgICAgICAgICBjb25zdCB0cmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuXG4gICAgICAgICAgaWYgKCEodHJhbnNmZXIgIT0gbnVsbCAmJiB0cmFuc2Zlci5maWxlcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcmFnb3Zlcik7XG5cbiAgICAgICAgICB0aGlzLnVwbG9hZCh0cmFuc2Zlci5maWxlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZHJhZ2VudGVyKGUpIHtcbiAgICAgICAgICBzdG9wKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRyYWdvdmVyKGUpIHtcbiAgICAgICAgICBzdG9wKGUpO1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0RyYWdvdmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmFnbGVhdmUoZSkge1xuICAgICAgICAgIHN0b3AoZSk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRHJhZ292ZXIpO1xuICAgICAgICB9IH0sXG5cblxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyB1cGxvYWQoZmlsZXMpIHtcbiAgICAgICAgICBmaWxlcyA9IHRvQXJyYXkoZmlsZXMpO1xuXG4gICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCAndXBsb2FkJywgW2ZpbGVzXSk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heFNpemUgJiYgdGhpcy5tYXhTaXplICogMTAwMCA8IGZpbGUuc2l6ZSkge1xuICAgICAgICAgICAgICB0aGlzLmZhaWwodGhpcy5tc2dJbnZhbGlkU2l6ZS5yZXBsYWNlKCclcycsIHRoaXMubWF4U2l6ZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93ICYmICFtYXRjaCh0aGlzLmFsbG93LCBmaWxlLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmFpbCh0aGlzLm1zZ0ludmFsaWROYW1lLnJlcGxhY2UoJyVzJywgdGhpcy5hbGxvdykpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1pbWUgJiYgIW1hdGNoKHRoaXMubWltZSwgZmlsZS50eXBlKSkge1xuICAgICAgICAgICAgICB0aGlzLmZhaWwodGhpcy5tc2dJbnZhbGlkTWltZS5yZXBsYWNlKCclcycsIHRoaXMubWltZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICBmaWxlcyA9IGZpbGVzLnNsaWNlKDAsIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYmVmb3JlQWxsKHRoaXMsIGZpbGVzKTtcblxuICAgICAgICAgIGNvbnN0IGNodW5rcyA9IGNodW5rKGZpbGVzLCB0aGlzLmNvbmN1cnJlbnQpO1xuICAgICAgICAgIGNvbnN0IHVwbG9hZCA9IGFzeW5jIChmaWxlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiBkYXRhLmFwcGVuZCh0aGlzLm5hbWUsIGZpbGUpKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoa2V5LCB0aGlzLnBhcmFtc1trZXldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeGhyID0gYXdhaXQgYWpheCh0aGlzLnVybCwge1xuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICBiZWZvcmVTZW5kOiAoZW52KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB7IHhociB9ID0gZW52O1xuICAgICAgICAgICAgICAgICAgeGhyLnVwbG9hZCAmJiBvbih4aHIudXBsb2FkLCAncHJvZ3Jlc3MnLCB0aGlzLnByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ2xvYWRTdGFydCcsICdsb2FkJywgJ2xvYWRFbmQnLCAnYWJvcnQnXSkge1xuICAgICAgICAgICAgICAgICAgICBvbih4aHIsIHR5cGUudG9Mb3dlckNhc2UoKSwgdGhpc1t0eXBlXSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNlbmQoZW52KTtcbiAgICAgICAgICAgICAgICB9IH0pO1xuXG5cbiAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSh4aHIpO1xuXG4gICAgICAgICAgICAgIGlmIChjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXBsb2FkKGNodW5rcy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlQWxsKHhocik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgYXdhaXQgdXBsb2FkKGNodW5rcy5zaGlmdCgpKTtcbiAgICAgICAgfSB9IH07XG5cblxuXG4gICAgZnVuY3Rpb24gbWF0Y2gocGF0dGVybiwgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubWF0Y2goXG4gICAgICBuZXcgUmVnRXhwKFwiXlwiICtcbiAgICAgIHBhdHRlcm4uXG4gICAgICByZXBsYWNlKC9cXC8vZywgJ1xcXFwvJykuXG4gICAgICByZXBsYWNlKC9cXCpcXCovZywgJyhcXFxcL1teXFxcXC9dKykqJykuXG4gICAgICByZXBsYWNlKC9cXCovZywgJ1teXFxcXC9dKycpLlxuICAgICAgcmVwbGFjZSgvKCg/IVxcXFwpKVxcPy9nLCAnJDEuJykgKyBcIiRcIixcbiAgICAgICdpJykpO1xuXG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaHVuayhmaWxlcywgc2l6ZSkge1xuICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSArPSBzaXplKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKGZpbGVzLnNsaWNlKGksIGkgKyBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2h1bmtzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3AoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBDb3VudGRvd246IGNvdW50ZG93bixcbiAgICAgICAgRmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIExpZ2h0Ym94OiBsaWdodGJveCxcbiAgICAgICAgTGlnaHRib3hQYW5lbDogTGlnaHRib3hQYW5lbCxcbiAgICAgICAgTm90aWZpY2F0aW9uOiBub3RpZmljYXRpb24sXG4gICAgICAgIFBhcmFsbGF4OiBwYXJhbGxheCxcbiAgICAgICAgU2xpZGVyOiBzbGlkZXIsXG4gICAgICAgIFNsaWRlclBhcmFsbGF4OiBzbGlkZXJQYXJhbGxheCxcbiAgICAgICAgU2xpZGVzaG93OiBzbGlkZXNob3csXG4gICAgICAgIFNsaWRlc2hvd1BhcmFsbGF4OiBzbGlkZXJQYXJhbGxheCxcbiAgICAgICAgU29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICBUb29sdGlwOiB0b29sdGlwLFxuICAgICAgICBVcGxvYWQ6IHVwbG9hZFxuICAgIH0pO1xuXG4gICAgZWFjaChjb21wb25lbnRzLCAoY29tcG9uZW50LCBuYW1lKSA9PiBVSWtpdC5jb21wb25lbnQobmFtZSwgY29tcG9uZW50KSk7XG5cbiAgICByZXR1cm4gVUlraXQ7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/dist/js/uikit.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/ajax.js":
/*!************************************************!*\
  !*** ./node_modules/uikit/src/js/util/ajax.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ajax\": () => (/* binding */ ajax),\n/* harmony export */   \"getImage\": () => (/* binding */ getImage)\n/* harmony export */ });\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event */ \"./node_modules/uikit/src/js/util/event.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\n\nfunction ajax(url, options) {\n    const env = {\n        data: null,\n        method: 'GET',\n        headers: {},\n        xhr: new XMLHttpRequest(),\n        beforeSend: _lang__WEBPACK_IMPORTED_MODULE_0__.noop,\n        responseType: '',\n        ...options,\n    };\n    return Promise.resolve()\n        .then(() => env.beforeSend(env))\n        .then(() => send(url, env));\n}\n\nfunction send(url, env) {\n    return new Promise((resolve, reject) => {\n        const { xhr } = env;\n\n        for (const prop in env) {\n            if (prop in xhr) {\n                try {\n                    xhr[prop] = env[prop];\n                } catch (e) {\n                    // noop\n                }\n            }\n        }\n\n        xhr.open(env.method.toUpperCase(), url);\n\n        for (const header in env.headers) {\n            xhr.setRequestHeader(header, env.headers[header]);\n        }\n\n        (0,_event__WEBPACK_IMPORTED_MODULE_1__.on)(xhr, 'load', () => {\n            if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n                resolve(xhr);\n            } else {\n                reject(\n                    (0,_lang__WEBPACK_IMPORTED_MODULE_0__.assign)(Error(xhr.statusText), {\n                        xhr,\n                        status: xhr.status,\n                    })\n                );\n            }\n        });\n\n        (0,_event__WEBPACK_IMPORTED_MODULE_1__.on)(xhr, 'error', () => reject((0,_lang__WEBPACK_IMPORTED_MODULE_0__.assign)(Error('Network Error'), { xhr })));\n        (0,_event__WEBPACK_IMPORTED_MODULE_1__.on)(xhr, 'timeout', () => reject((0,_lang__WEBPACK_IMPORTED_MODULE_0__.assign)(Error('Network Timeout'), { xhr })));\n\n        xhr.send(env.data);\n    });\n}\n\nfunction getImage(src, srcset, sizes) {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n\n        img.onerror = (e) => {\n            reject(e);\n        };\n        img.onload = () => {\n            resolve(img);\n        };\n\n        sizes && (img.sizes = sizes);\n        srcset && (img.srcset = srcset);\n        img.src = src;\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvYWpheC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZCO0FBQ1M7O0FBRS9CO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esb0JBQW9CLHVDQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVEsMENBQUU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esb0JBQW9CLDZDQUFNO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7O0FBRVQsUUFBUSwwQ0FBRSw0QkFBNEIsNkNBQU0sMkJBQTJCLEtBQUs7QUFDNUUsUUFBUSwwQ0FBRSw4QkFBOEIsNkNBQU0sNkJBQTZCLEtBQUs7O0FBRWhGO0FBQ0EsS0FBSztBQUNMOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Vpa2l0L3NyYy9qcy91dGlsL2FqYXguanM/OGE4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvbiB9IGZyb20gJy4vZXZlbnQnO1xuaW1wb3J0IHsgYXNzaWduLCBub29wIH0gZnJvbSAnLi9sYW5nJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFqYXgodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW52ID0ge1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgeGhyOiBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcbiAgICAgICAgYmVmb3JlU2VuZDogbm9vcCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnJyxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAudGhlbigoKSA9PiBlbnYuYmVmb3JlU2VuZChlbnYpKVxuICAgICAgICAudGhlbigoKSA9PiBzZW5kKHVybCwgZW52KSk7XG59XG5cbmZ1bmN0aW9uIHNlbmQodXJsLCBlbnYpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB7IHhociB9ID0gZW52O1xuXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBlbnYpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIHhocikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHhocltwcm9wXSA9IGVudltwcm9wXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4aHIub3BlbihlbnYubWV0aG9kLnRvVXBwZXJDYXNlKCksIHVybCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgaW4gZW52LmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgZW52LmhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBvbih4aHIsICdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDAgfHwgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeGhyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24oRXJyb3IoeGhyLnN0YXR1c1RleHQpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb24oeGhyLCAnZXJyb3InLCAoKSA9PiByZWplY3QoYXNzaWduKEVycm9yKCdOZXR3b3JrIEVycm9yJyksIHsgeGhyIH0pKSk7XG4gICAgICAgIG9uKHhociwgJ3RpbWVvdXQnLCAoKSA9PiByZWplY3QoYXNzaWduKEVycm9yKCdOZXR3b3JrIFRpbWVvdXQnKSwgeyB4aHIgfSkpKTtcblxuICAgICAgICB4aHIuc2VuZChlbnYuZGF0YSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWFnZShzcmMsIHNyY3NldCwgc2l6ZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2l6ZXMgJiYgKGltZy5zaXplcyA9IHNpemVzKTtcbiAgICAgICAgc3Jjc2V0ICYmIChpbWcuc3Jjc2V0ID0gc3Jjc2V0KTtcbiAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/ajax.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/animation.js":
/*!*****************************************************!*\
  !*** ./node_modules/uikit/src/js/util/animation.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Animation\": () => (/* binding */ Animation),\n/* harmony export */   \"Transition\": () => (/* binding */ Transition),\n/* harmony export */   \"animate\": () => (/* binding */ animate),\n/* harmony export */   \"transition\": () => (/* binding */ transition)\n/* harmony export */ });\n/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attr */ \"./node_modules/uikit/src/js/util/attr.js\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event */ \"./node_modules/uikit/src/js/util/event.js\");\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style */ \"./node_modules/uikit/src/js/util/style.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./class */ \"./node_modules/uikit/src/js/util/class.js\");\n\n\n\n\n\n\nfunction transition(element, props, duration = 400, timing = 'linear') {\n    return Promise.all(\n        (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element).map(\n            (element) =>\n                new Promise((resolve, reject) => {\n                    for (const name in props) {\n                        const value = (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, name);\n                        if (value === '') {\n                            (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, name, value);\n                        }\n                    }\n\n                    const timer = setTimeout(() => (0,_event__WEBPACK_IMPORTED_MODULE_2__.trigger)(element, 'transitionend'), duration);\n\n                    (0,_event__WEBPACK_IMPORTED_MODULE_2__.once)(\n                        element,\n                        'transitionend transitioncanceled',\n                        ({ type }) => {\n                            clearTimeout(timer);\n                            (0,_class__WEBPACK_IMPORTED_MODULE_3__.removeClass)(element, 'uk-transition');\n                            (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, {\n                                transitionProperty: '',\n                                transitionDuration: '',\n                                transitionTimingFunction: '',\n                            });\n                            type === 'transitioncanceled' ? reject() : resolve(element);\n                        },\n                        { self: true }\n                    );\n\n                    (0,_class__WEBPACK_IMPORTED_MODULE_3__.addClass)(element, 'uk-transition');\n                    (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, {\n                        transitionProperty: Object.keys(props).map(_style__WEBPACK_IMPORTED_MODULE_1__.propName).join(','),\n                        transitionDuration: `${duration}ms`,\n                        transitionTimingFunction: timing,\n                        ...props,\n                    });\n                })\n        )\n    );\n}\n\nconst Transition = {\n    start: transition,\n\n    stop(element) {\n        (0,_event__WEBPACK_IMPORTED_MODULE_2__.trigger)(element, 'transitionend');\n        return Promise.resolve();\n    },\n\n    cancel(element) {\n        (0,_event__WEBPACK_IMPORTED_MODULE_2__.trigger)(element, 'transitioncanceled');\n    },\n\n    inProgress(element) {\n        return (0,_class__WEBPACK_IMPORTED_MODULE_3__.hasClass)(element, 'uk-transition');\n    },\n};\n\nconst animationPrefix = 'uk-animation-';\n\nfunction animate(element, animation, duration = 200, origin, out) {\n    return Promise.all(\n        (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element).map(\n            (element) =>\n                new Promise((resolve, reject) => {\n                    (0,_event__WEBPACK_IMPORTED_MODULE_2__.trigger)(element, 'animationcanceled');\n                    const timer = setTimeout(() => (0,_event__WEBPACK_IMPORTED_MODULE_2__.trigger)(element, 'animationend'), duration);\n\n                    (0,_event__WEBPACK_IMPORTED_MODULE_2__.once)(\n                        element,\n                        'animationend animationcanceled',\n                        ({ type }) => {\n                            clearTimeout(timer);\n\n                            type === 'animationcanceled' ? reject() : resolve(element);\n\n                            (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, 'animationDuration', '');\n                            (0,_class__WEBPACK_IMPORTED_MODULE_3__.removeClasses)(element, `${animationPrefix}\\\\S*`);\n                        },\n                        { self: true }\n                    );\n\n                    (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, 'animationDuration', `${duration}ms`);\n                    (0,_class__WEBPACK_IMPORTED_MODULE_3__.addClass)(element, animation, animationPrefix + (out ? 'leave' : 'enter'));\n\n                    if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.startsWith)(animation, animationPrefix)) {\n                        origin && (0,_class__WEBPACK_IMPORTED_MODULE_3__.addClass)(element, `uk-transform-origin-${origin}`);\n                        out && (0,_class__WEBPACK_IMPORTED_MODULE_3__.addClass)(element, `${animationPrefix}reverse`);\n                    }\n                })\n        )\n    );\n}\n\nconst inProgress = new RegExp(`${animationPrefix}(enter|leave)`);\nconst Animation = {\n    in: animate,\n\n    out(element, animation, duration, origin) {\n        return animate(element, animation, duration, origin, true);\n    },\n\n    inProgress(element) {\n        return inProgress.test((0,_attr__WEBPACK_IMPORTED_MODULE_4__.attr)(element, 'class'));\n    },\n\n    cancel(element) {\n        (0,_event__WEBPACK_IMPORTED_MODULE_2__.trigger)(element, 'animationcanceled');\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvYW5pbWF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE4QjtBQUNVO0FBQ0E7QUFDSztBQUM0Qjs7QUFFbEU7QUFDUDtBQUNBLFFBQVEsOENBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkNBQUc7QUFDekM7QUFDQSw0QkFBNEIsMkNBQUc7QUFDL0I7QUFDQTs7QUFFQSxtREFBbUQsK0NBQU87O0FBRTFELG9CQUFvQiw0Q0FBSTtBQUN4QjtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQSw0QkFBNEIsbURBQVc7QUFDdkMsNEJBQTRCLDJDQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUI7O0FBRUEsb0JBQW9CLGdEQUFRO0FBQzVCLG9CQUFvQiwyQ0FBRztBQUN2QixtRUFBbUUsNENBQVE7QUFDM0UsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQSxRQUFRLCtDQUFPO0FBQ2Y7QUFDQSxLQUFLOztBQUVMO0FBQ0EsUUFBUSwrQ0FBTztBQUNmLEtBQUs7O0FBRUw7QUFDQSxlQUFlLGdEQUFRO0FBQ3ZCLEtBQUs7QUFDTDs7QUFFQTs7QUFFTztBQUNQO0FBQ0EsUUFBUSw4Q0FBTztBQUNmO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQU87QUFDM0IsbURBQW1ELCtDQUFPOztBQUUxRCxvQkFBb0IsNENBQUk7QUFDeEI7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDOztBQUVBOztBQUVBLDRCQUE0QiwyQ0FBRztBQUMvQiw0QkFBNEIscURBQWEsYUFBYSxnQkFBZ0I7QUFDdEUseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQjs7QUFFQSxvQkFBb0IsMkNBQUcsa0NBQWtDLFNBQVM7QUFDbEUsb0JBQW9CLGdEQUFROztBQUU1Qix3QkFBd0IsaURBQVU7QUFDbEMsa0NBQWtDLGdEQUFRLGlDQUFpQyxPQUFPO0FBQ2xGLCtCQUErQixnREFBUSxhQUFhLGdCQUFnQjtBQUNwRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGdCQUFnQjtBQUMxQztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0JBQStCLDJDQUFJO0FBQ25DLEtBQUs7O0FBRUw7QUFDQSxRQUFRLCtDQUFPO0FBQ2YsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Vpa2l0L3NyYy9qcy91dGlsL2FuaW1hdGlvbi5qcz85ZWFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF0dHIgfSBmcm9tICcuL2F0dHInO1xuaW1wb3J0IHsgb25jZSwgdHJpZ2dlciB9IGZyb20gJy4vZXZlbnQnO1xuaW1wb3J0IHsgY3NzLCBwcm9wTmFtZSB9IGZyb20gJy4vc3R5bGUnO1xuaW1wb3J0IHsgc3RhcnRzV2l0aCwgdG9Ob2RlcyB9IGZyb20gJy4vbGFuZyc7XG5pbXBvcnQgeyBhZGRDbGFzcywgaGFzQ2xhc3MsIHJlbW92ZUNsYXNzLCByZW1vdmVDbGFzc2VzIH0gZnJvbSAnLi9jbGFzcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aW9uKGVsZW1lbnQsIHByb3BzLCBkdXJhdGlvbiA9IDQwMCwgdGltaW5nID0gJ2xpbmVhcicpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKFxuICAgICAgICAgICAgKGVsZW1lbnQpID0+XG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3NzKGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcyhlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdHJpZ2dlcihlbGVtZW50LCAndHJhbnNpdGlvbmVuZCcpLCBkdXJhdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgb25jZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNpdGlvbmVuZCB0cmFuc2l0aW9uY2FuY2VsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHsgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCAndWstdHJhbnNpdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gJ3RyYW5zaXRpb25jYW5jZWxlZCcgPyByZWplY3QoKSA6IHJlc29sdmUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBzZWxmOiB0cnVlIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCAndWstdHJhbnNpdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICBjc3MoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBPYmplY3Qua2V5cyhwcm9wcykubWFwKHByb3BOYW1lKS5qb2luKCcsJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2R1cmF0aW9ufW1zYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogdGltaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICApO1xufVxuXG5leHBvcnQgY29uc3QgVHJhbnNpdGlvbiA9IHtcbiAgICBzdGFydDogdHJhbnNpdGlvbixcblxuICAgIHN0b3AoZWxlbWVudCkge1xuICAgICAgICB0cmlnZ2VyKGVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9LFxuXG4gICAgY2FuY2VsKGVsZW1lbnQpIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAndHJhbnNpdGlvbmNhbmNlbGVkJyk7XG4gICAgfSxcblxuICAgIGluUHJvZ3Jlc3MoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaGFzQ2xhc3MoZWxlbWVudCwgJ3VrLXRyYW5zaXRpb24nKTtcbiAgICB9LFxufTtcblxuY29uc3QgYW5pbWF0aW9uUHJlZml4ID0gJ3VrLWFuaW1hdGlvbi0nO1xuXG5leHBvcnQgZnVuY3Rpb24gYW5pbWF0ZShlbGVtZW50LCBhbmltYXRpb24sIGR1cmF0aW9uID0gMjAwLCBvcmlnaW4sIG91dCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgdG9Ob2RlcyhlbGVtZW50KS5tYXAoXG4gICAgICAgICAgICAoZWxlbWVudCkgPT5cbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoZWxlbWVudCwgJ2FuaW1hdGlvbmNhbmNlbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0cmlnZ2VyKGVsZW1lbnQsICdhbmltYXRpb25lbmQnKSwgZHVyYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuaW1hdGlvbmVuZCBhbmltYXRpb25jYW5jZWxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAoeyB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gJ2FuaW1hdGlvbmNhbmNlbGVkJyA/IHJlamVjdCgpIDogcmVzb2x2ZShlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcyhlbGVtZW50LCAnYW5pbWF0aW9uRHVyYXRpb24nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NlcyhlbGVtZW50LCBgJHthbmltYXRpb25QcmVmaXh9XFxcXFMqYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBzZWxmOiB0cnVlIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBjc3MoZWxlbWVudCwgJ2FuaW1hdGlvbkR1cmF0aW9uJywgYCR7ZHVyYXRpb259bXNgKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgYW5pbWF0aW9uLCBhbmltYXRpb25QcmVmaXggKyAob3V0ID8gJ2xlYXZlJyA6ICdlbnRlcicpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChhbmltYXRpb24sIGFuaW1hdGlvblByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbiAmJiBhZGRDbGFzcyhlbGVtZW50LCBgdWstdHJhbnNmb3JtLW9yaWdpbi0ke29yaWdpbn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCAmJiBhZGRDbGFzcyhlbGVtZW50LCBgJHthbmltYXRpb25QcmVmaXh9cmV2ZXJzZWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICk7XG59XG5cbmNvbnN0IGluUHJvZ3Jlc3MgPSBuZXcgUmVnRXhwKGAke2FuaW1hdGlvblByZWZpeH0oZW50ZXJ8bGVhdmUpYCk7XG5leHBvcnQgY29uc3QgQW5pbWF0aW9uID0ge1xuICAgIGluOiBhbmltYXRlLFxuXG4gICAgb3V0KGVsZW1lbnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0ZShlbGVtZW50LCBhbmltYXRpb24sIGR1cmF0aW9uLCBvcmlnaW4sIHRydWUpO1xuICAgIH0sXG5cbiAgICBpblByb2dyZXNzKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGluUHJvZ3Jlc3MudGVzdChhdHRyKGVsZW1lbnQsICdjbGFzcycpKTtcbiAgICB9LFxuXG4gICAgY2FuY2VsKGVsZW1lbnQpIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCAnYW5pbWF0aW9uY2FuY2VsZWQnKTtcbiAgICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/animation.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/attr.js":
/*!************************************************!*\
  !*** ./node_modules/uikit/src/js/util/attr.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"attr\": () => (/* binding */ attr),\n/* harmony export */   \"data\": () => (/* binding */ data),\n/* harmony export */   \"hasAttr\": () => (/* binding */ hasAttr),\n/* harmony export */   \"removeAttr\": () => (/* binding */ removeAttr)\n/* harmony export */ });\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\nfunction attr(element, name, value) {\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isObject)(name)) {\n        for (const key in name) {\n            attr(element, key, name[key]);\n        }\n        return;\n    }\n\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(value)) {\n        return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(element)?.getAttribute(name);\n    } else {\n        for (const el of (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element)) {\n            if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) {\n                value = value.call(el, attr(el, name));\n            }\n\n            if (value === null) {\n                removeAttr(el, name);\n            } else {\n                el.setAttribute(name, value);\n            }\n        }\n    }\n}\n\nfunction hasAttr(element, name) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element).some((element) => element.hasAttribute(name));\n}\n\nfunction removeAttr(element, name) {\n    const elements = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element);\n    for (const attribute of name.split(' ')) {\n        for (const element of elements) {\n            element.removeAttribute(attribute);\n        }\n    }\n}\n\nfunction data(element, attribute) {\n    for (const name of [attribute, `data-${attribute}`]) {\n        if (hasAttr(element, name)) {\n            return attr(element, name);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvYXR0ci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0RTs7QUFFckU7QUFDUCxRQUFRLCtDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxrREFBVztBQUNuQixlQUFlLDZDQUFNO0FBQ3JCLE1BQU07QUFDTix5QkFBeUIsOENBQU87QUFDaEMsZ0JBQWdCLGlEQUFVO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsV0FBVyw4Q0FBTztBQUNsQjs7QUFFTztBQUNQLHFCQUFxQiw4Q0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Vpa2l0L3NyYy9qcy91dGlsL2F0dHIuanM/MGRkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNVbmRlZmluZWQsIHRvTm9kZSwgdG9Ob2RlcyB9IGZyb20gJy4vbGFuZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhdHRyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5hbWUpIHtcbiAgICAgICAgICAgIGF0dHIoZWxlbWVudCwga2V5LCBuYW1lW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0b05vZGUoZWxlbWVudCk/LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRvTm9kZXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2FsbChlbCwgYXR0cihlbCwgbmFtZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0F0dHIoZWxlbWVudCwgbmFtZSkge1xuICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQpID0+IGVsZW1lbnQuaGFzQXR0cmlidXRlKG5hbWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUF0dHIoZWxlbWVudCwgbmFtZSkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdG9Ob2RlcyhlbGVtZW50KTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBuYW1lLnNwbGl0KCcgJykpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF0YShlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgW2F0dHJpYnV0ZSwgYGRhdGEtJHthdHRyaWJ1dGV9YF0pIHtcbiAgICAgICAgaWYgKGhhc0F0dHIoZWxlbWVudCwgbmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRyKGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/attr.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/class.js":
/*!*************************************************!*\
  !*** ./node_modules/uikit/src/js/util/class.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addClass\": () => (/* binding */ addClass),\n/* harmony export */   \"hasClass\": () => (/* binding */ hasClass),\n/* harmony export */   \"removeClass\": () => (/* binding */ removeClass),\n/* harmony export */   \"removeClasses\": () => (/* binding */ removeClasses),\n/* harmony export */   \"replaceClass\": () => (/* binding */ replaceClass),\n/* harmony export */   \"toggleClass\": () => (/* binding */ toggleClass)\n/* harmony export */ });\n/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attr */ \"./node_modules/uikit/src/js/util/attr.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\n\nfunction addClass(element, ...args) {\n    apply(element, args, 'add');\n}\n\nfunction removeClass(element, ...args) {\n    apply(element, args, 'remove');\n}\n\nfunction removeClasses(element, cls) {\n    (0,_attr__WEBPACK_IMPORTED_MODULE_0__.attr)(element, 'class', (value) => (value || '').replace(new RegExp(`\\\\b${cls}\\\\b`, 'g'), ''));\n}\n\nfunction replaceClass(element, ...args) {\n    args[0] && removeClass(element, args[0]);\n    args[1] && addClass(element, args[1]);\n}\n\nfunction hasClass(element, cls) {\n    [cls] = getClasses(cls);\n    return !!cls && (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNodes)(element).some((node) => node.classList.contains(cls));\n}\n\nfunction toggleClass(element, cls, force) {\n    const classes = getClasses(cls);\n\n    if (!(0,_lang__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(force)) {\n        force = !!force;\n    }\n\n    for (const node of (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNodes)(element)) {\n        for (const cls of classes) {\n            node.classList.toggle(cls, force);\n        }\n    }\n}\n\nfunction apply(element, args, fn) {\n    args = args.reduce((args, arg) => args.concat(getClasses(arg)), []);\n\n    for (const node of (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNodes)(element)) {\n        node.classList[fn](...args);\n    }\n}\n\nfunction getClasses(str) {\n    return String(str).split(/\\s|,/).filter(Boolean);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvY2xhc3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBOEI7QUFDZ0I7O0FBRXZDO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUCxJQUFJLDJDQUFJLHFFQUFxRSxJQUFJO0FBQ2pGOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxvQkFBb0IsOENBQU87QUFDM0I7O0FBRU87QUFDUDs7QUFFQSxTQUFTLGtEQUFXO0FBQ3BCO0FBQ0E7O0FBRUEsdUJBQXVCLDhDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsOENBQU87QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91aWtpdC9zcmMvanMvdXRpbC9jbGFzcy5qcz9jNWE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF0dHIgfSBmcm9tICcuL2F0dHInO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQsIHRvTm9kZXMgfSBmcm9tICcuL2xhbmcnO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgLi4uYXJncykge1xuICAgIGFwcGx5KGVsZW1lbnQsIGFyZ3MsICdhZGQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIC4uLmFyZ3MpIHtcbiAgICBhcHBseShlbGVtZW50LCBhcmdzLCAncmVtb3ZlJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKGVsZW1lbnQsIGNscykge1xuICAgIGF0dHIoZWxlbWVudCwgJ2NsYXNzJywgKHZhbHVlKSA9PiAodmFsdWUgfHwgJycpLnJlcGxhY2UobmV3IFJlZ0V4cChgXFxcXGIke2Nsc31cXFxcYmAsICdnJyksICcnKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlQ2xhc3MoZWxlbWVudCwgLi4uYXJncykge1xuICAgIGFyZ3NbMF0gJiYgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgYXJnc1swXSk7XG4gICAgYXJnc1sxXSAmJiBhZGRDbGFzcyhlbGVtZW50LCBhcmdzWzFdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNscykge1xuICAgIFtjbHNdID0gZ2V0Q2xhc3NlcyhjbHMpO1xuICAgIHJldHVybiAhIWNscyAmJiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKG5vZGUpID0+IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNscykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xzLCBmb3JjZSkge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBnZXRDbGFzc2VzKGNscyk7XG5cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZvcmNlKSkge1xuICAgICAgICBmb3JjZSA9ICEhZm9yY2U7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRvTm9kZXMoZWxlbWVudCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBjbHMgb2YgY2xhc3Nlcykge1xuICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QudG9nZ2xlKGNscywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcHBseShlbGVtZW50LCBhcmdzLCBmbikge1xuICAgIGFyZ3MgPSBhcmdzLnJlZHVjZSgoYXJncywgYXJnKSA9PiBhcmdzLmNvbmNhdChnZXRDbGFzc2VzKGFyZykpLCBbXSk7XG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdG9Ob2RlcyhlbGVtZW50KSkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdFtmbl0oLi4uYXJncyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRDbGFzc2VzKHN0cikge1xuICAgIHJldHVybiBTdHJpbmcoc3RyKS5zcGxpdCgvXFxzfCwvKS5maWx0ZXIoQm9vbGVhbik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/class.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/dimensions.js":
/*!******************************************************!*\
  !*** ./node_modules/uikit/src/js/util/dimensions.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"boxModelAdjust\": () => (/* binding */ boxModelAdjust),\n/* harmony export */   \"dimensions\": () => (/* binding */ dimensions),\n/* harmony export */   \"flipPosition\": () => (/* binding */ flipPosition),\n/* harmony export */   \"height\": () => (/* binding */ height),\n/* harmony export */   \"offset\": () => (/* binding */ offset),\n/* harmony export */   \"offsetPosition\": () => (/* binding */ offsetPosition),\n/* harmony export */   \"position\": () => (/* binding */ position),\n/* harmony export */   \"toPx\": () => (/* binding */ toPx),\n/* harmony export */   \"width\": () => (/* binding */ width)\n/* harmony export */ });\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style */ \"./node_modules/uikit/src/js/util/style.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\n\nconst dirs = {\n    width: ['left', 'right'],\n    height: ['top', 'bottom'],\n};\n\nfunction dimensions(element) {\n    const rect = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isElement)(element)\n        ? (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(element).getBoundingClientRect()\n        : { height: height(element), width: width(element), top: 0, left: 0 };\n\n    return {\n        height: rect.height,\n        width: rect.width,\n        top: rect.top,\n        left: rect.left,\n        bottom: rect.top + rect.height,\n        right: rect.left + rect.width,\n    };\n}\n\nfunction offset(element, coordinates) {\n    const currentOffset = dimensions(element);\n\n    if (element) {\n        const { scrollY, scrollX } = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toWindow)(element);\n        const offsetBy = { height: scrollY, width: scrollX };\n\n        for (const dir in dirs) {\n            for (const prop of dirs[dir]) {\n                currentOffset[prop] += offsetBy[dir];\n            }\n        }\n    }\n\n    if (!coordinates) {\n        return currentOffset;\n    }\n\n    const pos = (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, 'position');\n\n    (0,_lang__WEBPACK_IMPORTED_MODULE_0__.each)((0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, ['left', 'top']), (value, prop) =>\n        (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(\n            element,\n            prop,\n            coordinates[prop] -\n                currentOffset[prop] +\n                (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)(pos === 'absolute' && value === 'auto' ? position(element)[prop] : value)\n        )\n    );\n}\n\nfunction position(element) {\n    let { top, left } = offset(element);\n\n    const {\n        ownerDocument: { body, documentElement },\n        offsetParent,\n    } = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(element);\n    let parent = offsetParent || documentElement;\n\n    while (\n        parent &&\n        (parent === body || parent === documentElement) &&\n        (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(parent, 'position') === 'static'\n    ) {\n        parent = parent.parentNode;\n    }\n\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isElement)(parent)) {\n        const parentOffset = offset(parent);\n        top -= parentOffset.top + (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)((0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(parent, 'borderTopWidth'));\n        left -= parentOffset.left + (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)((0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(parent, 'borderLeftWidth'));\n    }\n\n    return {\n        top: top - (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)((0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, 'marginTop')),\n        left: left - (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)((0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, 'marginLeft')),\n    };\n}\n\nfunction offsetPosition(element) {\n    const offset = [0, 0];\n\n    element = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(element);\n\n    do {\n        offset[0] += element.offsetTop;\n        offset[1] += element.offsetLeft;\n\n        if ((0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, 'position') === 'fixed') {\n            const win = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toWindow)(element);\n            offset[0] += win.scrollY;\n            offset[1] += win.scrollX;\n            return offset;\n        }\n    } while ((element = element.offsetParent));\n\n    return offset;\n}\n\nconst height = dimension('height');\nconst width = dimension('width');\n\nfunction dimension(prop) {\n    const propName = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.ucfirst)(prop);\n    return (element, value) => {\n        if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(value)) {\n            if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isWindow)(element)) {\n                return element[`inner${propName}`];\n            }\n\n            if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isDocument)(element)) {\n                const doc = element.documentElement;\n                return Math.max(doc[`offset${propName}`], doc[`scroll${propName}`]);\n            }\n\n            element = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(element);\n\n            value = (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, prop);\n            value = value === 'auto' ? element[`offset${propName}`] : (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)(value) || 0;\n\n            return value - boxModelAdjust(element, prop);\n        } else {\n            return (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(\n                element,\n                prop,\n                !value && value !== 0 ? '' : +value + boxModelAdjust(element, prop) + 'px'\n            );\n        }\n    };\n}\n\nfunction boxModelAdjust(element, prop, sizing = 'border-box') {\n    return (0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, 'boxSizing') === sizing\n        ? dirs[prop]\n              .map(_lang__WEBPACK_IMPORTED_MODULE_0__.ucfirst)\n              .reduce(\n                  (value, prop) =>\n                      value +\n                      (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)((0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, `padding${prop}`)) +\n                      (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)((0,_style__WEBPACK_IMPORTED_MODULE_1__.css)(element, `border${prop}Width`)),\n                  0\n              )\n        : 0;\n}\n\nfunction flipPosition(pos) {\n    for (const dir in dirs) {\n        for (const i in dirs[dir]) {\n            if (dirs[dir][i] === pos) {\n                return dirs[dir][1 - i];\n            }\n        }\n    }\n    return pos;\n}\n\nfunction toPx(value, property = 'width', element = window, offsetDim = false) {\n    if (!(0,_lang__WEBPACK_IMPORTED_MODULE_0__.isString)(value)) {\n        return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)(value);\n    }\n\n    return parseCalc(value).reduce((result, value) => {\n        const unit = parseUnit(value);\n        if (unit) {\n            value = percent(\n                unit === 'vh'\n                    ? height((0,_lang__WEBPACK_IMPORTED_MODULE_0__.toWindow)(element))\n                    : unit === 'vw'\n                    ? width((0,_lang__WEBPACK_IMPORTED_MODULE_0__.toWindow)(element))\n                    : offsetDim\n                    ? element[`offset${(0,_lang__WEBPACK_IMPORTED_MODULE_0__.ucfirst)(property)}`]\n                    : dimensions(element)[property],\n                value\n            );\n        }\n\n        return result + (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)(value);\n    }, 0);\n}\n\nconst calcRe = /-?\\d+(?:\\.\\d+)?(?:v[wh]|%|px)?/g;\nconst parseCalc = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.memoize)((calc) => calc.toString().replace(/\\s/g, '').match(calcRe) || []);\nconst unitRe = /(?:v[hw]|%)$/;\nconst parseUnit = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.memoize)((str) => (str.match(unitRe) || [])[0]);\n\nfunction percent(base, value) {\n    return (base * (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toFloat)(value)) / 100;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvZGltZW5zaW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE4QjtBQWFkOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLGlCQUFpQixnREFBUztBQUMxQixVQUFVLDZDQUFNO0FBQ2hCLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CLEVBQUUsK0NBQVE7QUFDN0MsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiwyQ0FBRzs7QUFFbkIsSUFBSSwyQ0FBSSxDQUFDLDJDQUFHO0FBQ1osUUFBUSwyQ0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsWUFBWTs7QUFFdEI7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0EsTUFBTSxFQUFFLDZDQUFNO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBRztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGdEQUFTO0FBQ2pCO0FBQ0Esa0NBQWtDLDhDQUFPLENBQUMsMkNBQUc7QUFDN0Msb0NBQW9DLDhDQUFPLENBQUMsMkNBQUc7QUFDL0M7O0FBRUE7QUFDQSxtQkFBbUIsOENBQU8sQ0FBQywyQ0FBRztBQUM5QixxQkFBcUIsOENBQU8sQ0FBQywyQ0FBRztBQUNoQztBQUNBOztBQUVPO0FBQ1A7O0FBRUEsY0FBYyw2Q0FBTTs7QUFFcEI7QUFDQTtBQUNBOztBQUVBLFlBQVksMkNBQUc7QUFDZix3QkFBd0IsK0NBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRU87QUFDQTs7QUFFUDtBQUNBLHFCQUFxQiw4Q0FBTztBQUM1QjtBQUNBLFlBQVksa0RBQVc7QUFDdkIsZ0JBQWdCLCtDQUFRO0FBQ3hCLHVDQUF1QyxTQUFTO0FBQ2hEOztBQUVBLGdCQUFnQixpREFBVTtBQUMxQjtBQUNBLDZDQUE2QyxTQUFTLGlCQUFpQixTQUFTO0FBQ2hGOztBQUVBLHNCQUFzQiw2Q0FBTTs7QUFFNUIsb0JBQW9CLDJDQUFHO0FBQ3ZCLHdEQUF3RCxTQUFTLEtBQUssOENBQU87O0FBRTdFO0FBQ0EsVUFBVTtBQUNWLG1CQUFtQiwyQ0FBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFdBQVcsMkNBQUc7QUFDZDtBQUNBLG1CQUFtQiwwQ0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOENBQU8sQ0FBQywyQ0FBRyxvQkFBb0IsS0FBSztBQUMxRCxzQkFBc0IsOENBQU8sQ0FBQywyQ0FBRyxtQkFBbUIsS0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFNBQVMsK0NBQVE7QUFDakIsZUFBZSw4Q0FBTztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtDQUFRO0FBQ3JDO0FBQ0EsNEJBQTRCLCtDQUFRO0FBQ3BDO0FBQ0EsdUNBQXVDLDhDQUFPLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDhDQUFPO0FBQy9CLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGtCQUFrQiw4Q0FBTztBQUN6QjtBQUNBLGtCQUFrQiw4Q0FBTzs7QUFFekI7QUFDQSxtQkFBbUIsOENBQU87QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvZGltZW5zaW9ucy5qcz9jZjY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNzcyB9IGZyb20gJy4vc3R5bGUnO1xuaW1wb3J0IHtcbiAgICBlYWNoLFxuICAgIGlzRG9jdW1lbnQsXG4gICAgaXNFbGVtZW50LFxuICAgIGlzU3RyaW5nLFxuICAgIGlzVW5kZWZpbmVkLFxuICAgIGlzV2luZG93LFxuICAgIG1lbW9pemUsXG4gICAgdG9GbG9hdCxcbiAgICB0b05vZGUsXG4gICAgdG9XaW5kb3csXG4gICAgdWNmaXJzdCxcbn0gZnJvbSAnLi9sYW5nJztcblxuY29uc3QgZGlycyA9IHtcbiAgICB3aWR0aDogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgaGVpZ2h0OiBbJ3RvcCcsICdib3R0b20nXSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgICBjb25zdCByZWN0ID0gaXNFbGVtZW50KGVsZW1lbnQpXG4gICAgICAgID8gdG9Ob2RlKGVsZW1lbnQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogeyBoZWlnaHQ6IGhlaWdodChlbGVtZW50KSwgd2lkdGg6IHdpZHRoKGVsZW1lbnQpLCB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgICAgIGJvdHRvbTogcmVjdC50b3AgKyByZWN0LmhlaWdodCxcbiAgICAgICAgcmlnaHQ6IHJlY3QubGVmdCArIHJlY3Qud2lkdGgsXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9mZnNldChlbGVtZW50LCBjb29yZGluYXRlcykge1xuICAgIGNvbnN0IGN1cnJlbnRPZmZzZXQgPSBkaW1lbnNpb25zKGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxZLCBzY3JvbGxYIH0gPSB0b1dpbmRvdyhlbGVtZW50KTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0QnkgPSB7IGhlaWdodDogc2Nyb2xsWSwgd2lkdGg6IHNjcm9sbFggfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGRpciBpbiBkaXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgZGlyc1tkaXJdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE9mZnNldFtwcm9wXSArPSBvZmZzZXRCeVtkaXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY3VycmVudE9mZnNldDtcbiAgICB9XG5cbiAgICBjb25zdCBwb3MgPSBjc3MoZWxlbWVudCwgJ3Bvc2l0aW9uJyk7XG5cbiAgICBlYWNoKGNzcyhlbGVtZW50LCBbJ2xlZnQnLCAndG9wJ10pLCAodmFsdWUsIHByb3ApID0+XG4gICAgICAgIGNzcyhcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXNbcHJvcF0gLVxuICAgICAgICAgICAgICAgIGN1cnJlbnRPZmZzZXRbcHJvcF0gK1xuICAgICAgICAgICAgICAgIHRvRmxvYXQocG9zID09PSAnYWJzb2x1dGUnICYmIHZhbHVlID09PSAnYXV0bycgPyBwb3NpdGlvbihlbGVtZW50KVtwcm9wXSA6IHZhbHVlKVxuICAgICAgICApXG4gICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgICBsZXQgeyB0b3AsIGxlZnQgfSA9IG9mZnNldChlbGVtZW50KTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgb3duZXJEb2N1bWVudDogeyBib2R5LCBkb2N1bWVudEVsZW1lbnQgfSxcbiAgICAgICAgb2Zmc2V0UGFyZW50LFxuICAgIH0gPSB0b05vZGUoZWxlbWVudCk7XG4gICAgbGV0IHBhcmVudCA9IG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cbiAgICB3aGlsZSAoXG4gICAgICAgIHBhcmVudCAmJlxuICAgICAgICAocGFyZW50ID09PSBib2R5IHx8IHBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50KSAmJlxuICAgICAgICBjc3MocGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYydcbiAgICApIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGlzRWxlbWVudChwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE9mZnNldCA9IG9mZnNldChwYXJlbnQpO1xuICAgICAgICB0b3AgLT0gcGFyZW50T2Zmc2V0LnRvcCArIHRvRmxvYXQoY3NzKHBhcmVudCwgJ2JvcmRlclRvcFdpZHRoJykpO1xuICAgICAgICBsZWZ0IC09IHBhcmVudE9mZnNldC5sZWZ0ICsgdG9GbG9hdChjc3MocGFyZW50LCAnYm9yZGVyTGVmdFdpZHRoJykpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wIC0gdG9GbG9hdChjc3MoZWxlbWVudCwgJ21hcmdpblRvcCcpKSxcbiAgICAgICAgbGVmdDogbGVmdCAtIHRvRmxvYXQoY3NzKGVsZW1lbnQsICdtYXJnaW5MZWZ0JykpLFxuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvZmZzZXRQb3NpdGlvbihlbGVtZW50KSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gWzAsIDBdO1xuXG4gICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcblxuICAgIGRvIHtcbiAgICAgICAgb2Zmc2V0WzBdICs9IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICBvZmZzZXRbMV0gKz0gZWxlbWVudC5vZmZzZXRMZWZ0O1xuXG4gICAgICAgIGlmIChjc3MoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpbiA9IHRvV2luZG93KGVsZW1lbnQpO1xuICAgICAgICAgICAgb2Zmc2V0WzBdICs9IHdpbi5zY3JvbGxZO1xuICAgICAgICAgICAgb2Zmc2V0WzFdICs9IHdpbi5zY3JvbGxYO1xuICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKChlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQpKTtcblxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmV4cG9ydCBjb25zdCBoZWlnaHQgPSBkaW1lbnNpb24oJ2hlaWdodCcpO1xuZXhwb3J0IGNvbnN0IHdpZHRoID0gZGltZW5zaW9uKCd3aWR0aCcpO1xuXG5mdW5jdGlvbiBkaW1lbnNpb24ocHJvcCkge1xuICAgIGNvbnN0IHByb3BOYW1lID0gdWNmaXJzdChwcm9wKTtcbiAgICByZXR1cm4gKGVsZW1lbnQsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChpc1dpbmRvdyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50W2Bpbm5lciR7cHJvcE5hbWV9YF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0RvY3VtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0gZWxlbWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGRvY1tgb2Zmc2V0JHtwcm9wTmFtZX1gXSwgZG9jW2BzY3JvbGwke3Byb3BOYW1lfWBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcblxuICAgICAgICAgICAgdmFsdWUgPSBjc3MoZWxlbWVudCwgcHJvcCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSAnYXV0bycgPyBlbGVtZW50W2BvZmZzZXQke3Byb3BOYW1lfWBdIDogdG9GbG9hdCh2YWx1ZSkgfHwgMDtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gYm94TW9kZWxBZGp1c3QoZWxlbWVudCwgcHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3NzKFxuICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICAhdmFsdWUgJiYgdmFsdWUgIT09IDAgPyAnJyA6ICt2YWx1ZSArIGJveE1vZGVsQWRqdXN0KGVsZW1lbnQsIHByb3ApICsgJ3B4J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wLCBzaXppbmcgPSAnYm9yZGVyLWJveCcpIHtcbiAgICByZXR1cm4gY3NzKGVsZW1lbnQsICdib3hTaXppbmcnKSA9PT0gc2l6aW5nXG4gICAgICAgID8gZGlyc1twcm9wXVxuICAgICAgICAgICAgICAubWFwKHVjZmlyc3QpXG4gICAgICAgICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgICAodmFsdWUsIHByb3ApID0+XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICAgIHRvRmxvYXQoY3NzKGVsZW1lbnQsIGBwYWRkaW5nJHtwcm9wfWApKSArXG4gICAgICAgICAgICAgICAgICAgICAgdG9GbG9hdChjc3MoZWxlbWVudCwgYGJvcmRlciR7cHJvcH1XaWR0aGApKSxcbiAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKVxuICAgICAgICA6IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGlwUG9zaXRpb24ocG9zKSB7XG4gICAgZm9yIChjb25zdCBkaXIgaW4gZGlycykge1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gZGlyc1tkaXJdKSB7XG4gICAgICAgICAgICBpZiAoZGlyc1tkaXJdW2ldID09PSBwb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyc1tkaXJdWzEgLSBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9QeCh2YWx1ZSwgcHJvcGVydHkgPSAnd2lkdGgnLCBlbGVtZW50ID0gd2luZG93LCBvZmZzZXREaW0gPSBmYWxzZSkge1xuICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0b0Zsb2F0KHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VDYWxjKHZhbHVlKS5yZWR1Y2UoKHJlc3VsdCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdW5pdCA9IHBhcnNlVW5pdCh2YWx1ZSk7XG4gICAgICAgIGlmICh1bml0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBlcmNlbnQoXG4gICAgICAgICAgICAgICAgdW5pdCA9PT0gJ3ZoJ1xuICAgICAgICAgICAgICAgICAgICA/IGhlaWdodCh0b1dpbmRvdyhlbGVtZW50KSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bml0ID09PSAndncnXG4gICAgICAgICAgICAgICAgICAgID8gd2lkdGgodG9XaW5kb3coZWxlbWVudCkpXG4gICAgICAgICAgICAgICAgICAgIDogb2Zmc2V0RGltXG4gICAgICAgICAgICAgICAgICAgID8gZWxlbWVudFtgb2Zmc2V0JHt1Y2ZpcnN0KHByb3BlcnR5KX1gXVxuICAgICAgICAgICAgICAgICAgICA6IGRpbWVuc2lvbnMoZWxlbWVudClbcHJvcGVydHldLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHRvRmxvYXQodmFsdWUpO1xuICAgIH0sIDApO1xufVxuXG5jb25zdCBjYWxjUmUgPSAvLT9cXGQrKD86XFwuXFxkKyk/KD86dlt3aF18JXxweCk/L2c7XG5jb25zdCBwYXJzZUNhbGMgPSBtZW1vaXplKChjYWxjKSA9PiBjYWxjLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzL2csICcnKS5tYXRjaChjYWxjUmUpIHx8IFtdKTtcbmNvbnN0IHVuaXRSZSA9IC8oPzp2W2h3XXwlKSQvO1xuY29uc3QgcGFyc2VVbml0ID0gbWVtb2l6ZSgoc3RyKSA9PiAoc3RyLm1hdGNoKHVuaXRSZSkgfHwgW10pWzBdKTtcblxuZnVuY3Rpb24gcGVyY2VudChiYXNlLCB2YWx1ZSkge1xuICAgIHJldHVybiAoYmFzZSAqIHRvRmxvYXQodmFsdWUpKSAvIDEwMDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/dimensions.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/dom.js":
/*!***********************************************!*\
  !*** ./node_modules/uikit/src/js/util/dom.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$\": () => (/* binding */ $),\n/* harmony export */   \"$$\": () => (/* binding */ $$),\n/* harmony export */   \"after\": () => (/* binding */ after),\n/* harmony export */   \"append\": () => (/* binding */ append),\n/* harmony export */   \"apply\": () => (/* binding */ apply),\n/* harmony export */   \"before\": () => (/* binding */ before),\n/* harmony export */   \"empty\": () => (/* binding */ empty),\n/* harmony export */   \"fragment\": () => (/* binding */ fragment),\n/* harmony export */   \"html\": () => (/* binding */ html),\n/* harmony export */   \"isTag\": () => (/* binding */ isTag),\n/* harmony export */   \"prepend\": () => (/* binding */ prepend),\n/* harmony export */   \"ready\": () => (/* binding */ ready),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"replaceChildren\": () => (/* binding */ replaceChildren),\n/* harmony export */   \"unwrap\": () => (/* binding */ unwrap),\n/* harmony export */   \"wrapAll\": () => (/* binding */ wrapAll),\n/* harmony export */   \"wrapInner\": () => (/* binding */ wrapInner)\n/* harmony export */ });\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event */ \"./node_modules/uikit/src/js/util/event.js\");\n/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ \"./node_modules/uikit/src/js/util/filter.js\");\n/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selector */ \"./node_modules/uikit/src/js/util/selector.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\n\n\n\nfunction ready(fn) {\n    if (document.readyState !== 'loading') {\n        fn();\n        return;\n    }\n\n    (0,_event__WEBPACK_IMPORTED_MODULE_0__.once)(document, 'DOMContentLoaded', fn);\n}\n\nfunction isTag(element, tagName) {\n    return element?.tagName?.toLowerCase() === tagName.toLowerCase();\n}\n\nfunction empty(element) {\n    return replaceChildren(element, '');\n}\n\nfunction html(parent, html) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(html) ? $(parent).innerHTML : replaceChildren(parent, html);\n}\n\nconst replaceChildren = applyFn('replaceChildren');\nconst prepend = applyFn('prepend');\nconst append = applyFn('append');\nconst before = applyFn('before');\nconst after = applyFn('after');\n\nfunction applyFn(fn) {\n    return function (ref, element) {\n        const nodes = (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNodes)((0,_lang__WEBPACK_IMPORTED_MODULE_1__.isString)(element) ? fragment(element) : element);\n        $(ref)?.[fn](...nodes);\n        return unwrapSingle(nodes);\n    };\n}\n\nfunction remove(element) {\n    (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNodes)(element).forEach((element) => element.remove());\n}\n\nfunction wrapAll(element, structure) {\n    structure = (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNode)(before(element, structure));\n\n    while (structure.firstChild) {\n        structure = structure.firstChild;\n    }\n\n    append(structure, element);\n\n    return structure;\n}\n\nfunction wrapInner(element, structure) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNodes)(\n        (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNodes)(element).map((element) =>\n            element.hasChildNodes()\n                ? wrapAll((0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNodes)(element.childNodes), structure)\n                : append(element, structure)\n        )\n    );\n}\n\nfunction unwrap(element) {\n    (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNodes)(element)\n        .map(_filter__WEBPACK_IMPORTED_MODULE_2__.parent)\n        .filter((value, index, self) => self.indexOf(value) === index)\n        .forEach((parent) => parent.replaceWith(...parent.childNodes));\n}\n\nconst fragmentRe = /^\\s*<(\\w+|!)[^>]*>/;\nconst singleTagRe = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\n\nfunction fragment(html) {\n    const matches = singleTagRe.exec(html);\n    if (matches) {\n        return document.createElement(matches[1]);\n    }\n\n    const container = document.createElement('div');\n    if (fragmentRe.test(html)) {\n        container.insertAdjacentHTML('beforeend', html.trim());\n    } else {\n        container.textContent = html;\n    }\n\n    return unwrapSingle(container.childNodes);\n}\n\nfunction unwrapSingle(nodes) {\n    return nodes.length > 1 ? nodes : nodes[0];\n}\n\nfunction apply(node, fn) {\n    if (!(0,_lang__WEBPACK_IMPORTED_MODULE_1__.isElement)(node)) {\n        return;\n    }\n\n    fn(node);\n    node = node.firstElementChild;\n    while (node) {\n        const next = node.nextElementSibling;\n        apply(node, fn);\n        node = next;\n    }\n}\n\nfunction $(selector, context) {\n    return isHtml(selector) ? (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNode)(fragment(selector)) : (0,_selector__WEBPACK_IMPORTED_MODULE_3__.find)(selector, context);\n}\n\nfunction $$(selector, context) {\n    return isHtml(selector) ? (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNodes)(fragment(selector)) : (0,_selector__WEBPACK_IMPORTED_MODULE_3__.findAll)(selector, context);\n}\n\nfunction isHtml(str) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_1__.isString)(str) && (0,_lang__WEBPACK_IMPORTED_MODULE_1__.startsWith)(str.trim(), '<');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvZG9tLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNHO0FBQ1M7QUFDNEM7O0FBRWhGO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSw0Q0FBSTtBQUNSOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUCxXQUFXLGtEQUFXO0FBQ3RCOztBQUVPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBLHNCQUFzQiw4Q0FBTyxDQUFDLCtDQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsSUFBSSw4Q0FBTztBQUNYOztBQUVPO0FBQ1AsZ0JBQWdCLDZDQUFNOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFTztBQUNQLFdBQVcsOENBQU87QUFDbEIsUUFBUSw4Q0FBTztBQUNmO0FBQ0EsMEJBQTBCLDhDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsSUFBSSw4Q0FBTztBQUNYLGFBQWEsMkNBQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFNBQVMsZ0RBQVM7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsOEJBQThCLDZDQUFNLHVCQUF1QiwrQ0FBSTtBQUMvRDs7QUFFTztBQUNQLDhCQUE4Qiw4Q0FBTyx1QkFBdUIsa0RBQU87QUFDbkU7O0FBRUE7QUFDQSxXQUFXLCtDQUFRLFNBQVMsaURBQVU7QUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvZG9tLmpzPzdhY2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb25jZSB9IGZyb20gJy4vZXZlbnQnO1xuaW1wb3J0IHsgcGFyZW50IH0gZnJvbSAnLi9maWx0ZXInO1xuaW1wb3J0IHsgZmluZCwgZmluZEFsbCB9IGZyb20gJy4vc2VsZWN0b3InO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc1N0cmluZywgaXNVbmRlZmluZWQsIHN0YXJ0c1dpdGgsIHRvTm9kZSwgdG9Ob2RlcyB9IGZyb20gJy4vbGFuZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkeShmbikge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9uY2UoZG9jdW1lbnQsICdET01Db250ZW50TG9hZGVkJywgZm4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUYWcoZWxlbWVudCwgdGFnTmFtZSkge1xuICAgIHJldHVybiBlbGVtZW50Py50YWdOYW1lPy50b0xvd2VyQ2FzZSgpID09PSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShlbGVtZW50KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VDaGlsZHJlbihlbGVtZW50LCAnJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBodG1sKHBhcmVudCwgaHRtbCkge1xuICAgIHJldHVybiBpc1VuZGVmaW5lZChodG1sKSA/ICQocGFyZW50KS5pbm5lckhUTUwgOiByZXBsYWNlQ2hpbGRyZW4ocGFyZW50LCBodG1sKTtcbn1cblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VDaGlsZHJlbiA9IGFwcGx5Rm4oJ3JlcGxhY2VDaGlsZHJlbicpO1xuZXhwb3J0IGNvbnN0IHByZXBlbmQgPSBhcHBseUZuKCdwcmVwZW5kJyk7XG5leHBvcnQgY29uc3QgYXBwZW5kID0gYXBwbHlGbignYXBwZW5kJyk7XG5leHBvcnQgY29uc3QgYmVmb3JlID0gYXBwbHlGbignYmVmb3JlJyk7XG5leHBvcnQgY29uc3QgYWZ0ZXIgPSBhcHBseUZuKCdhZnRlcicpO1xuXG5mdW5jdGlvbiBhcHBseUZuKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWYsIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0b05vZGVzKGlzU3RyaW5nKGVsZW1lbnQpID8gZnJhZ21lbnQoZWxlbWVudCkgOiBlbGVtZW50KTtcbiAgICAgICAgJChyZWYpPy5bZm5dKC4uLm5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZShub2Rlcyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG4gICAgdG9Ob2RlcyhlbGVtZW50KS5mb3JFYWNoKChlbGVtZW50KSA9PiBlbGVtZW50LnJlbW92ZSgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBBbGwoZWxlbWVudCwgc3RydWN0dXJlKSB7XG4gICAgc3RydWN0dXJlID0gdG9Ob2RlKGJlZm9yZShlbGVtZW50LCBzdHJ1Y3R1cmUpKTtcblxuICAgIHdoaWxlIChzdHJ1Y3R1cmUuZmlyc3RDaGlsZCkge1xuICAgICAgICBzdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmUuZmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBhcHBlbmQoc3RydWN0dXJlLCBlbGVtZW50KTtcblxuICAgIHJldHVybiBzdHJ1Y3R1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwSW5uZXIoZWxlbWVudCwgc3RydWN0dXJlKSB7XG4gICAgcmV0dXJuIHRvTm9kZXMoXG4gICAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKChlbGVtZW50KSA9PlxuICAgICAgICAgICAgZWxlbWVudC5oYXNDaGlsZE5vZGVzKClcbiAgICAgICAgICAgICAgICA/IHdyYXBBbGwodG9Ob2RlcyhlbGVtZW50LmNoaWxkTm9kZXMpLCBzdHJ1Y3R1cmUpXG4gICAgICAgICAgICAgICAgOiBhcHBlbmQoZWxlbWVudCwgc3RydWN0dXJlKVxuICAgICAgICApXG4gICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcChlbGVtZW50KSB7XG4gICAgdG9Ob2RlcyhlbGVtZW50KVxuICAgICAgICAubWFwKHBhcmVudClcbiAgICAgICAgLmZpbHRlcigodmFsdWUsIGluZGV4LCBzZWxmKSA9PiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleClcbiAgICAgICAgLmZvckVhY2goKHBhcmVudCkgPT4gcGFyZW50LnJlcGxhY2VXaXRoKC4uLnBhcmVudC5jaGlsZE5vZGVzKSk7XG59XG5cbmNvbnN0IGZyYWdtZW50UmUgPSAvXlxccyo8KFxcdyt8ISlbXj5dKj4vO1xuY29uc3Qgc2luZ2xlVGFnUmUgPSAvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPik/JC87XG5cbmV4cG9ydCBmdW5jdGlvbiBmcmFnbWVudChodG1sKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHNpbmdsZVRhZ1JlLmV4ZWMoaHRtbCk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobWF0Y2hlc1sxXSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWYgKGZyYWdtZW50UmUudGVzdChodG1sKSkge1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBodG1sLnRyaW0oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gaHRtbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdW53cmFwU2luZ2xlKGNvbnRhaW5lci5jaGlsZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwU2luZ2xlKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDEgPyBub2RlcyA6IG5vZGVzWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkobm9kZSwgZm4pIHtcbiAgICBpZiAoIWlzRWxlbWVudChub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm4obm9kZSk7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBhcHBseShub2RlLCBmbik7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uICQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gaXNIdG1sKHNlbGVjdG9yKSA/IHRvTm9kZShmcmFnbWVudChzZWxlY3RvcikpIDogZmluZChzZWxlY3RvciwgY29udGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAkJChzZWxlY3RvciwgY29udGV4dCkge1xuICAgIHJldHVybiBpc0h0bWwoc2VsZWN0b3IpID8gdG9Ob2RlcyhmcmFnbWVudChzZWxlY3RvcikpIDogZmluZEFsbChzZWxlY3RvciwgY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIGlzSHRtbChzdHIpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcoc3RyKSAmJiBzdGFydHNXaXRoKHN0ci50cmltKCksICc8Jyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/dom.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/env.js":
/*!***********************************************!*\
  !*** ./node_modules/uikit/src/js/util/env.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasTouch\": () => (/* binding */ hasTouch),\n/* harmony export */   \"inBrowser\": () => (/* binding */ inBrowser),\n/* harmony export */   \"isRtl\": () => (/* binding */ isRtl),\n/* harmony export */   \"pointerCancel\": () => (/* binding */ pointerCancel),\n/* harmony export */   \"pointerDown\": () => (/* binding */ pointerDown),\n/* harmony export */   \"pointerEnter\": () => (/* binding */ pointerEnter),\n/* harmony export */   \"pointerLeave\": () => (/* binding */ pointerLeave),\n/* harmony export */   \"pointerMove\": () => (/* binding */ pointerMove),\n/* harmony export */   \"pointerUp\": () => (/* binding */ pointerUp)\n/* harmony export */ });\n/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attr */ \"./node_modules/uikit/src/js/util/attr.js\");\n\n\nconst inBrowser = typeof window !== 'undefined';\nconst isRtl = inBrowser && (0,_attr__WEBPACK_IMPORTED_MODULE_0__.attr)(document.documentElement, 'dir') === 'rtl';\n\nconst hasTouch = inBrowser && 'ontouchstart' in window;\nconst hasPointerEvents = inBrowser && window.PointerEvent;\n\nconst pointerDown = hasPointerEvents ? 'pointerdown' : hasTouch ? 'touchstart' : 'mousedown';\nconst pointerMove = hasPointerEvents ? 'pointermove' : hasTouch ? 'touchmove' : 'mousemove';\nconst pointerUp = hasPointerEvents ? 'pointerup' : hasTouch ? 'touchend' : 'mouseup';\nconst pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouch ? '' : 'mouseenter';\nconst pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouch ? '' : 'mouseleave';\nconst pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvZW52LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBOEI7O0FBRXZCO0FBQ0EsMkJBQTJCLDJDQUFJOztBQUUvQjtBQUNQOztBQUVPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91aWtpdC9zcmMvanMvdXRpbC9lbnYuanM/MzEwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhdHRyIH0gZnJvbSAnLi9hdHRyJztcblxuZXhwb3J0IGNvbnN0IGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuZXhwb3J0IGNvbnN0IGlzUnRsID0gaW5Ccm93c2VyICYmIGF0dHIoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnZGlyJykgPT09ICdydGwnO1xuXG5leHBvcnQgY29uc3QgaGFzVG91Y2ggPSBpbkJyb3dzZXIgJiYgJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuY29uc3QgaGFzUG9pbnRlckV2ZW50cyA9IGluQnJvd3NlciAmJiB3aW5kb3cuUG9pbnRlckV2ZW50O1xuXG5leHBvcnQgY29uc3QgcG9pbnRlckRvd24gPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJkb3duJyA6IGhhc1RvdWNoID8gJ3RvdWNoc3RhcnQnIDogJ21vdXNlZG93bic7XG5leHBvcnQgY29uc3QgcG9pbnRlck1vdmUgPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJtb3ZlJyA6IGhhc1RvdWNoID8gJ3RvdWNobW92ZScgOiAnbW91c2Vtb3ZlJztcbmV4cG9ydCBjb25zdCBwb2ludGVyVXAgPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJ1cCcgOiBoYXNUb3VjaCA/ICd0b3VjaGVuZCcgOiAnbW91c2V1cCc7XG5leHBvcnQgY29uc3QgcG9pbnRlckVudGVyID0gaGFzUG9pbnRlckV2ZW50cyA/ICdwb2ludGVyZW50ZXInIDogaGFzVG91Y2ggPyAnJyA6ICdtb3VzZWVudGVyJztcbmV4cG9ydCBjb25zdCBwb2ludGVyTGVhdmUgPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJsZWF2ZScgOiBoYXNUb3VjaCA/ICcnIDogJ21vdXNlbGVhdmUnO1xuZXhwb3J0IGNvbnN0IHBvaW50ZXJDYW5jZWwgPSBoYXNQb2ludGVyRXZlbnRzID8gJ3BvaW50ZXJjYW5jZWwnIDogJ3RvdWNoY2FuY2VsJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/env.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/event.js":
/*!*************************************************!*\
  !*** ./node_modules/uikit/src/js/util/event.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createEvent\": () => (/* binding */ createEvent),\n/* harmony export */   \"getEventPos\": () => (/* binding */ getEventPos),\n/* harmony export */   \"isTouch\": () => (/* binding */ isTouch),\n/* harmony export */   \"off\": () => (/* binding */ off),\n/* harmony export */   \"on\": () => (/* binding */ on),\n/* harmony export */   \"once\": () => (/* binding */ once),\n/* harmony export */   \"toEventTargets\": () => (/* binding */ toEventTargets),\n/* harmony export */   \"trigger\": () => (/* binding */ trigger)\n/* harmony export */ });\n/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selector */ \"./node_modules/uikit/src/js/util/selector.js\");\n/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ \"./node_modules/uikit/src/js/util/filter.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\n\n\nfunction on(...args) {\n    let [targets, types, selector, listener, useCapture = false] = getArgs(args);\n\n    if (listener.length > 1) {\n        listener = detail(listener);\n    }\n\n    if (useCapture?.self) {\n        listener = selfFilter(listener);\n    }\n\n    if (selector) {\n        listener = delegate(selector, listener);\n    }\n\n    for (const type of types) {\n        for (const target of targets) {\n            target.addEventListener(type, listener, useCapture);\n        }\n    }\n\n    return () => off(targets, types, listener, useCapture);\n}\n\nfunction off(...args) {\n    let [targets, types, , listener, useCapture = false] = getArgs(args);\n    for (const type of types) {\n        for (const target of targets) {\n            target.removeEventListener(type, listener, useCapture);\n        }\n    }\n}\n\nfunction once(...args) {\n    const [element, types, selector, listener, useCapture = false, condition] = getArgs(args);\n    const off = on(\n        element,\n        types,\n        selector,\n        (e) => {\n            const result = !condition || condition(e);\n            if (result) {\n                off();\n                listener(e, result);\n            }\n        },\n        useCapture\n    );\n\n    return off;\n}\n\nfunction trigger(targets, event, detail) {\n    return toEventTargets(targets).every((target) =>\n        target.dispatchEvent(createEvent(event, true, true, detail))\n    );\n}\n\nfunction createEvent(e, bubbles = true, cancelable = false, detail) {\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isString)(e)) {\n        e = new CustomEvent(e, { bubbles, cancelable, detail });\n    }\n\n    return e;\n}\n\nfunction getArgs(args) {\n    // Event targets\n    args[0] = toEventTargets(args[0]);\n\n    // Event types\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isString)(args[1])) {\n        args[1] = args[1].split(' ');\n    }\n\n    // Delegate?\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isFunction)(args[2])) {\n        args.splice(2, 0, false);\n    }\n\n    return args;\n}\n\nfunction delegate(selector, listener) {\n    return (e) => {\n        const current =\n            selector[0] === '>'\n                ? (0,_selector__WEBPACK_IMPORTED_MODULE_1__.findAll)(selector, e.currentTarget)\n                      .reverse()\n                      .filter((element) => (0,_filter__WEBPACK_IMPORTED_MODULE_2__.within)(e.target, element))[0]\n                : (0,_filter__WEBPACK_IMPORTED_MODULE_2__.closest)(e.target, selector);\n\n        if (current) {\n            e.current = current;\n            listener.call(this, e);\n        }\n    };\n}\n\nfunction detail(listener) {\n    return (e) => ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isArray)(e.detail) ? listener(e, ...e.detail) : listener(e));\n}\n\nfunction selfFilter(listener) {\n    return function (e) {\n        if (e.target === e.currentTarget || e.target === e.current) {\n            return listener.call(null, e);\n        }\n    };\n}\n\nfunction isEventTarget(target) {\n    return target && 'addEventListener' in target;\n}\n\nfunction toEventTarget(target) {\n    return isEventTarget(target) ? target : (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(target);\n}\n\nfunction toEventTargets(target) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)\n        ? target.map(toEventTarget).filter(Boolean)\n        : (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isString)(target)\n        ? (0,_selector__WEBPACK_IMPORTED_MODULE_1__.findAll)(target)\n        : isEventTarget(target)\n        ? [target]\n        : (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(target);\n}\n\nfunction isTouch(e) {\n    return e.pointerType === 'touch' || !!e.touches;\n}\n\nfunction getEventPos(e) {\n    const { clientX: x, clientY: y } = e.touches?.[0] || e.changedTouches?.[0] || e;\n\n    return { x, y };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvZXZlbnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDTTtBQUM2Qjs7QUFFakU7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxRQUFRLCtDQUFRO0FBQ2hCLGlDQUFpQyw2QkFBNkI7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLCtDQUFRO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGlEQUFVO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrREFBTztBQUN6QjtBQUNBLDJDQUEyQywrQ0FBTTtBQUNqRCxrQkFBa0IsZ0RBQU87O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw4Q0FBTztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsNkNBQU07QUFDbEQ7O0FBRU87QUFDUCxXQUFXLDhDQUFPO0FBQ2xCO0FBQ0EsVUFBVSwrQ0FBUTtBQUNsQixVQUFVLGtEQUFPO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVLDhDQUFPO0FBQ2pCOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQLFlBQVkseUJBQXlCOztBQUVyQyxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvZXZlbnQuanM/MmE4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaW5kQWxsIH0gZnJvbSAnLi9zZWxlY3Rvcic7XG5pbXBvcnQgeyBjbG9zZXN0LCB3aXRoaW4gfSBmcm9tICcuL2ZpbHRlcic7XG5pbXBvcnQgeyBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgdG9Ob2RlLCB0b05vZGVzIH0gZnJvbSAnLi9sYW5nJztcblxuZXhwb3J0IGZ1bmN0aW9uIG9uKC4uLmFyZ3MpIHtcbiAgICBsZXQgW3RhcmdldHMsIHR5cGVzLCBzZWxlY3RvciwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZV0gPSBnZXRBcmdzKGFyZ3MpO1xuXG4gICAgaWYgKGxpc3RlbmVyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBkZXRhaWwobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGlmICh1c2VDYXB0dXJlPy5zZWxmKSB7XG4gICAgICAgIGxpc3RlbmVyID0gc2VsZkZpbHRlcihsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGxpc3RlbmVyID0gZGVsZWdhdGUoc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IG9mZih0YXJnZXRzLCB0eXBlcywgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2ZmKC4uLmFyZ3MpIHtcbiAgICBsZXQgW3RhcmdldHMsIHR5cGVzLCAsIGxpc3RlbmVyLCB1c2VDYXB0dXJlID0gZmFsc2VdID0gZ2V0QXJncyhhcmdzKTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25jZSguLi5hcmdzKSB7XG4gICAgY29uc3QgW2VsZW1lbnQsIHR5cGVzLCBzZWxlY3RvciwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZSwgY29uZGl0aW9uXSA9IGdldEFyZ3MoYXJncyk7XG4gICAgY29uc3Qgb2ZmID0gb24oXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHR5cGVzLFxuICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICFjb25kaXRpb24gfHwgY29uZGl0aW9uKGUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIG9mZigpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGUsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVzZUNhcHR1cmVcbiAgICApO1xuXG4gICAgcmV0dXJuIG9mZjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0cywgZXZlbnQsIGRldGFpbCkge1xuICAgIHJldHVybiB0b0V2ZW50VGFyZ2V0cyh0YXJnZXRzKS5ldmVyeSgodGFyZ2V0KSA9PlxuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSwgZGV0YWlsKSlcbiAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnQoZSwgYnViYmxlcyA9IHRydWUsIGNhbmNlbGFibGUgPSBmYWxzZSwgZGV0YWlsKSB7XG4gICAgaWYgKGlzU3RyaW5nKGUpKSB7XG4gICAgICAgIGUgPSBuZXcgQ3VzdG9tRXZlbnQoZSwgeyBidWJibGVzLCBjYW5jZWxhYmxlLCBkZXRhaWwgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGdldEFyZ3MoYXJncykge1xuICAgIC8vIEV2ZW50IHRhcmdldHNcbiAgICBhcmdzWzBdID0gdG9FdmVudFRhcmdldHMoYXJnc1swXSk7XG5cbiAgICAvLyBFdmVudCB0eXBlc1xuICAgIGlmIChpc1N0cmluZyhhcmdzWzFdKSkge1xuICAgICAgICBhcmdzWzFdID0gYXJnc1sxXS5zcGxpdCgnICcpO1xuICAgIH1cblxuICAgIC8vIERlbGVnYXRlP1xuICAgIGlmIChpc0Z1bmN0aW9uKGFyZ3NbMl0pKSB7XG4gICAgICAgIGFyZ3Muc3BsaWNlKDIsIDAsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJncztcbn1cblxuZnVuY3Rpb24gZGVsZWdhdGUoc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPVxuICAgICAgICAgICAgc2VsZWN0b3JbMF0gPT09ICc+J1xuICAgICAgICAgICAgICAgID8gZmluZEFsbChzZWxlY3RvciwgZS5jdXJyZW50VGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChlbGVtZW50KSA9PiB3aXRoaW4oZS50YXJnZXQsIGVsZW1lbnQpKVswXVxuICAgICAgICAgICAgICAgIDogY2xvc2VzdChlLnRhcmdldCwgc2VsZWN0b3IpO1xuXG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBlLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRldGFpbChsaXN0ZW5lcikge1xuICAgIHJldHVybiAoZSkgPT4gKGlzQXJyYXkoZS5kZXRhaWwpID8gbGlzdGVuZXIoZSwgLi4uZS5kZXRhaWwpIDogbGlzdGVuZXIoZSkpO1xufVxuXG5mdW5jdGlvbiBzZWxmRmlsdGVyKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8IGUudGFyZ2V0ID09PSBlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxsKG51bGwsIGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXNFdmVudFRhcmdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0ICYmICdhZGRFdmVudExpc3RlbmVyJyBpbiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHRvRXZlbnRUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGlzRXZlbnRUYXJnZXQodGFyZ2V0KSA/IHRhcmdldCA6IHRvTm9kZSh0YXJnZXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9FdmVudFRhcmdldHModGFyZ2V0KSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodGFyZ2V0KVxuICAgICAgICA/IHRhcmdldC5tYXAodG9FdmVudFRhcmdldCkuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIDogaXNTdHJpbmcodGFyZ2V0KVxuICAgICAgICA/IGZpbmRBbGwodGFyZ2V0KVxuICAgICAgICA6IGlzRXZlbnRUYXJnZXQodGFyZ2V0KVxuICAgICAgICA/IFt0YXJnZXRdXG4gICAgICAgIDogdG9Ob2Rlcyh0YXJnZXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb3VjaChlKSB7XG4gICAgcmV0dXJuIGUucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgfHwgISFlLnRvdWNoZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFdmVudFBvcyhlKSB7XG4gICAgY29uc3QgeyBjbGllbnRYOiB4LCBjbGllbnRZOiB5IH0gPSBlLnRvdWNoZXM/LlswXSB8fCBlLmNoYW5nZWRUb3VjaGVzPy5bMF0gfHwgZTtcblxuICAgIHJldHVybiB7IHgsIHkgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/event.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/fastdom.js":
/*!***************************************************!*\
  !*** ./node_modules/uikit/src/js/util/fastdom.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fastdom\": () => (/* binding */ fastdom)\n/* harmony export */ });\n/*\n    Based on:\n    Copyright (c) 2016 Wilson Page wilsonpage@me.com\n    https://github.com/wilsonpage/fastdom\n*/\n\nconst fastdom = {\n    reads: [],\n    writes: [],\n\n    read(task) {\n        this.reads.push(task);\n        scheduleFlush();\n        return task;\n    },\n\n    write(task) {\n        this.writes.push(task);\n        scheduleFlush();\n        return task;\n    },\n\n    clear(task) {\n        remove(this.reads, task);\n        remove(this.writes, task);\n    },\n\n    flush,\n};\n\nfunction flush(recursion) {\n    runTasks(fastdom.reads);\n    runTasks(fastdom.writes.splice(0));\n\n    fastdom.scheduled = false;\n\n    if (fastdom.reads.length || fastdom.writes.length) {\n        scheduleFlush(recursion + 1);\n    }\n}\n\nconst RECURSION_LIMIT = 4;\nfunction scheduleFlush(recursion) {\n    if (fastdom.scheduled) {\n        return;\n    }\n\n    fastdom.scheduled = true;\n    if (recursion && recursion < RECURSION_LIMIT) {\n        Promise.resolve().then(() => flush(recursion));\n    } else {\n        requestAnimationFrame(() => flush(1));\n    }\n}\n\nfunction runTasks(tasks) {\n    let task;\n    while ((task = tasks.shift())) {\n        try {\n            task();\n        } catch (e) {\n            console.error(e);\n        }\n    }\n}\n\nfunction remove(array, item) {\n    const index = array.indexOf(item);\n    return ~index && array.splice(index, 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvZmFzdGRvbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Vpa2l0L3NyYy9qcy91dGlsL2Zhc3Rkb20uanM/ZjYyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIEJhc2VkIG9uOlxuICAgIENvcHlyaWdodCAoYykgMjAxNiBXaWxzb24gUGFnZSB3aWxzb25wYWdlQG1lLmNvbVxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS93aWxzb25wYWdlL2Zhc3Rkb21cbiovXG5cbmV4cG9ydCBjb25zdCBmYXN0ZG9tID0ge1xuICAgIHJlYWRzOiBbXSxcbiAgICB3cml0ZXM6IFtdLFxuXG4gICAgcmVhZCh0YXNrKSB7XG4gICAgICAgIHRoaXMucmVhZHMucHVzaCh0YXNrKTtcbiAgICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICByZXR1cm4gdGFzaztcbiAgICB9LFxuXG4gICAgd3JpdGUodGFzaykge1xuICAgICAgICB0aGlzLndyaXRlcy5wdXNoKHRhc2spO1xuICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgIH0sXG5cbiAgICBjbGVhcih0YXNrKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLnJlYWRzLCB0YXNrKTtcbiAgICAgICAgcmVtb3ZlKHRoaXMud3JpdGVzLCB0YXNrKTtcbiAgICB9LFxuXG4gICAgZmx1c2gsXG59O1xuXG5mdW5jdGlvbiBmbHVzaChyZWN1cnNpb24pIHtcbiAgICBydW5UYXNrcyhmYXN0ZG9tLnJlYWRzKTtcbiAgICBydW5UYXNrcyhmYXN0ZG9tLndyaXRlcy5zcGxpY2UoMCkpO1xuXG4gICAgZmFzdGRvbS5zY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIGlmIChmYXN0ZG9tLnJlYWRzLmxlbmd0aCB8fCBmYXN0ZG9tLndyaXRlcy5sZW5ndGgpIHtcbiAgICAgICAgc2NoZWR1bGVGbHVzaChyZWN1cnNpb24gKyAxKTtcbiAgICB9XG59XG5cbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDQ7XG5mdW5jdGlvbiBzY2hlZHVsZUZsdXNoKHJlY3Vyc2lvbikge1xuICAgIGlmIChmYXN0ZG9tLnNjaGVkdWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFzdGRvbS5zY2hlZHVsZWQgPSB0cnVlO1xuICAgIGlmIChyZWN1cnNpb24gJiYgcmVjdXJzaW9uIDwgUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZmx1c2gocmVjdXJzaW9uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGZsdXNoKDEpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJ1blRhc2tzKHRhc2tzKSB7XG4gICAgbGV0IHRhc2s7XG4gICAgd2hpbGUgKCh0YXNrID0gdGFza3Muc2hpZnQoKSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIHJldHVybiB+aW5kZXggJiYgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/fastdom.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/filter.js":
/*!**************************************************!*\
  !*** ./node_modules/uikit/src/js/util/filter.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"children\": () => (/* binding */ children),\n/* harmony export */   \"closest\": () => (/* binding */ closest),\n/* harmony export */   \"filter\": () => (/* binding */ filter),\n/* harmony export */   \"index\": () => (/* binding */ index),\n/* harmony export */   \"isFocusable\": () => (/* binding */ isFocusable),\n/* harmony export */   \"isInput\": () => (/* binding */ isInput),\n/* harmony export */   \"isVisible\": () => (/* binding */ isVisible),\n/* harmony export */   \"isVoidElement\": () => (/* binding */ isVoidElement),\n/* harmony export */   \"matches\": () => (/* binding */ matches),\n/* harmony export */   \"parent\": () => (/* binding */ parent),\n/* harmony export */   \"parents\": () => (/* binding */ parents),\n/* harmony export */   \"selFocusable\": () => (/* binding */ selFocusable),\n/* harmony export */   \"selInput\": () => (/* binding */ selInput),\n/* harmony export */   \"within\": () => (/* binding */ within)\n/* harmony export */ });\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\nconst voidElements = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuitem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true,\n};\nfunction isVoidElement(element) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element).some((element) => voidElements[element.tagName.toLowerCase()]);\n}\n\nfunction isVisible(element) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element).some(\n        (element) => element.offsetWidth || element.offsetHeight || element.getClientRects().length\n    );\n}\n\nconst selInput = 'input,select,textarea,button';\nfunction isInput(element) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element).some((element) => matches(element, selInput));\n}\n\nconst selFocusable = `${selInput},a[href],[tabindex]`;\nfunction isFocusable(element) {\n    return matches(element, selFocusable);\n}\n\nfunction parent(element) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(element)?.parentElement;\n}\n\nfunction filter(element, selector) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element).filter((element) => matches(element, selector));\n}\n\nfunction matches(element, selector) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element).some((element) => element.matches(selector));\n}\n\nfunction closest(element, selector) {\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.startsWith)(selector, '>')) {\n        selector = selector.slice(1);\n    }\n\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isElement)(element)\n        ? element.closest(selector)\n        : (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element)\n              .map((element) => closest(element, selector))\n              .filter(Boolean);\n}\n\nfunction within(element, selector) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isString)(selector)\n        ? matches(element, selector) || !!closest(element, selector)\n        : element === selector || (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(selector).contains((0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(element));\n}\n\nfunction parents(element, selector) {\n    const elements = [];\n\n    while ((element = parent(element))) {\n        if (!selector || matches(element, selector)) {\n            elements.push(element);\n        }\n    }\n\n    return elements;\n}\n\nfunction children(element, selector) {\n    element = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(element);\n    const children = element ? (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element.children) : [];\n    return selector ? filter(children, selector) : children;\n}\n\nfunction index(element, ref) {\n    return ref ? (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element).indexOf((0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(ref)) : children(parent(element)).indexOf(element);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvZmlsdGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLDhDQUFPO0FBQ2xCOztBQUVPO0FBQ1AsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRU87QUFDQTtBQUNQLFdBQVcsOENBQU87QUFDbEI7O0FBRU8sd0JBQXdCLFNBQVM7QUFDakM7QUFDUDtBQUNBOztBQUVPO0FBQ1AsV0FBVyw2Q0FBTTtBQUNqQjs7QUFFTztBQUNQLFdBQVcsOENBQU87QUFDbEI7O0FBRU87QUFDUCxXQUFXLDhDQUFPO0FBQ2xCOztBQUVPO0FBQ1AsUUFBUSxpREFBVTtBQUNsQjtBQUNBOztBQUVBLFdBQVcsZ0RBQVM7QUFDcEI7QUFDQSxVQUFVLDhDQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFdBQVcsK0NBQVE7QUFDbkI7QUFDQSxrQ0FBa0MsNkNBQU0sb0JBQW9CLDZDQUFNO0FBQ2xFOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1AsY0FBYyw2Q0FBTTtBQUNwQiwrQkFBK0IsOENBQU87QUFDdEM7QUFDQTs7QUFFTztBQUNQLGlCQUFpQiw4Q0FBTyxrQkFBa0IsNkNBQU07QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvZmlsdGVyLmpzPzFjMDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNFbGVtZW50LCBpc1N0cmluZywgc3RhcnRzV2l0aCwgdG9Ob2RlLCB0b05vZGVzIH0gZnJvbSAnLi9sYW5nJztcblxuY29uc3Qgdm9pZEVsZW1lbnRzID0ge1xuICAgIGFyZWE6IHRydWUsXG4gICAgYmFzZTogdHJ1ZSxcbiAgICBicjogdHJ1ZSxcbiAgICBjb2w6IHRydWUsXG4gICAgZW1iZWQ6IHRydWUsXG4gICAgaHI6IHRydWUsXG4gICAgaW1nOiB0cnVlLFxuICAgIGlucHV0OiB0cnVlLFxuICAgIGtleWdlbjogdHJ1ZSxcbiAgICBsaW5rOiB0cnVlLFxuICAgIG1lbnVpdGVtOiB0cnVlLFxuICAgIG1ldGE6IHRydWUsXG4gICAgcGFyYW06IHRydWUsXG4gICAgc291cmNlOiB0cnVlLFxuICAgIHRyYWNrOiB0cnVlLFxuICAgIHdicjogdHJ1ZSxcbn07XG5leHBvcnQgZnVuY3Rpb24gaXNWb2lkRWxlbWVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZSgoZWxlbWVudCkgPT4gdm9pZEVsZW1lbnRzW2VsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Zpc2libGUoZWxlbWVudCkge1xuICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoXG4gICAgICAgIChlbGVtZW50KSA9PiBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGhcbiAgICApO1xufVxuXG5leHBvcnQgY29uc3Qgc2VsSW5wdXQgPSAnaW5wdXQsc2VsZWN0LHRleHRhcmVhLGJ1dHRvbic7XG5leHBvcnQgZnVuY3Rpb24gaXNJbnB1dChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZSgoZWxlbWVudCkgPT4gbWF0Y2hlcyhlbGVtZW50LCBzZWxJbnB1dCkpO1xufVxuXG5leHBvcnQgY29uc3Qgc2VsRm9jdXNhYmxlID0gYCR7c2VsSW5wdXR9LGFbaHJlZl0sW3RhYmluZGV4XWA7XG5leHBvcnQgZnVuY3Rpb24gaXNGb2N1c2FibGUoZWxlbWVudCkge1xuICAgIHJldHVybiBtYXRjaGVzKGVsZW1lbnQsIHNlbEZvY3VzYWJsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJlbnQoZWxlbWVudCkge1xuICAgIHJldHVybiB0b05vZGUoZWxlbWVudCk/LnBhcmVudEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXIoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5maWx0ZXIoKGVsZW1lbnQpID0+IG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKChlbGVtZW50KSA9PiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoc3RhcnRzV2l0aChzZWxlY3RvciwgJz4nKSkge1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHJldHVybiBpc0VsZW1lbnQoZWxlbWVudClcbiAgICAgICAgPyBlbGVtZW50LmNsb3Nlc3Qoc2VsZWN0b3IpXG4gICAgICAgIDogdG9Ob2RlcyhlbGVtZW50KVxuICAgICAgICAgICAgICAubWFwKChlbGVtZW50KSA9PiBjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yKSlcbiAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBpc1N0cmluZyhzZWxlY3RvcilcbiAgICAgICAgPyBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB8fCAhIWNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpXG4gICAgICAgIDogZWxlbWVudCA9PT0gc2VsZWN0b3IgfHwgdG9Ob2RlKHNlbGVjdG9yKS5jb250YWlucyh0b05vZGUoZWxlbWVudCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyZW50cyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICB3aGlsZSAoKGVsZW1lbnQgPSBwYXJlbnQoZWxlbWVudCkpKSB7XG4gICAgICAgIGlmICghc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGVsZW1lbnQgPSB0b05vZGUoZWxlbWVudCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBlbGVtZW50ID8gdG9Ob2RlcyhlbGVtZW50LmNoaWxkcmVuKSA6IFtdO1xuICAgIHJldHVybiBzZWxlY3RvciA/IGZpbHRlcihjaGlsZHJlbiwgc2VsZWN0b3IpIDogY2hpbGRyZW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmRleChlbGVtZW50LCByZWYpIHtcbiAgICByZXR1cm4gcmVmID8gdG9Ob2RlcyhlbGVtZW50KS5pbmRleE9mKHRvTm9kZShyZWYpKSA6IGNoaWxkcmVuKHBhcmVudChlbGVtZW50KSkuaW5kZXhPZihlbGVtZW50KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/filter.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/index.js":
/*!*************************************************!*\
  !*** ./node_modules/uikit/src/js/util/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.$),\n/* harmony export */   \"$$\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.$$),\n/* harmony export */   \"Animation\": () => (/* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_1__.Animation),\n/* harmony export */   \"Deferred\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.Deferred),\n/* harmony export */   \"Dimensions\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.Dimensions),\n/* harmony export */   \"MouseTracker\": () => (/* reexport safe */ _mouse__WEBPACK_IMPORTED_MODULE_11__.MouseTracker),\n/* harmony export */   \"Transition\": () => (/* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_1__.Transition),\n/* harmony export */   \"addClass\": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.addClass),\n/* harmony export */   \"after\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.after),\n/* harmony export */   \"ajax\": () => (/* reexport safe */ _ajax__WEBPACK_IMPORTED_MODULE_0__.ajax),\n/* harmony export */   \"animate\": () => (/* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_1__.animate),\n/* harmony export */   \"append\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.append),\n/* harmony export */   \"apply\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.apply),\n/* harmony export */   \"assign\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.assign),\n/* harmony export */   \"attr\": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_2__.attr),\n/* harmony export */   \"before\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.before),\n/* harmony export */   \"boxModelAdjust\": () => (/* reexport safe */ _dimensions__WEBPACK_IMPORTED_MODULE_4__.boxModelAdjust),\n/* harmony export */   \"camelize\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.camelize),\n/* harmony export */   \"children\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.children),\n/* harmony export */   \"clamp\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.clamp),\n/* harmony export */   \"closest\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.closest),\n/* harmony export */   \"createEvent\": () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_7__.createEvent),\n/* harmony export */   \"css\": () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_17__.css),\n/* harmony export */   \"data\": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_2__.data),\n/* harmony export */   \"dimensions\": () => (/* reexport safe */ _dimensions__WEBPACK_IMPORTED_MODULE_4__.dimensions),\n/* harmony export */   \"each\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.each),\n/* harmony export */   \"empty\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.empty),\n/* harmony export */   \"endsWith\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.endsWith),\n/* harmony export */   \"escape\": () => (/* reexport safe */ _selector__WEBPACK_IMPORTED_MODULE_16__.escape),\n/* harmony export */   \"fastdom\": () => (/* reexport safe */ _fastdom__WEBPACK_IMPORTED_MODULE_8__.fastdom),\n/* harmony export */   \"filter\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.filter),\n/* harmony export */   \"find\": () => (/* reexport safe */ _selector__WEBPACK_IMPORTED_MODULE_16__.find),\n/* harmony export */   \"findAll\": () => (/* reexport safe */ _selector__WEBPACK_IMPORTED_MODULE_16__.findAll),\n/* harmony export */   \"findIndex\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.findIndex),\n/* harmony export */   \"flipPosition\": () => (/* reexport safe */ _dimensions__WEBPACK_IMPORTED_MODULE_4__.flipPosition),\n/* harmony export */   \"fragment\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.fragment),\n/* harmony export */   \"getCssVar\": () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_17__.getCssVar),\n/* harmony export */   \"getEventPos\": () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_7__.getEventPos),\n/* harmony export */   \"getImage\": () => (/* reexport safe */ _ajax__WEBPACK_IMPORTED_MODULE_0__.getImage),\n/* harmony export */   \"getIndex\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.getIndex),\n/* harmony export */   \"hasAttr\": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_2__.hasAttr),\n/* harmony export */   \"hasClass\": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.hasClass),\n/* harmony export */   \"hasOwn\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.hasOwn),\n/* harmony export */   \"hasTouch\": () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_6__.hasTouch),\n/* harmony export */   \"height\": () => (/* reexport safe */ _dimensions__WEBPACK_IMPORTED_MODULE_4__.height),\n/* harmony export */   \"html\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.html),\n/* harmony export */   \"hyphenate\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.hyphenate),\n/* harmony export */   \"inBrowser\": () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_6__.inBrowser),\n/* harmony export */   \"includes\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.includes),\n/* harmony export */   \"index\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.index),\n/* harmony export */   \"intersectRect\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.intersectRect),\n/* harmony export */   \"isArray\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isArray),\n/* harmony export */   \"isBoolean\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isBoolean),\n/* harmony export */   \"isDocument\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isDocument),\n/* harmony export */   \"isElement\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isElement),\n/* harmony export */   \"isEmpty\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isEmpty),\n/* harmony export */   \"isEqual\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isEqual),\n/* harmony export */   \"isFocusable\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.isFocusable),\n/* harmony export */   \"isFunction\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isFunction),\n/* harmony export */   \"isInView\": () => (/* reexport safe */ _viewport__WEBPACK_IMPORTED_MODULE_18__.isInView),\n/* harmony export */   \"isInput\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.isInput),\n/* harmony export */   \"isNode\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isNode),\n/* harmony export */   \"isNumber\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isNumber),\n/* harmony export */   \"isNumeric\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isNumeric),\n/* harmony export */   \"isObject\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isObject),\n/* harmony export */   \"isPlainObject\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isPlainObject),\n/* harmony export */   \"isRtl\": () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_6__.isRtl),\n/* harmony export */   \"isString\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isString),\n/* harmony export */   \"isTag\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.isTag),\n/* harmony export */   \"isTouch\": () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_7__.isTouch),\n/* harmony export */   \"isUndefined\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isUndefined),\n/* harmony export */   \"isVideo\": () => (/* reexport safe */ _player__WEBPACK_IMPORTED_MODULE_14__.isVideo),\n/* harmony export */   \"isVisible\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.isVisible),\n/* harmony export */   \"isVoidElement\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.isVoidElement),\n/* harmony export */   \"isWindow\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.isWindow),\n/* harmony export */   \"last\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.last),\n/* harmony export */   \"matches\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.matches),\n/* harmony export */   \"memoize\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.memoize),\n/* harmony export */   \"mergeOptions\": () => (/* reexport safe */ _options__WEBPACK_IMPORTED_MODULE_13__.mergeOptions),\n/* harmony export */   \"mute\": () => (/* reexport safe */ _player__WEBPACK_IMPORTED_MODULE_14__.mute),\n/* harmony export */   \"noop\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.noop),\n/* harmony export */   \"observeIntersection\": () => (/* reexport safe */ _observer__WEBPACK_IMPORTED_MODULE_12__.observeIntersection),\n/* harmony export */   \"observeMutation\": () => (/* reexport safe */ _observer__WEBPACK_IMPORTED_MODULE_12__.observeMutation),\n/* harmony export */   \"observeResize\": () => (/* reexport safe */ _observer__WEBPACK_IMPORTED_MODULE_12__.observeResize),\n/* harmony export */   \"off\": () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_7__.off),\n/* harmony export */   \"offset\": () => (/* reexport safe */ _dimensions__WEBPACK_IMPORTED_MODULE_4__.offset),\n/* harmony export */   \"offsetPosition\": () => (/* reexport safe */ _dimensions__WEBPACK_IMPORTED_MODULE_4__.offsetPosition),\n/* harmony export */   \"offsetViewport\": () => (/* reexport safe */ _viewport__WEBPACK_IMPORTED_MODULE_18__.offsetViewport),\n/* harmony export */   \"on\": () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_7__.on),\n/* harmony export */   \"once\": () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_7__.once),\n/* harmony export */   \"parent\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.parent),\n/* harmony export */   \"parents\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.parents),\n/* harmony export */   \"parseOptions\": () => (/* reexport safe */ _options__WEBPACK_IMPORTED_MODULE_13__.parseOptions),\n/* harmony export */   \"pause\": () => (/* reexport safe */ _player__WEBPACK_IMPORTED_MODULE_14__.pause),\n/* harmony export */   \"play\": () => (/* reexport safe */ _player__WEBPACK_IMPORTED_MODULE_14__.play),\n/* harmony export */   \"pointInRect\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.pointInRect),\n/* harmony export */   \"pointerCancel\": () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_6__.pointerCancel),\n/* harmony export */   \"pointerDown\": () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_6__.pointerDown),\n/* harmony export */   \"pointerEnter\": () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_6__.pointerEnter),\n/* harmony export */   \"pointerLeave\": () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_6__.pointerLeave),\n/* harmony export */   \"pointerMove\": () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_6__.pointerMove),\n/* harmony export */   \"pointerUp\": () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_6__.pointerUp),\n/* harmony export */   \"position\": () => (/* reexport safe */ _dimensions__WEBPACK_IMPORTED_MODULE_4__.position),\n/* harmony export */   \"positionAt\": () => (/* reexport safe */ _position__WEBPACK_IMPORTED_MODULE_15__.positionAt),\n/* harmony export */   \"prepend\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.prepend),\n/* harmony export */   \"propName\": () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_17__.propName),\n/* harmony export */   \"query\": () => (/* reexport safe */ _selector__WEBPACK_IMPORTED_MODULE_16__.query),\n/* harmony export */   \"queryAll\": () => (/* reexport safe */ _selector__WEBPACK_IMPORTED_MODULE_16__.queryAll),\n/* harmony export */   \"ready\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.ready),\n/* harmony export */   \"remove\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.remove),\n/* harmony export */   \"removeAttr\": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_2__.removeAttr),\n/* harmony export */   \"removeClass\": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.removeClass),\n/* harmony export */   \"removeClasses\": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.removeClasses),\n/* harmony export */   \"replaceChildren\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.replaceChildren),\n/* harmony export */   \"replaceClass\": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.replaceClass),\n/* harmony export */   \"scrollIntoView\": () => (/* reexport safe */ _viewport__WEBPACK_IMPORTED_MODULE_18__.scrollIntoView),\n/* harmony export */   \"scrollParents\": () => (/* reexport safe */ _viewport__WEBPACK_IMPORTED_MODULE_18__.scrollParents),\n/* harmony export */   \"scrollTop\": () => (/* reexport safe */ _viewport__WEBPACK_IMPORTED_MODULE_18__.scrollTop),\n/* harmony export */   \"scrolledOver\": () => (/* reexport safe */ _viewport__WEBPACK_IMPORTED_MODULE_18__.scrolledOver),\n/* harmony export */   \"selFocusable\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.selFocusable),\n/* harmony export */   \"selInput\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.selInput),\n/* harmony export */   \"sortBy\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.sortBy),\n/* harmony export */   \"startsWith\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.startsWith),\n/* harmony export */   \"swap\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.swap),\n/* harmony export */   \"toArray\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.toArray),\n/* harmony export */   \"toBoolean\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.toBoolean),\n/* harmony export */   \"toEventTargets\": () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_7__.toEventTargets),\n/* harmony export */   \"toFloat\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.toFloat),\n/* harmony export */   \"toNode\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.toNode),\n/* harmony export */   \"toNodes\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.toNodes),\n/* harmony export */   \"toNumber\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.toNumber),\n/* harmony export */   \"toPx\": () => (/* reexport safe */ _dimensions__WEBPACK_IMPORTED_MODULE_4__.toPx),\n/* harmony export */   \"toWindow\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.toWindow),\n/* harmony export */   \"toggleClass\": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.toggleClass),\n/* harmony export */   \"transition\": () => (/* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_1__.transition),\n/* harmony export */   \"trigger\": () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_7__.trigger),\n/* harmony export */   \"ucfirst\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.ucfirst),\n/* harmony export */   \"uniqueBy\": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_10__.uniqueBy),\n/* harmony export */   \"unwrap\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.unwrap),\n/* harmony export */   \"width\": () => (/* reexport safe */ _dimensions__WEBPACK_IMPORTED_MODULE_4__.width),\n/* harmony export */   \"within\": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_9__.within),\n/* harmony export */   \"wrapAll\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.wrapAll),\n/* harmony export */   \"wrapInner\": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_5__.wrapInner)\n/* harmony export */ });\n/* harmony import */ var _ajax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ajax */ \"./node_modules/uikit/src/js/util/ajax.js\");\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./animation */ \"./node_modules/uikit/src/js/util/animation.js\");\n/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attr */ \"./node_modules/uikit/src/js/util/attr.js\");\n/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./class */ \"./node_modules/uikit/src/js/util/class.js\");\n/* harmony import */ var _dimensions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dimensions */ \"./node_modules/uikit/src/js/util/dimensions.js\");\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom */ \"./node_modules/uikit/src/js/util/dom.js\");\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./env */ \"./node_modules/uikit/src/js/util/env.js\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./event */ \"./node_modules/uikit/src/js/util/event.js\");\n/* harmony import */ var _fastdom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fastdom */ \"./node_modules/uikit/src/js/util/fastdom.js\");\n/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./filter */ \"./node_modules/uikit/src/js/util/filter.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./mouse */ \"./node_modules/uikit/src/js/util/mouse.js\");\n/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./observer */ \"./node_modules/uikit/src/js/util/observer.js\");\n/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./options */ \"./node_modules/uikit/src/js/util/options.js\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./player */ \"./node_modules/uikit/src/js/util/player.js\");\n/* harmony import */ var _position__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./position */ \"./node_modules/uikit/src/js/util/position.js\");\n/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./selector */ \"./node_modules/uikit/src/js/util/selector.js\");\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./style */ \"./node_modules/uikit/src/js/util/style.js\");\n/* harmony import */ var _viewport__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./viewport */ \"./node_modules/uikit/src/js/util/viewport.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVCO0FBQ0s7QUFDTDtBQUNDO0FBQ0s7QUFDUDtBQUNBO0FBQ0U7QUFDRTtBQUNEO0FBQ0Y7QUFDQztBQUNHO0FBQ0Q7QUFDRDtBQUNFO0FBQ0E7QUFDSDtBQUNHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Vpa2l0L3NyYy9qcy91dGlsL2luZGV4LmpzPzc0MDciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9hamF4JztcbmV4cG9ydCAqIGZyb20gJy4vYW5pbWF0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vYXR0cic7XG5leHBvcnQgKiBmcm9tICcuL2NsYXNzJztcbmV4cG9ydCAqIGZyb20gJy4vZGltZW5zaW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2RvbSc7XG5leHBvcnQgKiBmcm9tICcuL2Vudic7XG5leHBvcnQgKiBmcm9tICcuL2V2ZW50JztcbmV4cG9ydCAqIGZyb20gJy4vZmFzdGRvbSc7XG5leHBvcnQgKiBmcm9tICcuL2ZpbHRlcic7XG5leHBvcnQgKiBmcm9tICcuL2xhbmcnO1xuZXhwb3J0ICogZnJvbSAnLi9tb3VzZSc7XG5leHBvcnQgKiBmcm9tICcuL29ic2VydmVyJztcbmV4cG9ydCAqIGZyb20gJy4vb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3BsYXllcic7XG5leHBvcnQgKiBmcm9tICcuL3Bvc2l0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vc2VsZWN0b3InO1xuZXhwb3J0ICogZnJvbSAnLi9zdHlsZSc7XG5leHBvcnQgKiBmcm9tICcuL3ZpZXdwb3J0JztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/index.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/lang.js":
/*!************************************************!*\
  !*** ./node_modules/uikit/src/js/util/lang.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred),\n/* harmony export */   \"Dimensions\": () => (/* binding */ Dimensions),\n/* harmony export */   \"assign\": () => (/* binding */ assign),\n/* harmony export */   \"camelize\": () => (/* binding */ camelize),\n/* harmony export */   \"clamp\": () => (/* binding */ clamp),\n/* harmony export */   \"each\": () => (/* binding */ each),\n/* harmony export */   \"endsWith\": () => (/* binding */ endsWith),\n/* harmony export */   \"findIndex\": () => (/* binding */ findIndex),\n/* harmony export */   \"getIndex\": () => (/* binding */ getIndex),\n/* harmony export */   \"hasOwn\": () => (/* binding */ hasOwn),\n/* harmony export */   \"hyphenate\": () => (/* binding */ hyphenate),\n/* harmony export */   \"includes\": () => (/* binding */ includes),\n/* harmony export */   \"intersectRect\": () => (/* binding */ intersectRect),\n/* harmony export */   \"isArray\": () => (/* binding */ isArray),\n/* harmony export */   \"isBoolean\": () => (/* binding */ isBoolean),\n/* harmony export */   \"isDocument\": () => (/* binding */ isDocument),\n/* harmony export */   \"isElement\": () => (/* binding */ isElement),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"isEqual\": () => (/* binding */ isEqual),\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction),\n/* harmony export */   \"isNode\": () => (/* binding */ isNode),\n/* harmony export */   \"isNumber\": () => (/* binding */ isNumber),\n/* harmony export */   \"isNumeric\": () => (/* binding */ isNumeric),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"isPlainObject\": () => (/* binding */ isPlainObject),\n/* harmony export */   \"isString\": () => (/* binding */ isString),\n/* harmony export */   \"isUndefined\": () => (/* binding */ isUndefined),\n/* harmony export */   \"isWindow\": () => (/* binding */ isWindow),\n/* harmony export */   \"last\": () => (/* binding */ last),\n/* harmony export */   \"memoize\": () => (/* binding */ memoize),\n/* harmony export */   \"noop\": () => (/* binding */ noop),\n/* harmony export */   \"pointInRect\": () => (/* binding */ pointInRect),\n/* harmony export */   \"sortBy\": () => (/* binding */ sortBy),\n/* harmony export */   \"startsWith\": () => (/* binding */ startsWith),\n/* harmony export */   \"swap\": () => (/* binding */ swap),\n/* harmony export */   \"toArray\": () => (/* binding */ toArray),\n/* harmony export */   \"toBoolean\": () => (/* binding */ toBoolean),\n/* harmony export */   \"toFloat\": () => (/* binding */ toFloat),\n/* harmony export */   \"toNode\": () => (/* binding */ toNode),\n/* harmony export */   \"toNodes\": () => (/* binding */ toNodes),\n/* harmony export */   \"toNumber\": () => (/* binding */ toNumber),\n/* harmony export */   \"toWindow\": () => (/* binding */ toWindow),\n/* harmony export */   \"ucfirst\": () => (/* binding */ ucfirst),\n/* harmony export */   \"uniqueBy\": () => (/* binding */ uniqueBy)\n/* harmony export */ });\nconst { hasOwnProperty, toString } = Object.prototype;\n\nfunction hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n}\n\nconst hyphenateRe = /\\B([A-Z])/g;\n\nconst hyphenate = memoize((str) => str.replace(hyphenateRe, '-$1').toLowerCase());\n\nconst camelizeRe = /-(\\w)/g;\n\nconst camelize = memoize((str) => str.replace(camelizeRe, toUpper));\n\nconst ucfirst = memoize((str) =>\n    str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : ''\n);\n\nfunction toUpper(_, c) {\n    return c ? c.toUpperCase() : '';\n}\n\nfunction startsWith(str, search) {\n    return str?.startsWith?.(search);\n}\n\nfunction endsWith(str, search) {\n    return str?.endsWith?.(search);\n}\n\nfunction includes(obj, search) {\n    return obj?.includes?.(search);\n}\n\nfunction findIndex(array, predicate) {\n    return array?.findIndex?.(predicate);\n}\n\nconst { isArray, from: toArray } = Array;\nconst { assign } = Object;\n\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\n\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n\nfunction isPlainObject(obj) {\n    return toString.call(obj) === '[object Object]';\n}\n\nfunction isWindow(obj) {\n    return isObject(obj) && obj === obj.window;\n}\n\nfunction isDocument(obj) {\n    return nodeType(obj) === 9;\n}\n\nfunction isNode(obj) {\n    return nodeType(obj) >= 1;\n}\n\nfunction isElement(obj) {\n    return nodeType(obj) === 1;\n}\n\nfunction nodeType(obj) {\n    return !isWindow(obj) && isObject(obj) && obj.nodeType;\n}\n\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\n\nfunction isString(value) {\n    return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\n\nfunction isNumeric(value) {\n    return isNumber(value) || (isString(value) && !isNaN(value - parseFloat(value)));\n}\n\nfunction isEmpty(obj) {\n    return !(isArray(obj) ? obj.length : isObject(obj) ? Object.keys(obj).length : false);\n}\n\nfunction isUndefined(value) {\n    return value === void 0;\n}\n\nfunction toBoolean(value) {\n    return isBoolean(value)\n        ? value\n        : value === 'true' || value === '1' || value === ''\n        ? true\n        : value === 'false' || value === '0'\n        ? false\n        : value;\n}\n\nfunction toNumber(value) {\n    const number = Number(value);\n    return isNaN(number) ? false : number;\n}\n\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\nfunction toNode(element) {\n    return toNodes(element)[0];\n}\n\nfunction toNodes(element) {\n    return (element && (isNode(element) ? [element] : Array.from(element).filter(isNode))) || [];\n}\n\nfunction toWindow(element) {\n    if (isWindow(element)) {\n        return element;\n    }\n\n    element = toNode(element);\n    const document = isDocument(element) ? element : element?.ownerDocument;\n\n    return document?.defaultView || window;\n}\n\nfunction isEqual(value, other) {\n    return (\n        value === other ||\n        (isObject(value) &&\n            isObject(other) &&\n            Object.keys(value).length === Object.keys(other).length &&\n            each(value, (val, key) => val === other[key]))\n    );\n}\n\nfunction swap(value, a, b) {\n    return value.replace(new RegExp(`${a}|${b}`, 'g'), (match) => (match === a ? b : a));\n}\n\nfunction last(array) {\n    return array[array.length - 1];\n}\n\nfunction each(obj, cb) {\n    for (const key in obj) {\n        if (false === cb(obj[key], key)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction sortBy(array, prop) {\n    return array\n        .slice()\n        .sort(({ [prop]: propA = 0 }, { [prop]: propB = 0 }) =>\n            propA > propB ? 1 : propB > propA ? -1 : 0\n        );\n}\n\nfunction uniqueBy(array, prop) {\n    const seen = new Set();\n    return array.filter(({ [prop]: check }) => (seen.has(check) ? false : seen.add(check)));\n}\n\nfunction clamp(number, min = 0, max = 1) {\n    return Math.min(Math.max(toNumber(number) || 0, min), max);\n}\n\nfunction noop() {}\n\nfunction intersectRect(...rects) {\n    return [\n        ['bottom', 'top'],\n        ['right', 'left'],\n    ].every(\n        ([minProp, maxProp]) =>\n            Math.min(...rects.map(({ [minProp]: min }) => min)) -\n                Math.max(...rects.map(({ [maxProp]: max }) => max)) >\n            0\n    );\n}\n\nfunction pointInRect(point, rect) {\n    return (\n        point.x <= rect.right &&\n        point.x >= rect.left &&\n        point.y <= rect.bottom &&\n        point.y >= rect.top\n    );\n}\n\nfunction ratio(dimensions, prop, value) {\n    const aProp = prop === 'width' ? 'height' : 'width';\n\n    return {\n        [aProp]: dimensions[prop]\n            ? Math.round((value * dimensions[aProp]) / dimensions[prop])\n            : dimensions[aProp],\n        [prop]: value,\n    };\n}\n\nfunction contain(dimensions, maxDimensions) {\n    dimensions = { ...dimensions };\n\n    for (const prop in dimensions) {\n        dimensions =\n            dimensions[prop] > maxDimensions[prop]\n                ? ratio(dimensions, prop, maxDimensions[prop])\n                : dimensions;\n    }\n\n    return dimensions;\n}\n\nfunction cover(dimensions, maxDimensions) {\n    dimensions = contain(dimensions, maxDimensions);\n\n    for (const prop in dimensions) {\n        dimensions =\n            dimensions[prop] < maxDimensions[prop]\n                ? ratio(dimensions, prop, maxDimensions[prop])\n                : dimensions;\n    }\n\n    return dimensions;\n}\n\nconst Dimensions = { ratio, contain, cover };\n\nfunction getIndex(i, elements, current = 0, finite = false) {\n    elements = toNodes(elements);\n\n    const { length } = elements;\n\n    if (!length) {\n        return -1;\n    }\n\n    i = isNumeric(i)\n        ? toNumber(i)\n        : i === 'next'\n        ? current + 1\n        : i === 'previous'\n        ? current - 1\n        : elements.indexOf(toNode(i));\n\n    if (finite) {\n        return clamp(i, 0, length - 1);\n    }\n\n    i %= length;\n\n    return i < 0 ? i + length : i;\n}\n\nfunction memoize(fn) {\n    const cache = Object.create(null);\n    return (key) => cache[key] || (cache[key] = fn(key));\n}\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvbGFuZy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFFBQVEsMkJBQTJCOztBQUU1QjtBQUNQO0FBQ0E7O0FBRUE7O0FBRU87O0FBRVA7O0FBRU87O0FBRUE7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU8sUUFBUSx5QkFBeUI7QUFDakMsUUFBUSxTQUFTOztBQUVqQjtBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsdUNBQXVDLEVBQUUsR0FBRyxFQUFFO0FBQzlDOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsSUFBSSxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQzs7QUFFTztBQUNQO0FBQ0E7O0FBRU87O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRCx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU8scUJBQXFCOztBQUVyQjtBQUNQOztBQUVBLFlBQVksU0FBUzs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91aWtpdC9zcmMvanMvdXRpbC9sYW5nLmpzPzZlODIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSwgdG9TdHJpbmcgfSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbmNvbnN0IGh5cGhlbmF0ZVJlID0gL1xcQihbQS1aXSkvZztcblxuZXhwb3J0IGNvbnN0IGh5cGhlbmF0ZSA9IG1lbW9pemUoKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUmUsICctJDEnKS50b0xvd2VyQ2FzZSgpKTtcblxuY29uc3QgY2FtZWxpemVSZSA9IC8tKFxcdykvZztcblxuZXhwb3J0IGNvbnN0IGNhbWVsaXplID0gbWVtb2l6ZSgoc3RyKSA9PiBzdHIucmVwbGFjZShjYW1lbGl6ZVJlLCB0b1VwcGVyKSk7XG5cbmV4cG9ydCBjb25zdCB1Y2ZpcnN0ID0gbWVtb2l6ZSgoc3RyKSA9PlxuICAgIHN0ci5sZW5ndGggPyB0b1VwcGVyKG51bGwsIHN0ci5jaGFyQXQoMCkpICsgc3RyLnNsaWNlKDEpIDogJydcbik7XG5cbmZ1bmN0aW9uIHRvVXBwZXIoXywgYykge1xuICAgIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoKSB7XG4gICAgcmV0dXJuIHN0cj8uc3RhcnRzV2l0aD8uKHNlYXJjaCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCkge1xuICAgIHJldHVybiBzdHI/LmVuZHNXaXRoPy4oc2VhcmNoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluY2x1ZGVzKG9iaiwgc2VhcmNoKSB7XG4gICAgcmV0dXJuIG9iaj8uaW5jbHVkZXM/LihzZWFyY2gpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gYXJyYXk/LmZpbmRJbmRleD8uKHByZWRpY2F0ZSk7XG59XG5cbmV4cG9ydCBjb25zdCB7IGlzQXJyYXksIGZyb206IHRvQXJyYXkgfSA9IEFycmF5O1xuZXhwb3J0IGNvbnN0IHsgYXNzaWduIH0gPSBPYmplY3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqKSAmJiBvYmogPT09IG9iai53aW5kb3c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RvY3VtZW50KG9iaikge1xuICAgIHJldHVybiBub2RlVHlwZShvYmopID09PSA5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlKG9iaikge1xuICAgIHJldHVybiBub2RlVHlwZShvYmopID49IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuIG5vZGVUeXBlKG9iaikgPT09IDE7XG59XG5cbmZ1bmN0aW9uIG5vZGVUeXBlKG9iaikge1xuICAgIHJldHVybiAhaXNXaW5kb3cob2JqKSAmJiBpc09iamVjdChvYmopICYmIG9iai5ub2RlVHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1lcmljKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSB8fCAoaXNTdHJpbmcodmFsdWUpICYmICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIHJldHVybiAhKGlzQXJyYXkob2JqKSA/IG9iai5sZW5ndGggOiBpc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggOiBmYWxzZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9Cb29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQm9vbGVhbih2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICcxJyB8fCB2YWx1ZSA9PT0gJydcbiAgICAgICAgPyB0cnVlXG4gICAgICAgIDogdmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICcwJ1xuICAgICAgICA/IGZhbHNlXG4gICAgICAgIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIGNvbnN0IG51bWJlciA9IE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIGlzTmFOKG51bWJlcikgPyBmYWxzZSA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvTm9kZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudClbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b05vZGVzKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gKGVsZW1lbnQgJiYgKGlzTm9kZShlbGVtZW50KSA/IFtlbGVtZW50XSA6IEFycmF5LmZyb20oZWxlbWVudCkuZmlsdGVyKGlzTm9kZSkpKSB8fCBbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvV2luZG93KGVsZW1lbnQpIHtcbiAgICBpZiAoaXNXaW5kb3coZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcbiAgICBjb25zdCBkb2N1bWVudCA9IGlzRG9jdW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudD8ub3duZXJEb2N1bWVudDtcblxuICAgIHJldHVybiBkb2N1bWVudD8uZGVmYXVsdFZpZXcgfHwgd2luZG93O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB2YWx1ZSA9PT0gb3RoZXIgfHxcbiAgICAgICAgKGlzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICAgICAgaXNPYmplY3Qob3RoZXIpICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhvdGhlcikubGVuZ3RoICYmXG4gICAgICAgICAgICBlYWNoKHZhbHVlLCAodmFsLCBrZXkpID0+IHZhbCA9PT0gb3RoZXJba2V5XSkpXG4gICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN3YXAodmFsdWUsIGEsIGIpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKGAke2F9fCR7Yn1gLCAnZycpLCAobWF0Y2gpID0+IChtYXRjaCA9PT0gYSA/IGIgOiBhKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWFjaChvYmosIGNiKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gY2Iob2JqW2tleV0sIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRCeShhcnJheSwgcHJvcCkge1xuICAgIHJldHVybiBhcnJheVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAuc29ydCgoeyBbcHJvcF06IHByb3BBID0gMCB9LCB7IFtwcm9wXTogcHJvcEIgPSAwIH0pID0+XG4gICAgICAgICAgICBwcm9wQSA+IHByb3BCID8gMSA6IHByb3BCID4gcHJvcEEgPyAtMSA6IDBcbiAgICAgICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUJ5KGFycmF5LCBwcm9wKSB7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKCh7IFtwcm9wXTogY2hlY2sgfSkgPT4gKHNlZW4uaGFzKGNoZWNrKSA/IGZhbHNlIDogc2Vlbi5hZGQoY2hlY2spKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcChudW1iZXIsIG1pbiA9IDAsIG1heCA9IDEpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodG9OdW1iZXIobnVtYmVyKSB8fCAwLCBtaW4pLCBtYXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RSZWN0KC4uLnJlY3RzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgWydib3R0b20nLCAndG9wJ10sXG4gICAgICAgIFsncmlnaHQnLCAnbGVmdCddLFxuICAgIF0uZXZlcnkoXG4gICAgICAgIChbbWluUHJvcCwgbWF4UHJvcF0pID0+XG4gICAgICAgICAgICBNYXRoLm1pbiguLi5yZWN0cy5tYXAoKHsgW21pblByb3BdOiBtaW4gfSkgPT4gbWluKSkgLVxuICAgICAgICAgICAgICAgIE1hdGgubWF4KC4uLnJlY3RzLm1hcCgoeyBbbWF4UHJvcF06IG1heCB9KSA9PiBtYXgpKSA+XG4gICAgICAgICAgICAwXG4gICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50SW5SZWN0KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgcG9pbnQueCA8PSByZWN0LnJpZ2h0ICYmXG4gICAgICAgIHBvaW50LnggPj0gcmVjdC5sZWZ0ICYmXG4gICAgICAgIHBvaW50LnkgPD0gcmVjdC5ib3R0b20gJiZcbiAgICAgICAgcG9pbnQueSA+PSByZWN0LnRvcFxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHJhdGlvKGRpbWVuc2lvbnMsIHByb3AsIHZhbHVlKSB7XG4gICAgY29uc3QgYVByb3AgPSBwcm9wID09PSAnd2lkdGgnID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgW2FQcm9wXTogZGltZW5zaW9uc1twcm9wXVxuICAgICAgICAgICAgPyBNYXRoLnJvdW5kKCh2YWx1ZSAqIGRpbWVuc2lvbnNbYVByb3BdKSAvIGRpbWVuc2lvbnNbcHJvcF0pXG4gICAgICAgICAgICA6IGRpbWVuc2lvbnNbYVByb3BdLFxuICAgICAgICBbcHJvcF06IHZhbHVlLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW4oZGltZW5zaW9ucywgbWF4RGltZW5zaW9ucykge1xuICAgIGRpbWVuc2lvbnMgPSB7IC4uLmRpbWVuc2lvbnMgfTtcblxuICAgIGZvciAoY29uc3QgcHJvcCBpbiBkaW1lbnNpb25zKSB7XG4gICAgICAgIGRpbWVuc2lvbnMgPVxuICAgICAgICAgICAgZGltZW5zaW9uc1twcm9wXSA+IG1heERpbWVuc2lvbnNbcHJvcF1cbiAgICAgICAgICAgICAgICA/IHJhdGlvKGRpbWVuc2lvbnMsIHByb3AsIG1heERpbWVuc2lvbnNbcHJvcF0pXG4gICAgICAgICAgICAgICAgOiBkaW1lbnNpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBkaW1lbnNpb25zO1xufVxuXG5mdW5jdGlvbiBjb3ZlcihkaW1lbnNpb25zLCBtYXhEaW1lbnNpb25zKSB7XG4gICAgZGltZW5zaW9ucyA9IGNvbnRhaW4oZGltZW5zaW9ucywgbWF4RGltZW5zaW9ucyk7XG5cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBkaW1lbnNpb25zID1cbiAgICAgICAgICAgIGRpbWVuc2lvbnNbcHJvcF0gPCBtYXhEaW1lbnNpb25zW3Byb3BdXG4gICAgICAgICAgICAgICAgPyByYXRpbyhkaW1lbnNpb25zLCBwcm9wLCBtYXhEaW1lbnNpb25zW3Byb3BdKVxuICAgICAgICAgICAgICAgIDogZGltZW5zaW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4gZGltZW5zaW9ucztcbn1cblxuZXhwb3J0IGNvbnN0IERpbWVuc2lvbnMgPSB7IHJhdGlvLCBjb250YWluLCBjb3ZlciB9O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5kZXgoaSwgZWxlbWVudHMsIGN1cnJlbnQgPSAwLCBmaW5pdGUgPSBmYWxzZSkge1xuICAgIGVsZW1lbnRzID0gdG9Ob2RlcyhlbGVtZW50cyk7XG5cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gZWxlbWVudHM7XG5cbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaSA9IGlzTnVtZXJpYyhpKVxuICAgICAgICA/IHRvTnVtYmVyKGkpXG4gICAgICAgIDogaSA9PT0gJ25leHQnXG4gICAgICAgID8gY3VycmVudCArIDFcbiAgICAgICAgOiBpID09PSAncHJldmlvdXMnXG4gICAgICAgID8gY3VycmVudCAtIDFcbiAgICAgICAgOiBlbGVtZW50cy5pbmRleE9mKHRvTm9kZShpKSk7XG5cbiAgICBpZiAoZmluaXRlKSB7XG4gICAgICAgIHJldHVybiBjbGFtcChpLCAwLCBsZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBpICU9IGxlbmd0aDtcblxuICAgIHJldHVybiBpIDwgMCA/IGkgKyBsZW5ndGggOiBpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKGtleSkgPT4gY2FjaGVba2V5XSB8fCAoY2FjaGVba2V5XSA9IGZuKGtleSkpO1xufVxuXG5leHBvcnQgY2xhc3MgRGVmZXJyZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/lang.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/mouse.js":
/*!*************************************************!*\
  !*** ./node_modules/uikit/src/js/util/mouse.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MouseTracker\": () => (/* binding */ MouseTracker)\n/* harmony export */ });\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event */ \"./node_modules/uikit/src/js/util/event.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\n\nfunction MouseTracker() {}\n\nMouseTracker.prototype = {\n    positions: [],\n\n    init() {\n        this.positions = [];\n\n        let position;\n        this.unbind = (0,_event__WEBPACK_IMPORTED_MODULE_0__.on)(document, 'mousemove', (e) => (position = (0,_event__WEBPACK_IMPORTED_MODULE_0__.getEventPos)(e)));\n        this.interval = setInterval(() => {\n            if (!position) {\n                return;\n            }\n\n            this.positions.push(position);\n\n            if (this.positions.length > 5) {\n                this.positions.shift();\n            }\n        }, 50);\n    },\n\n    cancel() {\n        this.unbind?.();\n        this.interval && clearInterval(this.interval);\n    },\n\n    movesTo(target) {\n        if (this.positions.length < 2) {\n            return false;\n        }\n\n        const p = target.getBoundingClientRect();\n        const { left, right, top, bottom } = p;\n\n        const [prevPosition] = this.positions;\n        const position = (0,_lang__WEBPACK_IMPORTED_MODULE_1__.last)(this.positions);\n        const path = [prevPosition, position];\n\n        if ((0,_lang__WEBPACK_IMPORTED_MODULE_1__.pointInRect)(position, p)) {\n            return false;\n        }\n\n        const diagonals = [\n            [\n                { x: left, y: top },\n                { x: right, y: bottom },\n            ],\n            [\n                { x: left, y: bottom },\n                { x: right, y: top },\n            ],\n        ];\n\n        return diagonals.some((diagonal) => {\n            const intersection = intersect(path, diagonal);\n            return intersection && (0,_lang__WEBPACK_IMPORTED_MODULE_1__.pointInRect)(intersection, p);\n        });\n    },\n};\n\n// Inspired by http://paulbourke.net/geometry/pointlineplane/\nfunction intersect([{ x: x1, y: y1 }, { x: x2, y: y2 }], [{ x: x3, y: y3 }, { x: x4, y: y4 }]) {\n    const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n    // Lines are parallel\n    if (denominator === 0) {\n        return false;\n    }\n\n    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n\n    if (ua < 0) {\n        return false;\n    }\n\n    // Return an object with the x and y coordinates of the intersection\n    return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvbW91c2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBDO0FBQ0M7O0FBRXBDOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiwwQ0FBRSwyQ0FBMkMsbURBQVc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiwyQkFBMkI7O0FBRTNDO0FBQ0EseUJBQXlCLDJDQUFJO0FBQzdCOztBQUVBLFlBQVksa0RBQVc7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQyxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFXO0FBQzlDLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxzQkFBc0IsY0FBYyxJQUFJLGNBQWMsTUFBTSxjQUFjLElBQUksY0FBYztBQUM1Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvbW91c2UuanM/NmNiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRFdmVudFBvcywgb24gfSBmcm9tICcuL2V2ZW50JztcbmltcG9ydCB7IGxhc3QsIHBvaW50SW5SZWN0IH0gZnJvbSAnLi9sYW5nJztcblxuZXhwb3J0IGZ1bmN0aW9uIE1vdXNlVHJhY2tlcigpIHt9XG5cbk1vdXNlVHJhY2tlci5wcm90b3R5cGUgPSB7XG4gICAgcG9zaXRpb25zOiBbXSxcblxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gW107XG5cbiAgICAgICAgbGV0IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLnVuYmluZCA9IG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgKGUpID0+IChwb3NpdGlvbiA9IGdldEV2ZW50UG9zKGUpKSk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25zLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCA1MCk7XG4gICAgfSxcblxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy51bmJpbmQ/LigpO1xuICAgICAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgfSxcblxuICAgIG1vdmVzVG8odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gcDtcblxuICAgICAgICBjb25zdCBbcHJldlBvc2l0aW9uXSA9IHRoaXMucG9zaXRpb25zO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGxhc3QodGhpcy5wb3NpdGlvbnMpO1xuICAgICAgICBjb25zdCBwYXRoID0gW3ByZXZQb3NpdGlvbiwgcG9zaXRpb25dO1xuXG4gICAgICAgIGlmIChwb2ludEluUmVjdChwb3NpdGlvbiwgcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRpYWdvbmFscyA9IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB7IHg6IGxlZnQsIHk6IHRvcCB9LFxuICAgICAgICAgICAgICAgIHsgeDogcmlnaHQsIHk6IGJvdHRvbSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB7IHg6IGxlZnQsIHk6IGJvdHRvbSB9LFxuICAgICAgICAgICAgICAgIHsgeDogcmlnaHQsIHk6IHRvcCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgXTtcblxuICAgICAgICByZXR1cm4gZGlhZ29uYWxzLnNvbWUoKGRpYWdvbmFsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3QocGF0aCwgZGlhZ29uYWwpO1xuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbiAmJiBwb2ludEluUmVjdChpbnRlcnNlY3Rpb24sIHApO1xuICAgICAgICB9KTtcbiAgICB9LFxufTtcblxuLy8gSW5zcGlyZWQgYnkgaHR0cDovL3BhdWxib3Vya2UubmV0L2dlb21ldHJ5L3BvaW50bGluZXBsYW5lL1xuZnVuY3Rpb24gaW50ZXJzZWN0KFt7IHg6IHgxLCB5OiB5MSB9LCB7IHg6IHgyLCB5OiB5MiB9XSwgW3sgeDogeDMsIHk6IHkzIH0sIHsgeDogeDQsIHk6IHk0IH1dKSB7XG4gICAgY29uc3QgZGVub21pbmF0b3IgPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG5cbiAgICAvLyBMaW5lcyBhcmUgcGFyYWxsZWxcbiAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHVhID0gKCh4NCAtIHgzKSAqICh5MSAtIHkzKSAtICh5NCAtIHkzKSAqICh4MSAtIHgzKSkgLyBkZW5vbWluYXRvcjtcblxuICAgIGlmICh1YSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uXG4gICAgcmV0dXJuIHsgeDogeDEgKyB1YSAqICh4MiAtIHgxKSwgeTogeTEgKyB1YSAqICh5MiAtIHkxKSB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/mouse.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/observer.js":
/*!****************************************************!*\
  !*** ./node_modules/uikit/src/js/util/observer.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"observeIntersection\": () => (/* binding */ observeIntersection),\n/* harmony export */   \"observeMutation\": () => (/* binding */ observeMutation),\n/* harmony export */   \"observeResize\": () => (/* binding */ observeResize)\n/* harmony export */ });\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./event */ \"./node_modules/uikit/src/js/util/event.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n/* harmony import */ var _fastdom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fastdom */ \"./node_modules/uikit/src/js/util/fastdom.js\");\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ \"./node_modules/uikit/src/js/util/env.js\");\n\n\n\n\n\nfunction observeIntersection(targets, cb, options, intersecting = true) {\n    const observer = new IntersectionObserver(\n        intersecting\n            ? (entries, observer) => {\n                  if (entries.some((entry) => entry.isIntersecting)) {\n                      cb(entries, observer);\n                  }\n              }\n            : cb,\n        options\n    );\n    for (const el of (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(targets)) {\n        observer.observe(el);\n    }\n\n    return observer;\n}\n\nconst hasResizeObserver = _env__WEBPACK_IMPORTED_MODULE_1__.inBrowser && window.ResizeObserver;\nfunction observeResize(targets, cb, options = { box: 'border-box' }) {\n    if (hasResizeObserver) {\n        return observe(ResizeObserver, targets, cb, options);\n    }\n\n    // Fallback Safari < 13.1\n    initResizeListener();\n    listeners.add(cb);\n\n    return {\n        disconnect() {\n            listeners.delete(cb);\n        },\n    };\n}\n\nlet listeners;\nfunction initResizeListener() {\n    if (listeners) {\n        return;\n    }\n\n    listeners = new Set();\n\n    // throttle 'resize'\n    let pendingResize;\n    const handleResize = () => {\n        if (pendingResize) {\n            return;\n        }\n        pendingResize = true;\n        _fastdom__WEBPACK_IMPORTED_MODULE_2__.fastdom.read(() => (pendingResize = false));\n        for (const listener of listeners) {\n            listener();\n        }\n    };\n\n    (0,_event__WEBPACK_IMPORTED_MODULE_3__.on)(window, 'load resize', handleResize);\n    (0,_event__WEBPACK_IMPORTED_MODULE_3__.on)(document, 'loadedmetadata load', handleResize, true);\n}\n\nfunction observeMutation(targets, cb, options) {\n    return observe(MutationObserver, targets, cb, options);\n}\n\nfunction observe(Observer, targets, cb, options) {\n    const observer = new Observer(cb);\n    for (const el of (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(targets)) {\n        observer.observe(el, options);\n    }\n\n    return observer;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvb2JzZXJ2ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2QjtBQUNJO0FBQ0c7QUFDRjs7QUFFM0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLDJDQUFTO0FBQzVCLGdEQUFnRCxtQkFBbUI7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDBDQUFFO0FBQ04sSUFBSSwwQ0FBRTtBQUNOOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91aWtpdC9zcmMvanMvdXRpbC9vYnNlcnZlci5qcz8yNzM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9uIH0gZnJvbSAnLi9ldmVudCc7XG5pbXBvcnQgeyB0b05vZGVzIH0gZnJvbSAnLi9sYW5nJztcbmltcG9ydCB7IGZhc3Rkb20gfSBmcm9tICcuL2Zhc3Rkb20nO1xuaW1wb3J0IHsgaW5Ccm93c2VyIH0gZnJvbSAnLi9lbnYnO1xuXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZUludGVyc2VjdGlvbih0YXJnZXRzLCBjYiwgb3B0aW9ucywgaW50ZXJzZWN0aW5nID0gdHJ1ZSkge1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgICBpbnRlcnNlY3RpbmdcbiAgICAgICAgICAgID8gKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5zb21lKChlbnRyeSkgPT4gZW50cnkuaXNJbnRlcnNlY3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2IoZW50cmllcywgb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGNiLFxuICAgICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRvTm9kZXModGFyZ2V0cykpIHtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5jb25zdCBoYXNSZXNpemVPYnNlcnZlciA9IGluQnJvd3NlciAmJiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXI7XG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZVJlc2l6ZSh0YXJnZXRzLCBjYiwgb3B0aW9ucyA9IHsgYm94OiAnYm9yZGVyLWJveCcgfSkge1xuICAgIGlmIChoYXNSZXNpemVPYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZShSZXNpemVPYnNlcnZlciwgdGFyZ2V0cywgY2IsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIFNhZmFyaSA8IDEzLjFcbiAgICBpbml0UmVzaXplTGlzdGVuZXIoKTtcbiAgICBsaXN0ZW5lcnMuYWRkKGNiKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5sZXQgbGlzdGVuZXJzO1xuZnVuY3Rpb24gaW5pdFJlc2l6ZUxpc3RlbmVyKCkge1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcblxuICAgIC8vIHRocm90dGxlICdyZXNpemUnXG4gICAgbGV0IHBlbmRpbmdSZXNpemU7XG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICBpZiAocGVuZGluZ1Jlc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdSZXNpemUgPSB0cnVlO1xuICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4gKHBlbmRpbmdSZXNpemUgPSBmYWxzZSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBvbih3aW5kb3csICdsb2FkIHJlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgb24oZG9jdW1lbnQsICdsb2FkZWRtZXRhZGF0YSBsb2FkJywgaGFuZGxlUmVzaXplLCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVNdXRhdGlvbih0YXJnZXRzLCBjYiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvYnNlcnZlKE11dGF0aW9uT2JzZXJ2ZXIsIHRhcmdldHMsIGNiLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZShPYnNlcnZlciwgdGFyZ2V0cywgY2IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBPYnNlcnZlcihjYik7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0b05vZGVzKHRhcmdldHMpKSB7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/observer.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/options.js":
/*!***************************************************!*\
  !*** ./node_modules/uikit/src/js/util/options.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"mergeOptions\": () => (/* binding */ mergeOptions),\n/* harmony export */   \"parseOptions\": () => (/* binding */ parseOptions)\n/* harmony export */ });\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\nconst strats = {};\n\nstrats.events =\n    strats.created =\n    strats.beforeConnect =\n    strats.connected =\n    strats.beforeDisconnect =\n    strats.disconnected =\n    strats.destroy =\n        concatStrat;\n\n// args strategy\nstrats.args = function (parentVal, childVal) {\n    return childVal !== false && concatStrat(childVal || parentVal);\n};\n\n// update strategy\nstrats.update = function (parentVal, childVal) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.sortBy)(\n        concatStrat(parentVal, (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isFunction)(childVal) ? { read: childVal } : childVal),\n        'order'\n    );\n};\n\n// property strategy\nstrats.props = function (parentVal, childVal) {\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isArray)(childVal)) {\n        const value = {};\n        for (const key of childVal) {\n            value[key] = String;\n        }\n        childVal = value;\n    }\n\n    return strats.methods(parentVal, childVal);\n};\n\n// extend strategy\nstrats.computed = strats.methods = function (parentVal, childVal) {\n    return childVal ? (parentVal ? { ...parentVal, ...childVal } : childVal) : parentVal;\n};\n\n// data strategy\nstrats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n        if (!childVal) {\n            return parentVal;\n        }\n\n        if (!parentVal) {\n            return childVal;\n        }\n\n        return function (vm) {\n            return mergeFnData(parentVal, childVal, vm);\n        };\n    }\n\n    return mergeFnData(parentVal, childVal, vm);\n};\n\nfunction mergeFnData(parentVal, childVal, vm) {\n    return strats.computed(\n        (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isFunction)(parentVal) ? parentVal.call(vm, vm) : parentVal,\n        (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isFunction)(childVal) ? childVal.call(vm, vm) : childVal\n    );\n}\n\n// concat strategy\nfunction concatStrat(parentVal, childVal) {\n    parentVal = parentVal && !(0,_lang__WEBPACK_IMPORTED_MODULE_0__.isArray)(parentVal) ? [parentVal] : parentVal;\n\n    return childVal\n        ? parentVal\n            ? parentVal.concat(childVal)\n            : (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isArray)(childVal)\n            ? childVal\n            : [childVal]\n        : parentVal;\n}\n\n// default strategy\nfunction defaultStrat(parentVal, childVal) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(childVal) ? parentVal : childVal;\n}\n\nfunction mergeOptions(parent, child, vm) {\n    const options = {};\n\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isFunction)(child)) {\n        child = child.options;\n    }\n\n    if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n    }\n\n    if (child.mixins) {\n        for (const mixin of child.mixins) {\n            parent = mergeOptions(parent, mixin, vm);\n        }\n    }\n\n    for (const key in parent) {\n        mergeKey(key);\n    }\n\n    for (const key in child) {\n        if (!(0,_lang__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(parent, key)) {\n            mergeKey(key);\n        }\n    }\n\n    function mergeKey(key) {\n        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);\n    }\n\n    return options;\n}\n\nfunction parseOptions(options, args = []) {\n    try {\n        return options\n            ? (0,_lang__WEBPACK_IMPORTED_MODULE_0__.startsWith)(options, '{')\n                ? JSON.parse(options)\n                : args.length && !(0,_lang__WEBPACK_IMPORTED_MODULE_0__.includes)(options, ':')\n                ? { [args[0]]: options }\n                : options.split(';').reduce((options, option) => {\n                      const [key, value] = option.split(/:(.*)/);\n                      if (key && !(0,_lang__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(value)) {\n                          options[key.trim()] = value.trim();\n                      }\n                      return options;\n                  }, {})\n            : {};\n    } catch (e) {\n        return {};\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvb3B0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0c7O0FBRWhHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNkNBQU07QUFDakIsK0JBQStCLGlEQUFVLGVBQWUsaUJBQWlCO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsNEJBQTRCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxpREFBVTtBQUNsQixRQUFRLGlEQUFVO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBTzs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxrREFBVztBQUN0Qjs7QUFFTztBQUNQOztBQUVBLFFBQVEsaURBQVU7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZDQUFNO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxjQUFjLGlEQUFVLFlBQVk7QUFDcEM7QUFDQSxrQ0FBa0MsK0NBQVE7QUFDMUMsb0JBQW9CO0FBQ3BCLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQyxrREFBVztBQUM3QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSTtBQUN2QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvb3B0aW9ucy5qcz8yY2NlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc093biwgaW5jbHVkZXMsIGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzVW5kZWZpbmVkLCBzb3J0QnksIHN0YXJ0c1dpdGggfSBmcm9tICcuL2xhbmcnO1xuXG5jb25zdCBzdHJhdHMgPSB7fTtcblxuc3RyYXRzLmV2ZW50cyA9XG4gICAgc3RyYXRzLmNyZWF0ZWQgPVxuICAgIHN0cmF0cy5iZWZvcmVDb25uZWN0ID1cbiAgICBzdHJhdHMuY29ubmVjdGVkID1cbiAgICBzdHJhdHMuYmVmb3JlRGlzY29ubmVjdCA9XG4gICAgc3RyYXRzLmRpc2Nvbm5lY3RlZCA9XG4gICAgc3RyYXRzLmRlc3Ryb3kgPVxuICAgICAgICBjb25jYXRTdHJhdDtcblxuLy8gYXJncyBzdHJhdGVneVxuc3RyYXRzLmFyZ3MgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBjaGlsZFZhbCAhPT0gZmFsc2UgJiYgY29uY2F0U3RyYXQoY2hpbGRWYWwgfHwgcGFyZW50VmFsKTtcbn07XG5cbi8vIHVwZGF0ZSBzdHJhdGVneVxuc3RyYXRzLnVwZGF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIHNvcnRCeShcbiAgICAgICAgY29uY2F0U3RyYXQocGFyZW50VmFsLCBpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IHsgcmVhZDogY2hpbGRWYWwgfSA6IGNoaWxkVmFsKSxcbiAgICAgICAgJ29yZGVyJ1xuICAgICk7XG59O1xuXG4vLyBwcm9wZXJ0eSBzdHJhdGVneVxuc3RyYXRzLnByb3BzID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICBpZiAoaXNBcnJheShjaGlsZFZhbCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgY2hpbGRWYWwpIHtcbiAgICAgICAgICAgIHZhbHVlW2tleV0gPSBTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRWYWwgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyYXRzLm1ldGhvZHMocGFyZW50VmFsLCBjaGlsZFZhbCk7XG59O1xuXG4vLyBleHRlbmQgc3RyYXRlZ3lcbnN0cmF0cy5jb21wdXRlZCA9IHN0cmF0cy5tZXRob2RzID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gY2hpbGRWYWwgPyAocGFyZW50VmFsID8geyAuLi5wYXJlbnRWYWwsIC4uLmNoaWxkVmFsIH0gOiBjaGlsZFZhbCkgOiBwYXJlbnRWYWw7XG59O1xuXG4vLyBkYXRhIHN0cmF0ZWd5XG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZtKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VGbkRhdGEocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBtZXJnZUZuRGF0YShwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSk7XG59O1xuXG5mdW5jdGlvbiBtZXJnZUZuRGF0YShwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICAgIHJldHVybiBzdHJhdHMuY29tcHV0ZWQoXG4gICAgICAgIGlzRnVuY3Rpb24ocGFyZW50VmFsKSA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSkgOiBwYXJlbnRWYWwsXG4gICAgICAgIGlzRnVuY3Rpb24oY2hpbGRWYWwpID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pIDogY2hpbGRWYWxcbiAgICApO1xufVxuXG4vLyBjb25jYXQgc3RyYXRlZ3lcbmZ1bmN0aW9uIGNvbmNhdFN0cmF0KHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICBwYXJlbnRWYWwgPSBwYXJlbnRWYWwgJiYgIWlzQXJyYXkocGFyZW50VmFsKSA/IFtwYXJlbnRWYWxdIDogcGFyZW50VmFsO1xuXG4gICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgICAgID8gcGFyZW50VmFsXG4gICAgICAgICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICAgICAgICA6IGlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICAgICAgOiBwYXJlbnRWYWw7XG59XG5cbi8vIGRlZmF1bHQgc3RyYXRlZ3lcbmZ1bmN0aW9uIGRlZmF1bHRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKGNoaWxkVmFsKSA/IHBhcmVudFZhbCA6IGNoaWxkVmFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQsIHZtKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgICBmb3IgKGNvbnN0IG1peGluIG9mIGNoaWxkLm1peGlucykge1xuICAgICAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgbWl4aW4sIHZtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmVudCkge1xuICAgICAgICBtZXJnZUtleShrZXkpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IGluIGNoaWxkKSB7XG4gICAgICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgICAgICAgbWVyZ2VLZXkoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlS2V5KGtleSkge1xuICAgICAgICBvcHRpb25zW2tleV0gPSAoc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0KShwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0pO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VPcHRpb25zKG9wdGlvbnMsIGFyZ3MgPSBbXSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zXG4gICAgICAgICAgICA/IHN0YXJ0c1dpdGgob3B0aW9ucywgJ3snKVxuICAgICAgICAgICAgICAgID8gSlNPTi5wYXJzZShvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogYXJncy5sZW5ndGggJiYgIWluY2x1ZGVzKG9wdGlvbnMsICc6JylcbiAgICAgICAgICAgICAgICA/IHsgW2FyZ3NbMF1dOiBvcHRpb25zIH1cbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuc3BsaXQoJzsnKS5yZWR1Y2UoKG9wdGlvbnMsIG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IG9wdGlvbi5zcGxpdCgvOiguKikvKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICYmICFpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXkudHJpbSgpXSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgICAgIDoge307XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/options.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/player.js":
/*!**************************************************!*\
  !*** ./node_modules/uikit/src/js/util/player.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isVideo\": () => (/* binding */ isVideo),\n/* harmony export */   \"mute\": () => (/* binding */ mute),\n/* harmony export */   \"pause\": () => (/* binding */ pause),\n/* harmony export */   \"play\": () => (/* binding */ play)\n/* harmony export */ });\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom */ \"./node_modules/uikit/src/js/util/dom.js\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event */ \"./node_modules/uikit/src/js/util/event.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\n\n\nfunction play(el) {\n    if (isIFrame(el)) {\n        call(el, { func: 'playVideo', method: 'play' });\n    }\n\n    if (isHTML5(el)) {\n        try {\n            el.play().catch(_lang__WEBPACK_IMPORTED_MODULE_0__.noop);\n        } catch (e) {\n            // noop\n        }\n    }\n}\n\nfunction pause(el) {\n    if (isIFrame(el)) {\n        call(el, { func: 'pauseVideo', method: 'pause' });\n    }\n\n    if (isHTML5(el)) {\n        el.pause();\n    }\n}\n\nfunction mute(el) {\n    if (isIFrame(el)) {\n        call(el, { func: 'mute', method: 'setVolume', value: 0 });\n    }\n\n    if (isHTML5(el)) {\n        el.muted = true;\n    }\n}\n\nfunction isVideo(el) {\n    return isHTML5(el) || isIFrame(el);\n}\n\nfunction isHTML5(el) {\n    return (0,_dom__WEBPACK_IMPORTED_MODULE_1__.isTag)(el, 'video');\n}\n\nfunction isIFrame(el) {\n    return (0,_dom__WEBPACK_IMPORTED_MODULE_1__.isTag)(el, 'iframe') && (isYoutube(el) || isVimeo(el));\n}\n\nfunction isYoutube(el) {\n    return !!el.src.match(\n        /\\/\\/.*?youtube(-nocookie)?\\.[a-z]+\\/(watch\\?v=[^&\\s]+|embed)|youtu\\.be\\/.*/\n    );\n}\n\nfunction isVimeo(el) {\n    return !!el.src.match(/vimeo\\.com\\/video\\/.*/);\n}\n\nasync function call(el, cmd) {\n    await enableApi(el);\n    post(el, cmd);\n}\n\nfunction post(el, cmd) {\n    try {\n        el.contentWindow.postMessage(JSON.stringify({ event: 'command', ...cmd }), '*');\n    } catch (e) {\n        // noop\n    }\n}\n\nconst stateKey = '_ukPlayer';\nlet counter = 0;\nfunction enableApi(el) {\n    if (el[stateKey]) {\n        return el[stateKey];\n    }\n\n    const youtube = isYoutube(el);\n    const vimeo = isVimeo(el);\n\n    const id = ++counter;\n    let poller;\n\n    return (el[stateKey] = new Promise((resolve) => {\n        youtube &&\n            (0,_event__WEBPACK_IMPORTED_MODULE_2__.once)(el, 'load', () => {\n                const listener = () => post(el, { event: 'listening', id });\n                poller = setInterval(listener, 100);\n                listener();\n            });\n\n        (0,_event__WEBPACK_IMPORTED_MODULE_2__.once)(window, 'message', resolve, false, ({ data }) => {\n            try {\n                data = JSON.parse(data);\n                return (\n                    data &&\n                    ((youtube && data.id === id && data.event === 'onReady') ||\n                        (vimeo && Number(data.player_id) === id))\n                );\n            } catch (e) {\n                // noop\n            }\n        });\n\n        el.src = `${el.src}${(0,_lang__WEBPACK_IMPORTED_MODULE_0__.includes)(el.src, '?') ? '&' : '?'}${\n            youtube ? 'enablejsapi=1' : `api=1&player_id=${id}`\n        }`;\n    }).then(() => clearInterval(poller)));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvcGxheWVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEI7QUFDQztBQUNTOztBQUVqQztBQUNQO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHVDQUFJO0FBQ2hDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsbUJBQW1CLDZDQUE2QztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDJDQUFLO0FBQ2hCOztBQUVBO0FBQ0EsV0FBVywyQ0FBSztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNELDBCQUEwQjtBQUNoRixNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksNENBQUk7QUFDaEIsa0RBQWtELHdCQUF3QjtBQUMxRTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixRQUFRLDRDQUFJLHVDQUF1QyxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVULG9CQUFvQixPQUFPLEVBQUUsK0NBQVEsMEJBQTBCO0FBQy9ELDJEQUEyRCxHQUFHO0FBQzlELFNBQVM7QUFDVCxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvcGxheWVyLmpzPzhiNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNUYWcgfSBmcm9tICcuL2RvbSc7XG5pbXBvcnQgeyBvbmNlIH0gZnJvbSAnLi9ldmVudCc7XG5pbXBvcnQgeyBpbmNsdWRlcywgbm9vcCB9IGZyb20gJy4vbGFuZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBwbGF5KGVsKSB7XG4gICAgaWYgKGlzSUZyYW1lKGVsKSkge1xuICAgICAgICBjYWxsKGVsLCB7IGZ1bmM6ICdwbGF5VmlkZW8nLCBtZXRob2Q6ICdwbGF5JyB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MNShlbCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsLnBsYXkoKS5jYXRjaChub29wKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF1c2UoZWwpIHtcbiAgICBpZiAoaXNJRnJhbWUoZWwpKSB7XG4gICAgICAgIGNhbGwoZWwsIHsgZnVuYzogJ3BhdXNlVmlkZW8nLCBtZXRob2Q6ICdwYXVzZScgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTDUoZWwpKSB7XG4gICAgICAgIGVsLnBhdXNlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbXV0ZShlbCkge1xuICAgIGlmIChpc0lGcmFtZShlbCkpIHtcbiAgICAgICAgY2FsbChlbCwgeyBmdW5jOiAnbXV0ZScsIG1ldGhvZDogJ3NldFZvbHVtZScsIHZhbHVlOiAwIH0pO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUw1KGVsKSkge1xuICAgICAgICBlbC5tdXRlZCA9IHRydWU7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWaWRlbyhlbCkge1xuICAgIHJldHVybiBpc0hUTUw1KGVsKSB8fCBpc0lGcmFtZShlbCk7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTDUoZWwpIHtcbiAgICByZXR1cm4gaXNUYWcoZWwsICd2aWRlbycpO1xufVxuXG5mdW5jdGlvbiBpc0lGcmFtZShlbCkge1xuICAgIHJldHVybiBpc1RhZyhlbCwgJ2lmcmFtZScpICYmIChpc1lvdXR1YmUoZWwpIHx8IGlzVmltZW8oZWwpKTtcbn1cblxuZnVuY3Rpb24gaXNZb3V0dWJlKGVsKSB7XG4gICAgcmV0dXJuICEhZWwuc3JjLm1hdGNoKFxuICAgICAgICAvXFwvXFwvLio/eW91dHViZSgtbm9jb29raWUpP1xcLlthLXpdK1xcLyh3YXRjaFxcP3Y9W14mXFxzXSt8ZW1iZWQpfHlvdXR1XFwuYmVcXC8uKi9cbiAgICApO1xufVxuXG5mdW5jdGlvbiBpc1ZpbWVvKGVsKSB7XG4gICAgcmV0dXJuICEhZWwuc3JjLm1hdGNoKC92aW1lb1xcLmNvbVxcL3ZpZGVvXFwvLiovKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbChlbCwgY21kKSB7XG4gICAgYXdhaXQgZW5hYmxlQXBpKGVsKTtcbiAgICBwb3N0KGVsLCBjbWQpO1xufVxuXG5mdW5jdGlvbiBwb3N0KGVsLCBjbWQpIHtcbiAgICB0cnkge1xuICAgICAgICBlbC5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHsgZXZlbnQ6ICdjb21tYW5kJywgLi4uY21kIH0pLCAnKicpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH1cbn1cblxuY29uc3Qgc3RhdGVLZXkgPSAnX3VrUGxheWVyJztcbmxldCBjb3VudGVyID0gMDtcbmZ1bmN0aW9uIGVuYWJsZUFwaShlbCkge1xuICAgIGlmIChlbFtzdGF0ZUtleV0pIHtcbiAgICAgICAgcmV0dXJuIGVsW3N0YXRlS2V5XTtcbiAgICB9XG5cbiAgICBjb25zdCB5b3V0dWJlID0gaXNZb3V0dWJlKGVsKTtcbiAgICBjb25zdCB2aW1lbyA9IGlzVmltZW8oZWwpO1xuXG4gICAgY29uc3QgaWQgPSArK2NvdW50ZXI7XG4gICAgbGV0IHBvbGxlcjtcblxuICAgIHJldHVybiAoZWxbc3RhdGVLZXldID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgeW91dHViZSAmJlxuICAgICAgICAgICAgb25jZShlbCwgJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiBwb3N0KGVsLCB7IGV2ZW50OiAnbGlzdGVuaW5nJywgaWQgfSk7XG4gICAgICAgICAgICAgICAgcG9sbGVyID0gc2V0SW50ZXJ2YWwobGlzdGVuZXIsIDEwMCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG9uY2Uod2luZG93LCAnbWVzc2FnZScsIHJlc29sdmUsIGZhbHNlLCAoeyBkYXRhIH0pID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICAoKHlvdXR1YmUgJiYgZGF0YS5pZCA9PT0gaWQgJiYgZGF0YS5ldmVudCA9PT0gJ29uUmVhZHknKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHZpbWVvICYmIE51bWJlcihkYXRhLnBsYXllcl9pZCkgPT09IGlkKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWwuc3JjID0gYCR7ZWwuc3JjfSR7aW5jbHVkZXMoZWwuc3JjLCAnPycpID8gJyYnIDogJz8nfSR7XG4gICAgICAgICAgICB5b3V0dWJlID8gJ2VuYWJsZWpzYXBpPTEnIDogYGFwaT0xJnBsYXllcl9pZD0ke2lkfWBcbiAgICAgICAgfWA7XG4gICAgfSkudGhlbigoKSA9PiBjbGVhckludGVydmFsKHBvbGxlcikpKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/player.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/position.js":
/*!****************************************************!*\
  !*** ./node_modules/uikit/src/js/util/position.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"positionAt\": () => (/* binding */ positionAt)\n/* harmony export */ });\n/* harmony import */ var _dimensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dimensions */ \"./node_modules/uikit/src/js/util/dimensions.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n/* harmony import */ var _viewport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewport */ \"./node_modules/uikit/src/js/util/viewport.js\");\n\n\n\n\nconst dirs = [\n    ['width', 'x', 'left', 'right'],\n    ['height', 'y', 'top', 'bottom'],\n];\n\nfunction positionAt(element, target, options) {\n    options = {\n        attach: {\n            element: ['left', 'top'],\n            target: ['left', 'top'],\n            ...options.attach,\n        },\n        offset: [0, 0],\n        ...options,\n    };\n\n    const dim = options.flip\n        ? attachToWithFlip(element, target, options)\n        : attachTo(element, target, options);\n\n    (0,_dimensions__WEBPACK_IMPORTED_MODULE_0__.offset)(element, dim);\n}\n\nfunction attachTo(element, target, options) {\n    let { attach, offset: offsetBy } = {\n        attach: {\n            element: ['left', 'top'],\n            target: ['left', 'top'],\n            ...options.attach,\n        },\n        offset: [0, 0],\n        ...options,\n    };\n\n    const position = (0,_dimensions__WEBPACK_IMPORTED_MODULE_0__.offset)(element);\n    const targetOffset = (0,_dimensions__WEBPACK_IMPORTED_MODULE_0__.offset)(target);\n    for (const [i, [prop, dir, start, end]] of Object.entries(dirs)) {\n        position[start] = position[dir] =\n            targetOffset[start] +\n            moveBy(attach.target[i], end, targetOffset[prop]) -\n            moveBy(attach.element[i], end, position[prop]) +\n            +offsetBy[i];\n        position[end] = position[start] + position[prop];\n    }\n    return position;\n}\n\nfunction attachToWithFlip(element, target, options) {\n    const position = attachTo(element, target, options);\n    const targetDim = (0,_dimensions__WEBPACK_IMPORTED_MODULE_0__.offset)(target);\n\n    let {\n        flip,\n        attach: { element: elAttach, target: targetAttach },\n        offset: elOffset,\n        boundary,\n        viewport,\n        viewportPadding,\n    } = options;\n\n    let viewports = (0,_viewport__WEBPACK_IMPORTED_MODULE_1__.scrollParents)(element);\n    if (boundary === target) {\n        viewports = viewports.filter((viewport) => viewport !== boundary);\n    }\n    const [scrollElement] = viewports;\n    viewports.push(viewport);\n\n    const offsetPosition = { ...position };\n    for (const [i, [prop, dir, start, end]] of Object.entries(dirs)) {\n        if (flip !== true && !(0,_lang__WEBPACK_IMPORTED_MODULE_2__.includes)(flip, dir)) {\n            continue;\n        }\n\n        const willFlip =\n            !intersectLine(position, targetDim, i) && intersectLine(position, targetDim, 1 - i);\n\n        viewport = getIntersectionArea(...viewports.filter(Boolean).map(_viewport__WEBPACK_IMPORTED_MODULE_1__.offsetViewport));\n\n        if (viewportPadding) {\n            viewport[start] += viewportPadding;\n            viewport[end] -= viewportPadding;\n        }\n\n        if (boundary && !willFlip && position[prop] <= (0,_dimensions__WEBPACK_IMPORTED_MODULE_0__.offset)(boundary)[prop]) {\n            viewport = getIntersectionArea(viewport, (0,_dimensions__WEBPACK_IMPORTED_MODULE_0__.offset)(boundary));\n        }\n\n        const isInStartBoundary = position[start] >= viewport[start];\n        const isInEndBoundary = position[end] <= viewport[end];\n\n        if (isInStartBoundary && isInEndBoundary) {\n            continue;\n        }\n\n        let offsetBy;\n\n        // Flip\n        if (willFlip) {\n            if (\n                (elAttach[i] === end && isInStartBoundary) ||\n                (elAttach[i] === start && isInEndBoundary)\n            ) {\n                continue;\n            }\n\n            offsetBy =\n                (elAttach[i] === start\n                    ? -position[prop]\n                    : elAttach[i] === end\n                    ? position[prop]\n                    : 0) +\n                (targetAttach[i] === start\n                    ? targetDim[prop]\n                    : targetAttach[i] === end\n                    ? -targetDim[prop]\n                    : 0) -\n                elOffset[i] * 2;\n\n            if (\n                !isInScrollArea(\n                    {\n                        ...position,\n                        [start]: position[start] + offsetBy,\n                        [end]: position[end] + offsetBy,\n                    },\n                    scrollElement,\n                    i\n                )\n            ) {\n                if (isInScrollArea(position, scrollElement, i)) {\n                    continue;\n                }\n\n                if (options.recursion) {\n                    return false;\n                }\n\n                const newPos = attachToWithFlip(element, target, {\n                    ...options,\n                    attach: {\n                        element: elAttach.map(flipDir).reverse(),\n                        target: targetAttach.map(flipDir).reverse(),\n                    },\n                    offset: elOffset.reverse(),\n                    flip: flip === true ? flip : [...flip, dirs[1 - i][1]],\n                    recursion: true,\n                });\n\n                if (newPos && isInScrollArea(newPos, scrollElement, 1 - i)) {\n                    return newPos;\n                }\n            }\n\n            // Move\n        } else {\n            offsetBy =\n                (0,_lang__WEBPACK_IMPORTED_MODULE_2__.clamp)(\n                    (0,_lang__WEBPACK_IMPORTED_MODULE_2__.clamp)(position[start], viewport[start], viewport[end] - position[prop]),\n                    targetDim[start] - position[prop] + elOffset[i],\n                    targetDim[end] - elOffset[i]\n                ) - position[start];\n        }\n\n        offsetPosition[start] = position[dir] = position[start] + offsetBy;\n        offsetPosition[end] += offsetBy;\n    }\n\n    return offsetPosition;\n}\n\nfunction moveBy(start, end, dim) {\n    return start === 'center' ? dim / 2 : start === end ? dim : 0;\n}\n\nfunction getIntersectionArea(...rects) {\n    let area = {};\n    for (const rect of rects) {\n        for (const [, , start, end] of dirs) {\n            area[start] = Math.max(area[start] || 0, rect[start]);\n            area[end] = Math.min(...[area[end], rect[end]].filter(Boolean));\n        }\n    }\n    return area;\n}\n\nfunction isInScrollArea(position, scrollElement, dir) {\n    const viewport = (0,_viewport__WEBPACK_IMPORTED_MODULE_1__.offsetViewport)(scrollElement);\n    const [prop, , start, end] = dirs[dir];\n    viewport[start] -= scrollElement[`scroll${(0,_lang__WEBPACK_IMPORTED_MODULE_2__.ucfirst)(start)}`];\n    viewport[end] = viewport[start] + scrollElement[`scroll${(0,_lang__WEBPACK_IMPORTED_MODULE_2__.ucfirst)(prop)}`];\n\n    return position[start] >= viewport[start] && position[end] <= viewport[end];\n}\n\nfunction intersectLine(dimA, dimB, dir) {\n    const [, , start, end] = dirs[dir];\n    return dimA[end] > dimB[start] && dimB[end] > dimA[start];\n}\n\nfunction flipDir(prop) {\n    for (let i = 0; i < dirs.length; i++) {\n        const index = dirs[i].indexOf(prop);\n        if (~index) {\n            return dirs[1 - i][(index % 2) + 2];\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvcG9zaXRpb24uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzQztBQUNZO0FBQ1M7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksbURBQU07QUFDVjs7QUFFQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsbURBQU07QUFDM0IseUJBQXlCLG1EQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQU07O0FBRTVCO0FBQ0E7QUFDQSxrQkFBa0IseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixvQkFBb0Isd0RBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQSw4QkFBOEIsK0NBQVE7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdFQUF3RSxxREFBYzs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVELG1EQUFNO0FBQzdELHFEQUFxRCxtREFBTTtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGdCQUFnQiw0Q0FBSztBQUNyQixvQkFBb0IsNENBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHlEQUFjO0FBQ25DO0FBQ0EsOENBQThDLDhDQUFPLFFBQVE7QUFDN0QsNkRBQTZELDhDQUFPLE9BQU87O0FBRTNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91aWtpdC9zcmMvanMvdXRpbC9wb3NpdGlvbi5qcz9mYjBlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9mZnNldCB9IGZyb20gJy4vZGltZW5zaW9ucyc7XG5pbXBvcnQgeyBjbGFtcCwgaW5jbHVkZXMsIHVjZmlyc3QgfSBmcm9tICcuL2xhbmcnO1xuaW1wb3J0IHsgb2Zmc2V0Vmlld3BvcnQsIHNjcm9sbFBhcmVudHMgfSBmcm9tICcuL3ZpZXdwb3J0JztcblxuY29uc3QgZGlycyA9IFtcbiAgICBbJ3dpZHRoJywgJ3gnLCAnbGVmdCcsICdyaWdodCddLFxuICAgIFsnaGVpZ2h0JywgJ3knLCAndG9wJywgJ2JvdHRvbSddLFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBvc2l0aW9uQXQoZWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgICAgYXR0YWNoOiB7XG4gICAgICAgICAgICBlbGVtZW50OiBbJ2xlZnQnLCAndG9wJ10sXG4gICAgICAgICAgICB0YXJnZXQ6IFsnbGVmdCcsICd0b3AnXSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuYXR0YWNoLFxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgY29uc3QgZGltID0gb3B0aW9ucy5mbGlwXG4gICAgICAgID8gYXR0YWNoVG9XaXRoRmxpcChlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpXG4gICAgICAgIDogYXR0YWNoVG8oZWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zKTtcblxuICAgIG9mZnNldChlbGVtZW50LCBkaW0pO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUbyhlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgeyBhdHRhY2gsIG9mZnNldDogb2Zmc2V0QnkgfSA9IHtcbiAgICAgICAgYXR0YWNoOiB7XG4gICAgICAgICAgICBlbGVtZW50OiBbJ2xlZnQnLCAndG9wJ10sXG4gICAgICAgICAgICB0YXJnZXQ6IFsnbGVmdCcsICd0b3AnXSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuYXR0YWNoLFxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgY29uc3QgcG9zaXRpb24gPSBvZmZzZXQoZWxlbWVudCk7XG4gICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0KHRhcmdldCk7XG4gICAgZm9yIChjb25zdCBbaSwgW3Byb3AsIGRpciwgc3RhcnQsIGVuZF1dIG9mIE9iamVjdC5lbnRyaWVzKGRpcnMpKSB7XG4gICAgICAgIHBvc2l0aW9uW3N0YXJ0XSA9IHBvc2l0aW9uW2Rpcl0gPVxuICAgICAgICAgICAgdGFyZ2V0T2Zmc2V0W3N0YXJ0XSArXG4gICAgICAgICAgICBtb3ZlQnkoYXR0YWNoLnRhcmdldFtpXSwgZW5kLCB0YXJnZXRPZmZzZXRbcHJvcF0pIC1cbiAgICAgICAgICAgIG1vdmVCeShhdHRhY2guZWxlbWVudFtpXSwgZW5kLCBwb3NpdGlvbltwcm9wXSkgK1xuICAgICAgICAgICAgK29mZnNldEJ5W2ldO1xuICAgICAgICBwb3NpdGlvbltlbmRdID0gcG9zaXRpb25bc3RhcnRdICsgcG9zaXRpb25bcHJvcF07XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9XaXRoRmxpcChlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGF0dGFjaFRvKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdGFyZ2V0RGltID0gb2Zmc2V0KHRhcmdldCk7XG5cbiAgICBsZXQge1xuICAgICAgICBmbGlwLFxuICAgICAgICBhdHRhY2g6IHsgZWxlbWVudDogZWxBdHRhY2gsIHRhcmdldDogdGFyZ2V0QXR0YWNoIH0sXG4gICAgICAgIG9mZnNldDogZWxPZmZzZXQsXG4gICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgdmlld3BvcnRQYWRkaW5nLFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgbGV0IHZpZXdwb3J0cyA9IHNjcm9sbFBhcmVudHMoZWxlbWVudCk7XG4gICAgaWYgKGJvdW5kYXJ5ID09PSB0YXJnZXQpIHtcbiAgICAgICAgdmlld3BvcnRzID0gdmlld3BvcnRzLmZpbHRlcigodmlld3BvcnQpID0+IHZpZXdwb3J0ICE9PSBib3VuZGFyeSk7XG4gICAgfVxuICAgIGNvbnN0IFtzY3JvbGxFbGVtZW50XSA9IHZpZXdwb3J0cztcbiAgICB2aWV3cG9ydHMucHVzaCh2aWV3cG9ydCk7XG5cbiAgICBjb25zdCBvZmZzZXRQb3NpdGlvbiA9IHsgLi4ucG9zaXRpb24gfTtcbiAgICBmb3IgKGNvbnN0IFtpLCBbcHJvcCwgZGlyLCBzdGFydCwgZW5kXV0gb2YgT2JqZWN0LmVudHJpZXMoZGlycykpIHtcbiAgICAgICAgaWYgKGZsaXAgIT09IHRydWUgJiYgIWluY2x1ZGVzKGZsaXAsIGRpcikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2lsbEZsaXAgPVxuICAgICAgICAgICAgIWludGVyc2VjdExpbmUocG9zaXRpb24sIHRhcmdldERpbSwgaSkgJiYgaW50ZXJzZWN0TGluZShwb3NpdGlvbiwgdGFyZ2V0RGltLCAxIC0gaSk7XG5cbiAgICAgICAgdmlld3BvcnQgPSBnZXRJbnRlcnNlY3Rpb25BcmVhKC4uLnZpZXdwb3J0cy5maWx0ZXIoQm9vbGVhbikubWFwKG9mZnNldFZpZXdwb3J0KSk7XG5cbiAgICAgICAgaWYgKHZpZXdwb3J0UGFkZGluZykge1xuICAgICAgICAgICAgdmlld3BvcnRbc3RhcnRdICs9IHZpZXdwb3J0UGFkZGluZztcbiAgICAgICAgICAgIHZpZXdwb3J0W2VuZF0gLT0gdmlld3BvcnRQYWRkaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvdW5kYXJ5ICYmICF3aWxsRmxpcCAmJiBwb3NpdGlvbltwcm9wXSA8PSBvZmZzZXQoYm91bmRhcnkpW3Byb3BdKSB7XG4gICAgICAgICAgICB2aWV3cG9ydCA9IGdldEludGVyc2VjdGlvbkFyZWEodmlld3BvcnQsIG9mZnNldChib3VuZGFyeSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNJblN0YXJ0Qm91bmRhcnkgPSBwb3NpdGlvbltzdGFydF0gPj0gdmlld3BvcnRbc3RhcnRdO1xuICAgICAgICBjb25zdCBpc0luRW5kQm91bmRhcnkgPSBwb3NpdGlvbltlbmRdIDw9IHZpZXdwb3J0W2VuZF07XG5cbiAgICAgICAgaWYgKGlzSW5TdGFydEJvdW5kYXJ5ICYmIGlzSW5FbmRCb3VuZGFyeSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb2Zmc2V0Qnk7XG5cbiAgICAgICAgLy8gRmxpcFxuICAgICAgICBpZiAod2lsbEZsaXApIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZWxBdHRhY2hbaV0gPT09IGVuZCAmJiBpc0luU3RhcnRCb3VuZGFyeSkgfHxcbiAgICAgICAgICAgICAgICAoZWxBdHRhY2hbaV0gPT09IHN0YXJ0ICYmIGlzSW5FbmRCb3VuZGFyeSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXRCeSA9XG4gICAgICAgICAgICAgICAgKGVsQXR0YWNoW2ldID09PSBzdGFydFxuICAgICAgICAgICAgICAgICAgICA/IC1wb3NpdGlvbltwcm9wXVxuICAgICAgICAgICAgICAgICAgICA6IGVsQXR0YWNoW2ldID09PSBlbmRcbiAgICAgICAgICAgICAgICAgICAgPyBwb3NpdGlvbltwcm9wXVxuICAgICAgICAgICAgICAgICAgICA6IDApICtcbiAgICAgICAgICAgICAgICAodGFyZ2V0QXR0YWNoW2ldID09PSBzdGFydFxuICAgICAgICAgICAgICAgICAgICA/IHRhcmdldERpbVtwcm9wXVxuICAgICAgICAgICAgICAgICAgICA6IHRhcmdldEF0dGFjaFtpXSA9PT0gZW5kXG4gICAgICAgICAgICAgICAgICAgID8gLXRhcmdldERpbVtwcm9wXVxuICAgICAgICAgICAgICAgICAgICA6IDApIC1cbiAgICAgICAgICAgICAgICBlbE9mZnNldFtpXSAqIDI7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhaXNJblNjcm9sbEFyZWEoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3N0YXJ0XTogcG9zaXRpb25bc3RhcnRdICsgb2Zmc2V0QnksXG4gICAgICAgICAgICAgICAgICAgICAgICBbZW5kXTogcG9zaXRpb25bZW5kXSArIG9mZnNldEJ5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5TY3JvbGxBcmVhKHBvc2l0aW9uLCBzY3JvbGxFbGVtZW50LCBpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZWN1cnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BvcyA9IGF0dGFjaFRvV2l0aEZsaXAoZWxlbWVudCwgdGFyZ2V0LCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxBdHRhY2gubWFwKGZsaXBEaXIpLnJldmVyc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0QXR0YWNoLm1hcChmbGlwRGlyKS5yZXZlcnNlKCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogZWxPZmZzZXQucmV2ZXJzZSgpLFxuICAgICAgICAgICAgICAgICAgICBmbGlwOiBmbGlwID09PSB0cnVlID8gZmxpcCA6IFsuLi5mbGlwLCBkaXJzWzEgLSBpXVsxXV0sXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXdQb3MgJiYgaXNJblNjcm9sbEFyZWEobmV3UG9zLCBzY3JvbGxFbGVtZW50LCAxIC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1vdmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldEJ5ID1cbiAgICAgICAgICAgICAgICBjbGFtcChcbiAgICAgICAgICAgICAgICAgICAgY2xhbXAocG9zaXRpb25bc3RhcnRdLCB2aWV3cG9ydFtzdGFydF0sIHZpZXdwb3J0W2VuZF0gLSBwb3NpdGlvbltwcm9wXSksXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldERpbVtzdGFydF0gLSBwb3NpdGlvbltwcm9wXSArIGVsT2Zmc2V0W2ldLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXREaW1bZW5kXSAtIGVsT2Zmc2V0W2ldXG4gICAgICAgICAgICAgICAgKSAtIHBvc2l0aW9uW3N0YXJ0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldFBvc2l0aW9uW3N0YXJ0XSA9IHBvc2l0aW9uW2Rpcl0gPSBwb3NpdGlvbltzdGFydF0gKyBvZmZzZXRCeTtcbiAgICAgICAgb2Zmc2V0UG9zaXRpb25bZW5kXSArPSBvZmZzZXRCeTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0UG9zaXRpb247XG59XG5cbmZ1bmN0aW9uIG1vdmVCeShzdGFydCwgZW5kLCBkaW0pIHtcbiAgICByZXR1cm4gc3RhcnQgPT09ICdjZW50ZXInID8gZGltIC8gMiA6IHN0YXJ0ID09PSBlbmQgPyBkaW0gOiAwO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25BcmVhKC4uLnJlY3RzKSB7XG4gICAgbGV0IGFyZWEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBbLCAsIHN0YXJ0LCBlbmRdIG9mIGRpcnMpIHtcbiAgICAgICAgICAgIGFyZWFbc3RhcnRdID0gTWF0aC5tYXgoYXJlYVtzdGFydF0gfHwgMCwgcmVjdFtzdGFydF0pO1xuICAgICAgICAgICAgYXJlYVtlbmRdID0gTWF0aC5taW4oLi4uW2FyZWFbZW5kXSwgcmVjdFtlbmRdXS5maWx0ZXIoQm9vbGVhbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmVhO1xufVxuXG5mdW5jdGlvbiBpc0luU2Nyb2xsQXJlYShwb3NpdGlvbiwgc2Nyb2xsRWxlbWVudCwgZGlyKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBvZmZzZXRWaWV3cG9ydChzY3JvbGxFbGVtZW50KTtcbiAgICBjb25zdCBbcHJvcCwgLCBzdGFydCwgZW5kXSA9IGRpcnNbZGlyXTtcbiAgICB2aWV3cG9ydFtzdGFydF0gLT0gc2Nyb2xsRWxlbWVudFtgc2Nyb2xsJHt1Y2ZpcnN0KHN0YXJ0KX1gXTtcbiAgICB2aWV3cG9ydFtlbmRdID0gdmlld3BvcnRbc3RhcnRdICsgc2Nyb2xsRWxlbWVudFtgc2Nyb2xsJHt1Y2ZpcnN0KHByb3ApfWBdO1xuXG4gICAgcmV0dXJuIHBvc2l0aW9uW3N0YXJ0XSA+PSB2aWV3cG9ydFtzdGFydF0gJiYgcG9zaXRpb25bZW5kXSA8PSB2aWV3cG9ydFtlbmRdO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RMaW5lKGRpbUEsIGRpbUIsIGRpcikge1xuICAgIGNvbnN0IFssICwgc3RhcnQsIGVuZF0gPSBkaXJzW2Rpcl07XG4gICAgcmV0dXJuIGRpbUFbZW5kXSA+IGRpbUJbc3RhcnRdICYmIGRpbUJbZW5kXSA+IGRpbUFbc3RhcnRdO1xufVxuXG5mdW5jdGlvbiBmbGlwRGlyKHByb3ApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBkaXJzW2ldLmluZGV4T2YocHJvcCk7XG4gICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXJzWzEgLSBpXVsoaW5kZXggJSAyKSArIDJdO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/position.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/selector.js":
/*!****************************************************!*\
  !*** ./node_modules/uikit/src/js/util/selector.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"escape\": () => (/* binding */ escape),\n/* harmony export */   \"find\": () => (/* binding */ find),\n/* harmony export */   \"findAll\": () => (/* binding */ findAll),\n/* harmony export */   \"query\": () => (/* binding */ query),\n/* harmony export */   \"queryAll\": () => (/* binding */ queryAll)\n/* harmony export */ });\n/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attr */ \"./node_modules/uikit/src/js/util/attr.js\");\n/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filter */ \"./node_modules/uikit/src/js/util/filter.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\n\n\nfunction query(selector, context) {\n    return find(selector, getContext(selector, context));\n}\n\nfunction queryAll(selector, context) {\n    return findAll(selector, getContext(selector, context));\n}\n\nfunction find(selector, context) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNode)(_query(selector, context, 'querySelector'));\n}\n\nfunction findAll(selector, context) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(_query(selector, context, 'querySelectorAll'));\n}\n\nconst contextSelectorRe = /(^|[^\\\\],)\\s*[!>+~-]/;\nconst isContextSelector = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.memoize)((selector) => selector.match(contextSelectorRe));\n\nfunction getContext(selector, context = document) {\n    return ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isString)(selector) && isContextSelector(selector)) || (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isDocument)(context)\n        ? context\n        : context.ownerDocument;\n}\n\nconst contextSanitizeRe = /([!>+~-])(?=\\s+[!>+~-]|\\s*$)/g;\nconst sanatize = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.memoize)((selector) => selector.replace(contextSanitizeRe, '$1 *'));\n\nfunction _query(selector, context = document, queryFn) {\n    if (!selector || !(0,_lang__WEBPACK_IMPORTED_MODULE_0__.isString)(selector)) {\n        return selector;\n    }\n\n    selector = sanatize(selector);\n\n    if (isContextSelector(selector)) {\n        const split = splitSelector(selector);\n        selector = '';\n        for (let sel of split) {\n            let ctx = context;\n\n            if (sel[0] === '!') {\n                const selectors = sel.substr(1).trim().split(' ');\n                ctx = (0,_filter__WEBPACK_IMPORTED_MODULE_1__.closest)((0,_filter__WEBPACK_IMPORTED_MODULE_1__.parent)(context), selectors[0]);\n                sel = selectors.slice(1).join(' ').trim();\n                if (!sel.length && split.length === 1) {\n                    return ctx;\n                }\n            }\n\n            if (sel[0] === '-') {\n                const selectors = sel.substr(1).trim().split(' ');\n                const prev = (ctx || context).previousElementSibling;\n                ctx = (0,_filter__WEBPACK_IMPORTED_MODULE_1__.matches)(prev, sel.substr(1)) ? prev : null;\n                sel = selectors.slice(1).join(' ');\n            }\n\n            if (ctx) {\n                selector += `${selector ? ',' : ''}${domPath(ctx)} ${sel}`;\n            }\n        }\n\n        context = document;\n    }\n\n    try {\n        return context[queryFn](selector);\n    } catch (e) {\n        return null;\n    }\n}\n\nconst selectorRe = /.*?[^\\\\](?:,|$)/g;\n\nconst splitSelector = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.memoize)((selector) =>\n    selector.match(selectorRe).map((selector) => selector.replace(/,$/, '').trim())\n);\n\nfunction domPath(element) {\n    const names = [];\n    while (element.parentNode) {\n        const id = (0,_attr__WEBPACK_IMPORTED_MODULE_2__.attr)(element, 'id');\n        if (id) {\n            names.unshift(`#${escape(id)}`);\n            break;\n        } else {\n            let { tagName } = element;\n            if (tagName !== 'HTML') {\n                tagName += `:nth-child(${(0,_filter__WEBPACK_IMPORTED_MODULE_1__.index)(element) + 1})`;\n            }\n            names.unshift(tagName);\n            element = element.parentNode;\n        }\n    }\n    return names.join(' > ');\n}\n\nfunction escape(css) {\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isString)(css) ? CSS.escape(css) : '';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvc2VsZWN0b3IuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBOEI7QUFDNkI7QUFDYTs7QUFFakU7QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQLFdBQVcsNkNBQU07QUFDakI7O0FBRU87QUFDUCxXQUFXLDhDQUFPO0FBQ2xCOztBQUVBO0FBQ0EsMEJBQTBCLDhDQUFPOztBQUVqQztBQUNBLFlBQVksK0NBQVEsOENBQThDLGlEQUFVO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw4Q0FBTzs7QUFFeEI7QUFDQSxzQkFBc0IsK0NBQVE7QUFDOUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQU8sQ0FBQywrQ0FBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBTztBQUM3QjtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLG9CQUFvQixFQUFFLGNBQWMsRUFBRSxJQUFJO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsOENBQU87QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkNBQUk7QUFDdkI7QUFDQSw4QkFBOEIsV0FBVztBQUN6QztBQUNBLFVBQVU7QUFDVixrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLHlDQUF5Qyw4Q0FBSyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsV0FBVywrQ0FBUTtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91aWtpdC9zcmMvanMvdXRpbC9zZWxlY3Rvci5qcz8yMzgxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF0dHIgfSBmcm9tICcuL2F0dHInO1xuaW1wb3J0IHsgY2xvc2VzdCwgaW5kZXgsIG1hdGNoZXMsIHBhcmVudCB9IGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCB7IGlzRG9jdW1lbnQsIGlzU3RyaW5nLCBtZW1vaXplLCB0b05vZGUsIHRvTm9kZXMgfSBmcm9tICcuL2xhbmcnO1xuXG5leHBvcnQgZnVuY3Rpb24gcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmluZChzZWxlY3RvciwgZ2V0Q29udGV4dChzZWxlY3RvciwgY29udGV4dCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlBbGwoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmluZEFsbChzZWxlY3RvciwgZ2V0Q29udGV4dChzZWxlY3RvciwgY29udGV4dCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZChzZWxlY3RvciwgY29udGV4dCkge1xuICAgIHJldHVybiB0b05vZGUoX3F1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0LCAncXVlcnlTZWxlY3RvcicpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBbGwoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdG9Ob2RlcyhfcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQsICdxdWVyeVNlbGVjdG9yQWxsJykpO1xufVxuXG5jb25zdCBjb250ZXh0U2VsZWN0b3JSZSA9IC8oXnxbXlxcXFxdLClcXHMqWyE+K34tXS87XG5jb25zdCBpc0NvbnRleHRTZWxlY3RvciA9IG1lbW9pemUoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5tYXRjaChjb250ZXh0U2VsZWN0b3JSZSkpO1xuXG5mdW5jdGlvbiBnZXRDb250ZXh0KHNlbGVjdG9yLCBjb250ZXh0ID0gZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gKGlzU3RyaW5nKHNlbGVjdG9yKSAmJiBpc0NvbnRleHRTZWxlY3RvcihzZWxlY3RvcikpIHx8IGlzRG9jdW1lbnQoY29udGV4dClcbiAgICAgICAgPyBjb250ZXh0XG4gICAgICAgIDogY29udGV4dC5vd25lckRvY3VtZW50O1xufVxuXG5jb25zdCBjb250ZXh0U2FuaXRpemVSZSA9IC8oWyE+K34tXSkoPz1cXHMrWyE+K34tXXxcXHMqJCkvZztcbmNvbnN0IHNhbmF0aXplID0gbWVtb2l6ZSgoc2VsZWN0b3IpID0+IHNlbGVjdG9yLnJlcGxhY2UoY29udGV4dFNhbml0aXplUmUsICckMSAqJykpO1xuXG5mdW5jdGlvbiBfcXVlcnkoc2VsZWN0b3IsIGNvbnRleHQgPSBkb2N1bWVudCwgcXVlcnlGbikge1xuICAgIGlmICghc2VsZWN0b3IgfHwgIWlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfVxuXG4gICAgc2VsZWN0b3IgPSBzYW5hdGl6ZShzZWxlY3Rvcik7XG5cbiAgICBpZiAoaXNDb250ZXh0U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHNlbGVjdG9yID0gJyc7XG4gICAgICAgIGZvciAobGV0IHNlbCBvZiBzcGxpdCkge1xuICAgICAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmIChzZWxbMF0gPT09ICchJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHNlbC5zdWJzdHIoMSkudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgY3R4ID0gY2xvc2VzdChwYXJlbnQoY29udGV4dCksIHNlbGVjdG9yc1swXSk7XG4gICAgICAgICAgICAgICAgc2VsID0gc2VsZWN0b3JzLnNsaWNlKDEpLmpvaW4oJyAnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWwubGVuZ3RoICYmIHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbFswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3JzID0gc2VsLnN1YnN0cigxKS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gKGN0eCB8fCBjb250ZXh0KS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN0eCA9IG1hdGNoZXMocHJldiwgc2VsLnN1YnN0cigxKSkgPyBwcmV2IDogbnVsbDtcbiAgICAgICAgICAgICAgICBzZWwgPSBzZWxlY3RvcnMuc2xpY2UoMSkuam9pbignICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgKz0gYCR7c2VsZWN0b3IgPyAnLCcgOiAnJ30ke2RvbVBhdGgoY3R4KX0gJHtzZWx9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQgPSBkb2N1bWVudDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29udGV4dFtxdWVyeUZuXShzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmNvbnN0IHNlbGVjdG9yUmUgPSAvLio/W15cXFxcXSg/Oix8JCkvZztcblxuY29uc3Qgc3BsaXRTZWxlY3RvciA9IG1lbW9pemUoKHNlbGVjdG9yKSA9PlxuICAgIHNlbGVjdG9yLm1hdGNoKHNlbGVjdG9yUmUpLm1hcCgoc2VsZWN0b3IpID0+IHNlbGVjdG9yLnJlcGxhY2UoLywkLywgJycpLnRyaW0oKSlcbik7XG5cbmZ1bmN0aW9uIGRvbVBhdGgoZWxlbWVudCkge1xuICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb25zdCBpZCA9IGF0dHIoZWxlbWVudCwgJ2lkJyk7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgbmFtZXMudW5zaGlmdChgIyR7ZXNjYXBlKGlkKX1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgdGFnTmFtZSB9ID0gZWxlbWVudDtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lICE9PSAnSFRNTCcpIHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lICs9IGA6bnRoLWNoaWxkKCR7aW5kZXgoZWxlbWVudCkgKyAxfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZXMudW5zaGlmdCh0YWdOYW1lKTtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLmpvaW4oJyA+ICcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlKGNzcykge1xuICAgIHJldHVybiBpc1N0cmluZyhjc3MpID8gQ1NTLmVzY2FwZShjc3MpIDogJyc7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/selector.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/style.js":
/*!*************************************************!*\
  !*** ./node_modules/uikit/src/js/util/style.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"css\": () => (/* binding */ css),\n/* harmony export */   \"getCssVar\": () => (/* binding */ getCssVar),\n/* harmony export */   \"propName\": () => (/* binding */ propName)\n/* harmony export */ });\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\nconst cssNumber = {\n    'animation-iteration-count': true,\n    'column-count': true,\n    'fill-opacity': true,\n    'flex-grow': true,\n    'flex-shrink': true,\n    'font-weight': true,\n    'line-height': true,\n    opacity: true,\n    order: true,\n    orphans: true,\n    'stroke-dasharray': true,\n    'stroke-dashoffset': true,\n    widows: true,\n    'z-index': true,\n    zoom: true,\n};\n\nfunction css(element, property, value, priority = '') {\n    const elements = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.toNodes)(element);\n    for (const element of elements) {\n        if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isString)(property)) {\n            property = propName(property);\n\n            if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(value)) {\n                return getComputedStyle(element).getPropertyValue(property);\n            } else {\n                element.style.setProperty(\n                    property,\n                    (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isNumeric)(value) && !cssNumber[property]\n                        ? `${value}px`\n                        : value || (0,_lang__WEBPACK_IMPORTED_MODULE_0__.isNumber)(value)\n                        ? value\n                        : '',\n                    priority\n                );\n            }\n        } else if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isArray)(property)) {\n            const props = {};\n            for (const prop of property) {\n                props[prop] = css(element, prop);\n            }\n            return props;\n        } else if ((0,_lang__WEBPACK_IMPORTED_MODULE_0__.isObject)(property)) {\n            priority = value;\n            (0,_lang__WEBPACK_IMPORTED_MODULE_0__.each)(property, (value, property) => css(element, property, value, priority));\n        }\n    }\n    return elements[0];\n}\n\nconst propertyRe = /^\\s*([\"'])?(.*?)\\1\\s*$/;\nfunction getCssVar(name, element = document.documentElement) {\n    return css(element, `--uk-${name}`).replace(propertyRe, '$2');\n}\n\n// https://drafts.csswg.org/cssom/#dom-cssstyledeclaration-setproperty\nconst propName = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.memoize)((name) => vendorPropName(name));\n\nconst cssPrefixes = ['webkit', 'moz'];\n\nfunction vendorPropName(name) {\n    if (name[0] === '-') {\n        return name;\n    }\n\n    name = (0,_lang__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(name);\n\n    const { style } = document.documentElement;\n\n    if (name in style) {\n        return name;\n    }\n\n    let i = cssPrefixes.length,\n        prefixedName;\n\n    while (i--) {\n        prefixedName = `-${cssPrefixes[i]}-${name}`;\n        if (prefixedName in style) {\n            return prefixedName;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvc3R5bGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVdnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHFCQUFxQiw4Q0FBTztBQUM1QjtBQUNBLFlBQVksK0NBQVE7QUFDcEI7O0FBRUEsZ0JBQWdCLGtEQUFXO0FBQzNCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQVM7QUFDN0IsNkJBQTZCLE1BQU07QUFDbkMsbUNBQW1DLCtDQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsOENBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUywrQ0FBUTtBQUMzQjtBQUNBLFlBQVksMkNBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQLGdDQUFnQyxLQUFLO0FBQ3JDOztBQUVBO0FBQ08saUJBQWlCLDhDQUFPOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGdEQUFTOztBQUVwQixZQUFZLFFBQVE7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGVBQWUsR0FBRyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvc3R5bGUuanM/ZjdmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIGVhY2gsXG4gICAgaHlwaGVuYXRlLFxuICAgIGlzQXJyYXksXG4gICAgaXNOdW1iZXIsXG4gICAgaXNOdW1lcmljLFxuICAgIGlzT2JqZWN0LFxuICAgIGlzU3RyaW5nLFxuICAgIGlzVW5kZWZpbmVkLFxuICAgIG1lbW9pemUsXG4gICAgdG9Ob2Rlcyxcbn0gZnJvbSAnLi9sYW5nJztcblxuY29uc3QgY3NzTnVtYmVyID0ge1xuICAgICdhbmltYXRpb24taXRlcmF0aW9uLWNvdW50JzogdHJ1ZSxcbiAgICAnY29sdW1uLWNvdW50JzogdHJ1ZSxcbiAgICAnZmlsbC1vcGFjaXR5JzogdHJ1ZSxcbiAgICAnZmxleC1ncm93JzogdHJ1ZSxcbiAgICAnZmxleC1zaHJpbmsnOiB0cnVlLFxuICAgICdmb250LXdlaWdodCc6IHRydWUsXG4gICAgJ2xpbmUtaGVpZ2h0JzogdHJ1ZSxcbiAgICBvcGFjaXR5OiB0cnVlLFxuICAgIG9yZGVyOiB0cnVlLFxuICAgIG9ycGhhbnM6IHRydWUsXG4gICAgJ3N0cm9rZS1kYXNoYXJyYXknOiB0cnVlLFxuICAgICdzdHJva2UtZGFzaG9mZnNldCc6IHRydWUsXG4gICAgd2lkb3dzOiB0cnVlLFxuICAgICd6LWluZGV4JzogdHJ1ZSxcbiAgICB6b29tOiB0cnVlLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNzcyhlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5ID0gJycpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRvTm9kZXMoZWxlbWVudCk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcE5hbWUocHJvcGVydHkpO1xuXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBpc051bWVyaWModmFsdWUpICYmICFjc3NOdW1iZXJbcHJvcGVydHldXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAke3ZhbHVlfXB4YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSB8fCBpc051bWJlcih2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHByb3BzW3Byb3BdID0gY3NzKGVsZW1lbnQsIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSB2YWx1ZTtcbiAgICAgICAgICAgIGVhY2gocHJvcGVydHksICh2YWx1ZSwgcHJvcGVydHkpID0+IGNzcyhlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzWzBdO1xufVxuXG5jb25zdCBwcm9wZXJ0eVJlID0gL15cXHMqKFtcIiddKT8oLio/KVxcMVxccyokLztcbmV4cG9ydCBmdW5jdGlvbiBnZXRDc3NWYXIobmFtZSwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBjc3MoZWxlbWVudCwgYC0tdWstJHtuYW1lfWApLnJlcGxhY2UocHJvcGVydHlSZSwgJyQyJyk7XG59XG5cbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jZG9tLWNzc3N0eWxlZGVjbGFyYXRpb24tc2V0cHJvcGVydHlcbmV4cG9ydCBjb25zdCBwcm9wTmFtZSA9IG1lbW9pemUoKG5hbWUpID0+IHZlbmRvclByb3BOYW1lKG5hbWUpKTtcblxuY29uc3QgY3NzUHJlZml4ZXMgPSBbJ3dlYmtpdCcsICdtb3onXTtcblxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUobmFtZSkge1xuICAgIGlmIChuYW1lWzBdID09PSAnLScpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgbmFtZSA9IGh5cGhlbmF0ZShuYW1lKTtcblxuICAgIGNvbnN0IHsgc3R5bGUgfSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgIGlmIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIGxldCBpID0gY3NzUHJlZml4ZXMubGVuZ3RoLFxuICAgICAgICBwcmVmaXhlZE5hbWU7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHByZWZpeGVkTmFtZSA9IGAtJHtjc3NQcmVmaXhlc1tpXX0tJHtuYW1lfWA7XG4gICAgICAgIGlmIChwcmVmaXhlZE5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXhlZE5hbWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/style.js\n");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/viewport.js":
/*!****************************************************!*\
  !*** ./node_modules/uikit/src/js/util/viewport.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isInView\": () => (/* binding */ isInView),\n/* harmony export */   \"offsetViewport\": () => (/* binding */ offsetViewport),\n/* harmony export */   \"scrollIntoView\": () => (/* binding */ scrollIntoView),\n/* harmony export */   \"scrollParents\": () => (/* binding */ scrollParents),\n/* harmony export */   \"scrollTop\": () => (/* binding */ scrollTop),\n/* harmony export */   \"scrolledOver\": () => (/* binding */ scrolledOver)\n/* harmony export */ });\n/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style */ \"./node_modules/uikit/src/js/util/style.js\");\n/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter */ \"./node_modules/uikit/src/js/util/filter.js\");\n/* harmony import */ var _dimensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dimensions */ \"./node_modules/uikit/src/js/util/dimensions.js\");\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n\n\n\n\n\nfunction isInView(element, offsetTop = 0, offsetLeft = 0) {\n    if (!(0,_filter__WEBPACK_IMPORTED_MODULE_0__.isVisible)(element)) {\n        return false;\n    }\n\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_1__.intersectRect)(\n        ...scrollParents(element)\n            .map((parent) => {\n                const { top, left, bottom, right } = offsetViewport(parent);\n\n                return {\n                    top: top - offsetTop,\n                    left: left - offsetLeft,\n                    bottom: bottom + offsetTop,\n                    right: right + offsetLeft,\n                };\n            })\n            .concat((0,_dimensions__WEBPACK_IMPORTED_MODULE_2__.offset)(element))\n    );\n}\n\nfunction scrollTop(element, top) {\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_1__.isWindow)(element) || (0,_lang__WEBPACK_IMPORTED_MODULE_1__.isDocument)(element)) {\n        element = scrollingElement(element);\n    } else {\n        element = (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toNode)(element);\n    }\n\n    if ((0,_lang__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(top)) {\n        return element.scrollTop;\n    } else {\n        element.scrollTop = top;\n    }\n}\n\nfunction scrollIntoView(element, { offset: offsetBy = 0 } = {}) {\n    const parents = (0,_filter__WEBPACK_IMPORTED_MODULE_0__.isVisible)(element) ? scrollParents(element) : [];\n    return parents.reduce(\n        (fn, scrollElement, i) => {\n            const { scrollTop, scrollHeight, offsetHeight } = scrollElement;\n            const viewport = offsetViewport(scrollElement);\n            const maxScroll = scrollHeight - viewport.height;\n            const { height: elHeight, top: elTop } = parents[i - 1]\n                ? offsetViewport(parents[i - 1])\n                : (0,_dimensions__WEBPACK_IMPORTED_MODULE_2__.offset)(element);\n\n            let top = Math.ceil(elTop - viewport.top - offsetBy + scrollTop);\n\n            if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) {\n                top += offsetBy;\n            } else {\n                offsetBy = 0;\n            }\n\n            if (top > maxScroll) {\n                offsetBy -= top - maxScroll;\n                top = maxScroll;\n            } else if (top < 0) {\n                offsetBy -= top;\n                top = 0;\n            }\n\n            return () => scrollTo(scrollElement, top - scrollTop).then(fn);\n        },\n        () => Promise.resolve()\n    )();\n\n    function scrollTo(element, top) {\n        return new Promise((resolve) => {\n            const scroll = element.scrollTop;\n            const duration = getDuration(Math.abs(top));\n            const start = Date.now();\n\n            (function step() {\n                const percent = ease((0,_lang__WEBPACK_IMPORTED_MODULE_1__.clamp)((Date.now() - start) / duration));\n\n                scrollTop(element, scroll + top * percent);\n\n                // scroll more if we have not reached our destination\n                if (percent === 1) {\n                    resolve();\n                } else {\n                    requestAnimationFrame(step);\n                }\n            })();\n        });\n    }\n\n    function getDuration(dist) {\n        return 40 * Math.pow(dist, 0.375);\n    }\n\n    function ease(k) {\n        return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n}\n\nfunction scrolledOver(element, startOffset = 0, endOffset = 0) {\n    if (!(0,_filter__WEBPACK_IMPORTED_MODULE_0__.isVisible)(element)) {\n        return 0;\n    }\n\n    const [scrollElement] = scrollParents(element, /auto|scroll/, true);\n    const { scrollHeight, scrollTop } = scrollElement;\n    const { height: viewportHeight } = offsetViewport(scrollElement);\n    const maxScroll = scrollHeight - viewportHeight;\n    const elementOffsetTop = (0,_dimensions__WEBPACK_IMPORTED_MODULE_2__.offsetPosition)(element)[0] - (0,_dimensions__WEBPACK_IMPORTED_MODULE_2__.offsetPosition)(scrollElement)[0];\n\n    const start = Math.max(0, elementOffsetTop - viewportHeight + startOffset);\n    const end = Math.min(maxScroll, elementOffsetTop + element.offsetHeight - endOffset);\n\n    return (0,_lang__WEBPACK_IMPORTED_MODULE_1__.clamp)((scrollTop - start) / (end - start));\n}\n\nfunction scrollParents(element, overflowRe = /auto|scroll|hidden/, scrollable = false) {\n    const scrollEl = scrollingElement(element);\n\n    let ancestors = (0,_filter__WEBPACK_IMPORTED_MODULE_0__.parents)(element).reverse();\n    ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1);\n\n    const fixedIndex = (0,_lang__WEBPACK_IMPORTED_MODULE_1__.findIndex)(ancestors, (el) => (0,_style__WEBPACK_IMPORTED_MODULE_3__.css)(el, 'position') === 'fixed');\n    if (~fixedIndex) {\n        ancestors = ancestors.slice(fixedIndex);\n    }\n\n    return [scrollEl]\n        .concat(\n            ancestors.filter(\n                (parent) =>\n                    overflowRe.test((0,_style__WEBPACK_IMPORTED_MODULE_3__.css)(parent, 'overflow')) &&\n                    (!scrollable || parent.scrollHeight > offsetViewport(parent).height)\n            )\n        )\n        .reverse();\n}\n\nfunction offsetViewport(scrollElement) {\n    let viewportElement = getViewport(scrollElement);\n\n    // iOS 12 returns <body> as scrollingElement\n    if (viewportElement === scrollingElement(viewportElement)) {\n        viewportElement = document.documentElement;\n    }\n\n    let rect = (0,_dimensions__WEBPACK_IMPORTED_MODULE_2__.offset)(viewportElement);\n    for (let [prop, dir, start, end] of [\n        ['width', 'x', 'left', 'right'],\n        ['height', 'y', 'top', 'bottom'],\n    ]) {\n        if (!(0,_lang__WEBPACK_IMPORTED_MODULE_1__.isWindow)(getViewport(viewportElement))) {\n            rect[start] += (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toFloat)((0,_style__WEBPACK_IMPORTED_MODULE_3__.css)(viewportElement, `border${(0,_lang__WEBPACK_IMPORTED_MODULE_1__.ucfirst)(start)}Width`));\n        }\n        rect[prop] = rect[dir] = (\n            (0,_lang__WEBPACK_IMPORTED_MODULE_1__.isWindow)(viewportElement) ? scrollingElement(viewportElement) : viewportElement\n        )[`client${(0,_lang__WEBPACK_IMPORTED_MODULE_1__.ucfirst)(prop)}`];\n        rect[end] = rect[prop] + rect[start];\n    }\n    return rect;\n}\n\nfunction scrollingElement(element) {\n    const {\n        document: { scrollingElement },\n    } = (0,_lang__WEBPACK_IMPORTED_MODULE_1__.toWindow)(element);\n    return scrollingElement;\n}\n\nfunction getViewport(scrollElement) {\n    return scrollElement === scrollingElement(scrollElement) ? window : scrollElement;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvdmlld3BvcnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE4QjtBQUNnQjtBQUNRO0FBWXRDOztBQUVUO0FBQ1AsU0FBUyxrREFBUztBQUNsQjtBQUNBOztBQUVBLFdBQVcsb0RBQWE7QUFDeEI7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixvQkFBb0IsbURBQU07QUFDMUI7QUFDQTs7QUFFTztBQUNQLFFBQVEsK0NBQVEsYUFBYSxpREFBVTtBQUN2QztBQUNBLE1BQU07QUFDTixrQkFBa0IsNkNBQU07QUFDeEI7O0FBRUEsUUFBUSxrREFBVztBQUNuQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRU8sbUNBQW1DLHVCQUF1QixJQUFJO0FBQ3JFLG9CQUFvQixrREFBUztBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBLGtCQUFrQixtREFBTTs7QUFFeEI7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLDRDQUFLOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsU0FBUyxrREFBUztBQUNsQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEMsWUFBWSx5QkFBeUI7QUFDckM7QUFDQSw2QkFBNkIsMkRBQWMsZUFBZSwyREFBYzs7QUFFeEU7QUFDQTs7QUFFQSxXQUFXLDRDQUFLO0FBQ2hCOztBQUVPO0FBQ1A7O0FBRUEsb0JBQW9CLGdEQUFPO0FBQzNCOztBQUVBLHVCQUF1QixnREFBUyxvQkFBb0IsMkNBQUc7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1EQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQ0FBUTtBQUNyQiwyQkFBMkIsOENBQU8sQ0FBQywyQ0FBRywyQkFBMkIsOENBQU8sUUFBUTtBQUNoRjtBQUNBO0FBQ0EsWUFBWSwrQ0FBUTtBQUNwQixtQkFBbUIsOENBQU8sT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QyxNQUFNLEVBQUUsK0NBQVE7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWlraXQvc3JjL2pzL3V0aWwvdmlld3BvcnQuanM/OTRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjc3MgfSBmcm9tICcuL3N0eWxlJztcbmltcG9ydCB7IGlzVmlzaWJsZSwgcGFyZW50cyB9IGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCB7IG9mZnNldCwgb2Zmc2V0UG9zaXRpb24gfSBmcm9tICcuL2RpbWVuc2lvbnMnO1xuaW1wb3J0IHtcbiAgICBjbGFtcCxcbiAgICBmaW5kSW5kZXgsXG4gICAgaW50ZXJzZWN0UmVjdCxcbiAgICBpc0RvY3VtZW50LFxuICAgIGlzVW5kZWZpbmVkLFxuICAgIGlzV2luZG93LFxuICAgIHRvRmxvYXQsXG4gICAgdG9Ob2RlLFxuICAgIHRvV2luZG93LFxuICAgIHVjZmlyc3QsXG59IGZyb20gJy4vbGFuZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luVmlldyhlbGVtZW50LCBvZmZzZXRUb3AgPSAwLCBvZmZzZXRMZWZ0ID0gMCkge1xuICAgIGlmICghaXNWaXNpYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0UmVjdChcbiAgICAgICAgLi4uc2Nyb2xsUGFyZW50cyhlbGVtZW50KVxuICAgICAgICAgICAgLm1hcCgocGFyZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSA9IG9mZnNldFZpZXdwb3J0KHBhcmVudCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCAtIG9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogYm90dG9tICsgb2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogcmlnaHQgKyBvZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNvbmNhdChvZmZzZXQoZWxlbWVudCkpXG4gICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvcChlbGVtZW50LCB0b3ApIHtcbiAgICBpZiAoaXNXaW5kb3coZWxlbWVudCkgfHwgaXNEb2N1bWVudChlbGVtZW50KSkge1xuICAgICAgICBlbGVtZW50ID0gc2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmIChpc1VuZGVmaW5lZCh0b3ApKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHRvcDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhlbGVtZW50LCB7IG9mZnNldDogb2Zmc2V0QnkgPSAwIH0gPSB7fSkge1xuICAgIGNvbnN0IHBhcmVudHMgPSBpc1Zpc2libGUoZWxlbWVudCkgPyBzY3JvbGxQYXJlbnRzKGVsZW1lbnQpIDogW107XG4gICAgcmV0dXJuIHBhcmVudHMucmVkdWNlKFxuICAgICAgICAoZm4sIHNjcm9sbEVsZW1lbnQsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIG9mZnNldEhlaWdodCB9ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBtYXhTY3JvbGwgPSBzY3JvbGxIZWlnaHQgLSB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCB7IGhlaWdodDogZWxIZWlnaHQsIHRvcDogZWxUb3AgfSA9IHBhcmVudHNbaSAtIDFdXG4gICAgICAgICAgICAgICAgPyBvZmZzZXRWaWV3cG9ydChwYXJlbnRzW2kgLSAxXSlcbiAgICAgICAgICAgICAgICA6IG9mZnNldChlbGVtZW50KTtcblxuICAgICAgICAgICAgbGV0IHRvcCA9IE1hdGguY2VpbChlbFRvcCAtIHZpZXdwb3J0LnRvcCAtIG9mZnNldEJ5ICsgc2Nyb2xsVG9wKTtcblxuICAgICAgICAgICAgaWYgKG9mZnNldEJ5ID4gMCAmJiBvZmZzZXRIZWlnaHQgPCBlbEhlaWdodCArIG9mZnNldEJ5KSB7XG4gICAgICAgICAgICAgICAgdG9wICs9IG9mZnNldEJ5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRCeSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b3AgPiBtYXhTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRCeSAtPSB0b3AgLSBtYXhTY3JvbGw7XG4gICAgICAgICAgICAgICAgdG9wID0gbWF4U2Nyb2xsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QnkgLT0gdG9wO1xuICAgICAgICAgICAgICAgIHRvcCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBzY3JvbGxUbyhzY3JvbGxFbGVtZW50LCB0b3AgLSBzY3JvbGxUb3ApLnRoZW4oZm4pO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiBQcm9taXNlLnJlc29sdmUoKVxuICAgICkoKTtcblxuICAgIGZ1bmN0aW9uIHNjcm9sbFRvKGVsZW1lbnQsIHRvcCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBnZXREdXJhdGlvbihNYXRoLmFicyh0b3ApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgKGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IGVhc2UoY2xhbXAoKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbikpO1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wKGVsZW1lbnQsIHNjcm9sbCArIHRvcCAqIHBlcmNlbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2Nyb2xsIG1vcmUgaWYgd2UgaGF2ZSBub3QgcmVhY2hlZCBvdXIgZGVzdGluYXRpb25cbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldER1cmF0aW9uKGRpc3QpIHtcbiAgICAgICAgcmV0dXJuIDQwICogTWF0aC5wb3coZGlzdCwgMC4zNzUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhc2Uoaykge1xuICAgICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbGVkT3ZlcihlbGVtZW50LCBzdGFydE9mZnNldCA9IDAsIGVuZE9mZnNldCA9IDApIHtcbiAgICBpZiAoIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb25zdCBbc2Nyb2xsRWxlbWVudF0gPSBzY3JvbGxQYXJlbnRzKGVsZW1lbnQsIC9hdXRvfHNjcm9sbC8sIHRydWUpO1xuICAgIGNvbnN0IHsgc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUb3AgfSA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgY29uc3QgeyBoZWlnaHQ6IHZpZXdwb3J0SGVpZ2h0IH0gPSBvZmZzZXRWaWV3cG9ydChzY3JvbGxFbGVtZW50KTtcbiAgICBjb25zdCBtYXhTY3JvbGwgPSBzY3JvbGxIZWlnaHQgLSB2aWV3cG9ydEhlaWdodDtcbiAgICBjb25zdCBlbGVtZW50T2Zmc2V0VG9wID0gb2Zmc2V0UG9zaXRpb24oZWxlbWVudClbMF0gLSBvZmZzZXRQb3NpdGlvbihzY3JvbGxFbGVtZW50KVswXTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZWxlbWVudE9mZnNldFRvcCAtIHZpZXdwb3J0SGVpZ2h0ICsgc3RhcnRPZmZzZXQpO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKG1heFNjcm9sbCwgZWxlbWVudE9mZnNldFRvcCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gZW5kT2Zmc2V0KTtcblxuICAgIHJldHVybiBjbGFtcCgoc2Nyb2xsVG9wIC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxQYXJlbnRzKGVsZW1lbnQsIG92ZXJmbG93UmUgPSAvYXV0b3xzY3JvbGx8aGlkZGVuLywgc2Nyb2xsYWJsZSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2Nyb2xsRWwgPSBzY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgbGV0IGFuY2VzdG9ycyA9IHBhcmVudHMoZWxlbWVudCkucmV2ZXJzZSgpO1xuICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5zbGljZShhbmNlc3RvcnMuaW5kZXhPZihzY3JvbGxFbCkgKyAxKTtcblxuICAgIGNvbnN0IGZpeGVkSW5kZXggPSBmaW5kSW5kZXgoYW5jZXN0b3JzLCAoZWwpID0+IGNzcyhlbCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpO1xuICAgIGlmICh+Zml4ZWRJbmRleCkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuc2xpY2UoZml4ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtzY3JvbGxFbF1cbiAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgIGFuY2VzdG9ycy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHBhcmVudCkgPT5cbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dSZS50ZXN0KGNzcyhwYXJlbnQsICdvdmVyZmxvdycpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXNjcm9sbGFibGUgfHwgcGFyZW50LnNjcm9sbEhlaWdodCA+IG9mZnNldFZpZXdwb3J0KHBhcmVudCkuaGVpZ2h0KVxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIC5yZXZlcnNlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvZmZzZXRWaWV3cG9ydChzY3JvbGxFbGVtZW50KSB7XG4gICAgbGV0IHZpZXdwb3J0RWxlbWVudCA9IGdldFZpZXdwb3J0KHNjcm9sbEVsZW1lbnQpO1xuXG4gICAgLy8gaU9TIDEyIHJldHVybnMgPGJvZHk+IGFzIHNjcm9sbGluZ0VsZW1lbnRcbiAgICBpZiAodmlld3BvcnRFbGVtZW50ID09PSBzY3JvbGxpbmdFbGVtZW50KHZpZXdwb3J0RWxlbWVudCkpIHtcbiAgICAgICAgdmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cblxuICAgIGxldCByZWN0ID0gb2Zmc2V0KHZpZXdwb3J0RWxlbWVudCk7XG4gICAgZm9yIChsZXQgW3Byb3AsIGRpciwgc3RhcnQsIGVuZF0gb2YgW1xuICAgICAgICBbJ3dpZHRoJywgJ3gnLCAnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBbJ2hlaWdodCcsICd5JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICBdKSB7XG4gICAgICAgIGlmICghaXNXaW5kb3coZ2V0Vmlld3BvcnQodmlld3BvcnRFbGVtZW50KSkpIHtcbiAgICAgICAgICAgIHJlY3Rbc3RhcnRdICs9IHRvRmxvYXQoY3NzKHZpZXdwb3J0RWxlbWVudCwgYGJvcmRlciR7dWNmaXJzdChzdGFydCl9V2lkdGhgKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdFtwcm9wXSA9IHJlY3RbZGlyXSA9IChcbiAgICAgICAgICAgIGlzV2luZG93KHZpZXdwb3J0RWxlbWVudCkgPyBzY3JvbGxpbmdFbGVtZW50KHZpZXdwb3J0RWxlbWVudCkgOiB2aWV3cG9ydEVsZW1lbnRcbiAgICAgICAgKVtgY2xpZW50JHt1Y2ZpcnN0KHByb3ApfWBdO1xuICAgICAgICByZWN0W2VuZF0gPSByZWN0W3Byb3BdICsgcmVjdFtzdGFydF07XG4gICAgfVxuICAgIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBzY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIGRvY3VtZW50OiB7IHNjcm9sbGluZ0VsZW1lbnQgfSxcbiAgICB9ID0gdG9XaW5kb3coZWxlbWVudCk7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0KHNjcm9sbEVsZW1lbnQpIHtcbiAgICByZXR1cm4gc2Nyb2xsRWxlbWVudCA9PT0gc2Nyb2xsaW5nRWxlbWVudChzY3JvbGxFbGVtZW50KSA/IHdpbmRvdyA6IHNjcm9sbEVsZW1lbnQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uikit/src/js/util/viewport.js\n");

/***/ })

}]);